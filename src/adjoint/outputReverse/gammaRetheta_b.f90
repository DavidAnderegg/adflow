!        generated by tapenade     (inria, ecuador team)
!  tapenade 3.16 (develop) - 10 nov 2023 18:24
!
module gammarethetamodel_b
  use constants
  implicit none

contains
!  differentiation of solve_local_re_thetat_eq in reverse (adjoint) mode (with options noisize i4 dr8 r8):
!   gradient     of useful results: *w re_thetat_eq
!   with respect to varying inputs: *w
!   plus diff mem management of: w:in
  subroutine solve_local_re_thetat_eq_b(re_thetat_eq, re_thetat_eqd, i, &
&   j, k)
    use blockpointers
    use constants
    use paramturb
    implicit none
! input/output variables
    integer(kind=inttype), intent(in) :: i, j, k
    real(kind=realtype) :: re_thetat_eq
    real(kind=realtype) :: re_thetat_eqd
! local variables
    real(kind=realtype) :: u, u_inv, fact, du_dx, du_dy, du_dz, du_ds, &
&   tu, f1, f2, f3, f
    real(kind=realtype) :: ud, u_invd, du_dxd, du_dyd, du_dzd, du_dsd, &
&   tud, f1d, f2d, f3d, fd
    real(kind=realtype) :: dudx, dudy, dudz, dvdx, dvdy, dvdz, dwdx, &
&   dwdy, dwdz
    real(kind=realtype) :: dudxd, dudyd, dudzd, dvdxd, dvdyd, dvdzd, &
&   dwdxd, dwdyd, dwdzd
    real(kind=realtype) :: lambda, thetat, residum, thetat_old, &
&   residum_old, thetat_new
    real(kind=realtype) :: lambdad, thetatd, residumd, thetat_oldd, &
&   residum_oldd, thetat_newd
    real(kind=realtype) :: re_thetat_eq_1, re_thetat_eq_2
    real(kind=realtype) :: re_thetat_eq_1d, re_thetat_eq_2d
    integer(kind=inttype) :: n
    intrinsic sqrt
    intrinsic max
    intrinsic min
    intrinsic exp
    intrinsic abs
    real(kind=realtype) :: x1
    real(kind=realtype) :: x1d
    real(kind=realtype) :: abs0
    real(kind=realtype) :: temp
    real(kind=realtype) :: temp0
    real(kind=realtype) :: temp1
    real(kind=realtype) :: temp2
    real(kind=realtype) :: tempd
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd2
    integer :: branch
    u = sqrt(w(i, j, k, ivx)**2 + w(i, j, k, ivy)**2 + w(i, j, k, ivz)**&
&     2)
    u_inv = 1.0/u
! compute the gradient of u in the cell center. use is made
! of the fact that the surrounding normals sum up to zero,
! such that the cell i,j,k does not give a contribution.
! since the gradient is scaled by a factor of 2*vol, we need to account for that
    fact = 1.0/(vol(i, j, k)*2.0)
    dudx = (w(i+1, j, k, ivx)*si(i, j, k, 1)-w(i-1, j, k, ivx)*si(i-1, j&
&     , k, 1)+w(i, j+1, k, ivx)*sj(i, j, k, 1)-w(i, j-1, k, ivx)*sj(i, j&
&     -1, k, 1)+w(i, j, k+1, ivx)*sk(i, j, k, 1)-w(i, j, k-1, ivx)*sk(i&
&     , j, k-1, 1))*fact
    dudy = (w(i+1, j, k, ivx)*si(i, j, k, 2)-w(i-1, j, k, ivx)*si(i-1, j&
&     , k, 2)+w(i, j+1, k, ivx)*sj(i, j, k, 2)-w(i, j-1, k, ivx)*sj(i, j&
&     -1, k, 2)+w(i, j, k+1, ivx)*sk(i, j, k, 2)-w(i, j, k-1, ivx)*sk(i&
&     , j, k-1, 2))*fact
    dudz = (w(i+1, j, k, ivx)*si(i, j, k, 3)-w(i-1, j, k, ivx)*si(i-1, j&
&     , k, 3)+w(i, j+1, k, ivx)*sj(i, j, k, 3)-w(i, j-1, k, ivx)*sj(i, j&
&     -1, k, 3)+w(i, j, k+1, ivx)*sk(i, j, k, 3)-w(i, j, k-1, ivx)*sk(i&
&     , j, k-1, 3))*fact
! idem for the gradient of v.
    dvdx = (w(i+1, j, k, ivy)*si(i, j, k, 1)-w(i-1, j, k, ivy)*si(i-1, j&
&     , k, 1)+w(i, j+1, k, ivy)*sj(i, j, k, 1)-w(i, j-1, k, ivy)*sj(i, j&
&     -1, k, 1)+w(i, j, k+1, ivy)*sk(i, j, k, 1)-w(i, j, k-1, ivy)*sk(i&
&     , j, k-1, 1))*fact
    dvdy = (w(i+1, j, k, ivy)*si(i, j, k, 2)-w(i-1, j, k, ivy)*si(i-1, j&
&     , k, 2)+w(i, j+1, k, ivy)*sj(i, j, k, 2)-w(i, j-1, k, ivy)*sj(i, j&
&     -1, k, 2)+w(i, j, k+1, ivy)*sk(i, j, k, 2)-w(i, j, k-1, ivy)*sk(i&
&     , j, k-1, 2))*fact
    dvdz = (w(i+1, j, k, ivy)*si(i, j, k, 3)-w(i-1, j, k, ivy)*si(i-1, j&
&     , k, 3)+w(i, j+1, k, ivy)*sj(i, j, k, 3)-w(i, j-1, k, ivy)*sj(i, j&
&     -1, k, 3)+w(i, j, k+1, ivy)*sk(i, j, k, 3)-w(i, j, k-1, ivy)*sk(i&
&     , j, k-1, 3))*fact
! and for the gradient of w.
    dwdx = (w(i+1, j, k, ivz)*si(i, j, k, 1)-w(i-1, j, k, ivz)*si(i-1, j&
&     , k, 1)+w(i, j+1, k, ivz)*sj(i, j, k, 1)-w(i, j-1, k, ivz)*sj(i, j&
&     -1, k, 1)+w(i, j, k+1, ivz)*sk(i, j, k, 1)-w(i, j, k-1, ivz)*sk(i&
&     , j, k-1, 1))*fact
    dwdy = (w(i+1, j, k, ivz)*si(i, j, k, 2)-w(i-1, j, k, ivz)*si(i-1, j&
&     , k, 2)+w(i, j+1, k, ivz)*sj(i, j, k, 2)-w(i, j-1, k, ivz)*sj(i, j&
&     -1, k, 2)+w(i, j, k+1, ivz)*sk(i, j, k, 2)-w(i, j, k-1, ivz)*sk(i&
&     , j, k-1, 2))*fact
    dwdz = (w(i+1, j, k, ivz)*si(i, j, k, 3)-w(i-1, j, k, ivz)*si(i-1, j&
&     , k, 3)+w(i, j+1, k, ivz)*sj(i, j, k, 3)-w(i, j-1, k, ivz)*sj(i, j&
&     -1, k, 3)+w(i, j, k+1, ivz)*sk(i, j, k, 3)-w(i, j, k-1, ivz)*sk(i&
&     , j, k-1, 3))*fact
    du_dx = u_inv*(w(i, j, k, ivx)*dudx+w(i, j, k, ivy)*dudy+w(i, j, k, &
&     ivz)*dudz)
    du_dy = u_inv*(w(i, j, k, ivx)*dvdx+w(i, j, k, ivy)*dvdy+w(i, j, k, &
&     ivz)*dvdz)
    du_dz = u_inv*(w(i, j, k, ivx)*dwdx+w(i, j, k, ivy)*dwdy+w(i, j, k, &
&     ivz)*dwdz)
    du_ds = w(i, j, k, ivx)/u*du_dx + w(i, j, k, ivy)/u*du_dy + w(i, j, &
&     k, ivz)/u*du_dz
    tu = 100.0*sqrt(2*w(i, j, k, itu1)/3)/u
    if (tu .lt. 0.027) then
      tu = 0.027
      call pushcontrol1b(0)
    else
      call pushcontrol1b(1)
      tu = tu
    end if
! now we need to solve for theta through newton's method. the number of iterations is hard-coded so tapenade is 
! able to differentiate it
    thetat = 0.01
    do n=1,10
      call pushreal8(lambda)
      lambda = w(i, j, k, irho)*thetat**2/rlv(i, j, k)*du_ds
      if (lambda .gt. 0.1) then
        x1 = 0.1
        call pushcontrol1b(0)
      else
        x1 = lambda
        call pushcontrol1b(1)
      end if
      if (x1 .lt. -0.1) then
        lambda = -0.1
        call pushcontrol1b(0)
      else
        lambda = x1
        call pushcontrol1b(1)
      end if
! compute f function
      f1 = 1.0 + 0.275*(1.0-exp(-(35.0*lambda)))*exp(-(tu/0.5))
      if (f1 .lt. 1.0) then
        f2 = 1.0
        call pushcontrol1b(0)
      else
        f2 = f1
        call pushcontrol1b(1)
      end if
      f3 = 1.0 - (-(12.986*lambda)-123.66*lambda**2-405.689*lambda**3)*&
&       exp(-((tu/1.5)**1.5))
      if (f2 .gt. f3) then
        call pushreal8(f)
        f = f3
        call pushcontrol1b(0)
      else
        call pushreal8(f)
        f = f2
        call pushcontrol1b(1)
      end if
      if (tu .gt. 1.3) then
        re_thetat_eq_1 = 331.50*(tu-0.5658)**(-0.671)*f
        call pushcontrol1b(0)
      else
        re_thetat_eq_1 = (1173.51-589.428*tu+0.2196*tu**(-2))*f
        call pushcontrol1b(1)
      end if
      re_thetat_eq_2 = w(i, j, k, irho)*u*thetat/rlv(i, j, k)
! residum which should go to 0
      call pushreal8(residum)
      residum = re_thetat_eq_1 - re_thetat_eq_2
! print *, 'iteration, thetat, residum, re_thetat_eq_1', n, thetat, residum, re_thetat_eq_1
! if we are in the first iteration, we need to kickstart the secant method first
      if (n .eq. 1) then
        residum_old = residum
        thetat_old = thetat
        call pushreal8(thetat)
        thetat = 0.5*thetat
        call pushcontrol2b(1)
      else
        if (residum .ge. 0.) then
          abs0 = residum
        else
          abs0 = -residum
        end if
! if the residum is basically 0, we cycle until we reach the end. (we cant drop out because tapenade would be unable to
! differentiate it)
        if (abs0 .lt. 1e-9) then
          call pushcontrol2b(0)
        else
! compute next step (secant method)
          thetat_new = (thetat_old*residum-thetat*residum_old)/(residum-&
&           residum_old)
! save values for next iteration
          call pushreal8(residum_old)
          residum_old = residum
          call pushreal8(thetat_old)
          thetat_old = thetat
          call pushreal8(thetat)
          thetat = thetat_new
          call pushcontrol2b(2)
        end if
      end if
    end do
    if (re_thetat_eq_1 .lt. 20.0) then
      re_thetat_eq_1d = 0.0_8
    else
      re_thetat_eq_1d = re_thetat_eqd
    end if
    tud = 0.0_8
    thetat_oldd = 0.0_8
    ud = 0.0_8
    du_dsd = 0.0_8
    residum_oldd = 0.0_8
    thetatd = 0.0_8
    do n=10,1,-1
      call popcontrol2b(branch)
      if (branch .eq. 0) then
        residumd = 0.0_8
      else if (branch .eq. 1) then
        call popreal8(thetat)
        thetatd = 0.5*thetatd + thetat_oldd
        residumd = residum_oldd
        thetat_oldd = 0.0_8
        residum_oldd = 0.0_8
      else
        call popreal8(thetat)
        thetat_newd = thetatd
        call popreal8(thetat_old)
        call popreal8(residum_old)
        tempd = thetat_newd/(residum-residum_old)
        thetatd = thetat_oldd - residum_old*tempd
        thetat_oldd = residum*tempd
        tempd1 = -((thetat_old*residum-thetat*residum_old)*tempd/(&
&         residum-residum_old))
        residumd = residum_oldd + thetat_old*tempd + tempd1
        residum_oldd = -(thetat*tempd) - tempd1
      end if
      call popreal8(residum)
      re_thetat_eq_1d = re_thetat_eq_1d + residumd
      re_thetat_eq_2d = -residumd
      wd(i, j, k, irho) = wd(i, j, k, irho) + u*thetat*re_thetat_eq_2d/&
&       rlv(i, j, k)
      tempd = w(i, j, k, irho)*re_thetat_eq_2d/rlv(i, j, k)
      ud = ud + thetat*tempd
      thetatd = thetatd + u*tempd
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        tud = tud - 0.671*(tu-0.5658)**(-1.671)*f*331.50*re_thetat_eq_1d
        fd = (tu-0.5658)**(-0.671)*331.50*re_thetat_eq_1d
      else
        temp2 = 0.2196/(tu*tu)
        tud = tud - (2*temp2*f/tu+589.428*f)*re_thetat_eq_1d
        fd = (temp2-589.428*tu+1173.51)*re_thetat_eq_1d
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        call popreal8(f)
        f3d = fd
        f2d = 0.0_8
      else
        call popreal8(f)
        f2d = fd
        f3d = 0.0_8
      end if
      temp2 = -((tu/1.5)**1.5)
      tempd1 = -(exp(temp2)*f3d)
      tud = tud + (tu/1.5)**0.5*exp(temp2)*(-(12.986*lambda)-123.66*&
&       lambda**2-405.689*lambda**3)*f3d
      lambdad = -((2*lambda*123.66+3*lambda**2*405.689+12.986)*tempd1)
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        f1d = 0.0_8
      else
        f1d = f2d
      end if
      lambdad = lambdad + 35.0*exp(-(35.0*lambda))*exp(-(tu/0.5))*0.275*&
&       f1d
      tud = tud - exp(-(tu/0.5))*(1.0-exp(-(35.0*lambda)))*0.275*f1d/0.5
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        x1d = 0.0_8
      else
        x1d = lambdad
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        lambdad = 0.0_8
      else
        lambdad = x1d
      end if
      call popreal8(lambda)
      wd(i, j, k, irho) = wd(i, j, k, irho) + thetat**2*du_ds*lambdad/&
&       rlv(i, j, k)
      tempd = w(i, j, k, irho)*lambdad/rlv(i, j, k)
      thetatd = thetatd + 2*thetat*du_ds*tempd
      du_dsd = du_dsd + thetat**2*tempd
      re_thetat_eq_1d = 0.0_8
    end do
    call popcontrol1b(branch)
    if (branch .eq. 0) tud = 0.0_8
    temp1 = 2*w(i, j, k, itu1)/3
    temp0 = sqrt(temp1)
    tempd = 100.0*tud/u
    if (.not.temp1 .eq. 0.0_8) wd(i, j, k, itu1) = wd(i, j, k, itu1) + 2&
&       *tempd/(3*2.0*temp0)
    ud = ud - temp0*tempd/u
    wd(i, j, k, ivx) = wd(i, j, k, ivx) + du_dx*du_dsd/u
    tempd = w(i, j, k, ivx)*du_dsd/u
    wd(i, j, k, ivy) = wd(i, j, k, ivy) + du_dy*du_dsd/u
    tempd1 = w(i, j, k, ivy)*du_dsd/u
    wd(i, j, k, ivz) = wd(i, j, k, ivz) + du_dz*du_dsd/u
    tempd2 = w(i, j, k, ivz)*du_dsd/u
    du_dzd = tempd2
    du_dyd = tempd1
    du_dxd = tempd
    temp2 = w(i, j, k, ivz)
    temp1 = w(i, j, k, ivy)
    temp0 = w(i, j, k, ivx)
    u_invd = (temp0*dwdx+temp1*dwdy+temp2*dwdz)*du_dzd
    tempd0 = u_inv*du_dzd
    wd(i, j, k, ivx) = wd(i, j, k, ivx) + dwdx*tempd0
    dwdxd = temp0*tempd0
    wd(i, j, k, ivy) = wd(i, j, k, ivy) + dwdy*tempd0
    dwdyd = temp1*tempd0
    wd(i, j, k, ivz) = wd(i, j, k, ivz) + dwdz*tempd0
    dwdzd = temp2*tempd0
    temp2 = w(i, j, k, ivz)
    temp1 = w(i, j, k, ivy)
    temp0 = w(i, j, k, ivx)
    u_invd = u_invd + (temp0*dvdx+temp1*dvdy+temp2*dvdz)*du_dyd
    tempd0 = u_inv*du_dyd
    wd(i, j, k, ivx) = wd(i, j, k, ivx) + dvdx*tempd0
    dvdxd = temp0*tempd0
    wd(i, j, k, ivy) = wd(i, j, k, ivy) + dvdy*tempd0
    dvdyd = temp1*tempd0
    wd(i, j, k, ivz) = wd(i, j, k, ivz) + dvdz*tempd0
    dvdzd = temp2*tempd0
    temp2 = w(i, j, k, ivz)
    temp1 = w(i, j, k, ivy)
    temp0 = w(i, j, k, ivx)
    u_invd = u_invd + (temp0*dudx+temp1*dudy+temp2*dudz)*du_dxd
    ud = ud - du_dz*tempd2/u - du_dy*tempd1/u - du_dx*tempd/u - u_invd/u&
&     **2
    tempd0 = u_inv*du_dxd
    wd(i, j, k, ivx) = wd(i, j, k, ivx) + dudx*tempd0
    dudxd = temp0*tempd0
    wd(i, j, k, ivy) = wd(i, j, k, ivy) + dudy*tempd0
    dudyd = temp1*tempd0
    wd(i, j, k, ivz) = wd(i, j, k, ivz) + dudz*tempd0
    dudzd = temp2*tempd0
    tempd = fact*dwdzd
    wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + si(i, j, k, 3)*tempd
    wd(i-1, j, k, ivz) = wd(i-1, j, k, ivz) - si(i-1, j, k, 3)*tempd
    wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + sj(i, j, k, 3)*tempd
    wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + sk(i, j, k, 3)*tempd
    wd(i, j-1, k, ivz) = wd(i, j-1, k, ivz) - sj(i, j-1, k, 3)*tempd
    wd(i, j, k-1, ivz) = wd(i, j, k-1, ivz) - sk(i, j, k-1, 3)*tempd
    tempd = fact*dwdyd
    wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + si(i, j, k, 2)*tempd
    wd(i-1, j, k, ivz) = wd(i-1, j, k, ivz) - si(i-1, j, k, 2)*tempd
    wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + sj(i, j, k, 2)*tempd
    wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + sk(i, j, k, 2)*tempd
    wd(i, j-1, k, ivz) = wd(i, j-1, k, ivz) - sj(i, j-1, k, 2)*tempd
    wd(i, j, k-1, ivz) = wd(i, j, k-1, ivz) - sk(i, j, k-1, 2)*tempd
    tempd = fact*dwdxd
    wd(i+1, j, k, ivz) = wd(i+1, j, k, ivz) + si(i, j, k, 1)*tempd
    wd(i-1, j, k, ivz) = wd(i-1, j, k, ivz) - si(i-1, j, k, 1)*tempd
    wd(i, j+1, k, ivz) = wd(i, j+1, k, ivz) + sj(i, j, k, 1)*tempd
    wd(i, j, k+1, ivz) = wd(i, j, k+1, ivz) + sk(i, j, k, 1)*tempd
    wd(i, j-1, k, ivz) = wd(i, j-1, k, ivz) - sj(i, j-1, k, 1)*tempd
    wd(i, j, k-1, ivz) = wd(i, j, k-1, ivz) - sk(i, j, k-1, 1)*tempd
    tempd = fact*dvdzd
    wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + si(i, j, k, 3)*tempd
    wd(i-1, j, k, ivy) = wd(i-1, j, k, ivy) - si(i-1, j, k, 3)*tempd
    wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + sj(i, j, k, 3)*tempd
    wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + sk(i, j, k, 3)*tempd
    wd(i, j-1, k, ivy) = wd(i, j-1, k, ivy) - sj(i, j-1, k, 3)*tempd
    wd(i, j, k-1, ivy) = wd(i, j, k-1, ivy) - sk(i, j, k-1, 3)*tempd
    tempd = fact*dvdyd
    wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + si(i, j, k, 2)*tempd
    wd(i-1, j, k, ivy) = wd(i-1, j, k, ivy) - si(i-1, j, k, 2)*tempd
    wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + sj(i, j, k, 2)*tempd
    wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + sk(i, j, k, 2)*tempd
    wd(i, j-1, k, ivy) = wd(i, j-1, k, ivy) - sj(i, j-1, k, 2)*tempd
    wd(i, j, k-1, ivy) = wd(i, j, k-1, ivy) - sk(i, j, k-1, 2)*tempd
    tempd = fact*dvdxd
    wd(i+1, j, k, ivy) = wd(i+1, j, k, ivy) + si(i, j, k, 1)*tempd
    wd(i-1, j, k, ivy) = wd(i-1, j, k, ivy) - si(i-1, j, k, 1)*tempd
    wd(i, j+1, k, ivy) = wd(i, j+1, k, ivy) + sj(i, j, k, 1)*tempd
    wd(i, j, k+1, ivy) = wd(i, j, k+1, ivy) + sk(i, j, k, 1)*tempd
    wd(i, j-1, k, ivy) = wd(i, j-1, k, ivy) - sj(i, j-1, k, 1)*tempd
    wd(i, j, k-1, ivy) = wd(i, j, k-1, ivy) - sk(i, j, k-1, 1)*tempd
    tempd = fact*dudzd
    wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + si(i, j, k, 3)*tempd
    wd(i-1, j, k, ivx) = wd(i-1, j, k, ivx) - si(i-1, j, k, 3)*tempd
    wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + sj(i, j, k, 3)*tempd
    wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + sk(i, j, k, 3)*tempd
    wd(i, j-1, k, ivx) = wd(i, j-1, k, ivx) - sj(i, j-1, k, 3)*tempd
    wd(i, j, k-1, ivx) = wd(i, j, k-1, ivx) - sk(i, j, k-1, 3)*tempd
    tempd = fact*dudyd
    wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + si(i, j, k, 2)*tempd
    wd(i-1, j, k, ivx) = wd(i-1, j, k, ivx) - si(i-1, j, k, 2)*tempd
    wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + sj(i, j, k, 2)*tempd
    wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + sk(i, j, k, 2)*tempd
    wd(i, j-1, k, ivx) = wd(i, j-1, k, ivx) - sj(i, j-1, k, 2)*tempd
    wd(i, j, k-1, ivx) = wd(i, j, k-1, ivx) - sk(i, j, k-1, 2)*tempd
    tempd = fact*dudxd
    wd(i+1, j, k, ivx) = wd(i+1, j, k, ivx) + si(i, j, k, 1)*tempd
    wd(i-1, j, k, ivx) = wd(i-1, j, k, ivx) - si(i-1, j, k, 1)*tempd
    wd(i, j+1, k, ivx) = wd(i, j+1, k, ivx) + sj(i, j, k, 1)*tempd
    wd(i, j, k+1, ivx) = wd(i, j, k+1, ivx) + sk(i, j, k, 1)*tempd
    wd(i, j-1, k, ivx) = wd(i, j-1, k, ivx) - sj(i, j-1, k, 1)*tempd
    wd(i, j, k-1, ivx) = wd(i, j, k-1, ivx) - sk(i, j, k-1, 1)*tempd
    temp = w(i, j, k, ivz)
    temp0 = w(i, j, k, ivy)
    temp1 = w(i, j, k, ivx)
    if (temp1**2 + temp0**2 + temp**2 .eq. 0.0_8) then
      tempd = 0.0_8
    else
      tempd = ud/(2.0*sqrt(temp1**2+temp0**2+temp**2))
    end if
    wd(i, j, k, ivx) = wd(i, j, k, ivx) + 2*temp1*tempd
    wd(i, j, k, ivy) = wd(i, j, k, ivy) + 2*temp0*tempd
    wd(i, j, k, ivz) = wd(i, j, k, ivz) + 2*temp*tempd
  end subroutine solve_local_re_thetat_eq_b

  subroutine solve_local_re_thetat_eq(re_thetat_eq, i, j, k)
    use blockpointers
    use constants
    use paramturb
    implicit none
! input/output variables
    integer(kind=inttype), intent(in) :: i, j, k
    real(kind=realtype), intent(out) :: re_thetat_eq
! local variables
    real(kind=realtype) :: u, u_inv, fact, du_dx, du_dy, du_dz, du_ds, &
&   tu, f1, f2, f3, f
    real(kind=realtype) :: dudx, dudy, dudz, dvdx, dvdy, dvdz, dwdx, &
&   dwdy, dwdz
    real(kind=realtype) :: lambda, thetat, residum, thetat_old, &
&   residum_old, thetat_new
    real(kind=realtype) :: re_thetat_eq_1, re_thetat_eq_2
    integer(kind=inttype) :: n
    intrinsic sqrt
    intrinsic max
    intrinsic min
    intrinsic exp
    intrinsic abs
    real(kind=realtype) :: x1
    real(kind=realtype) :: abs0
    u = sqrt(w(i, j, k, ivx)**2 + w(i, j, k, ivy)**2 + w(i, j, k, ivz)**&
&     2)
    u_inv = 1.0/u
! compute the gradient of u in the cell center. use is made
! of the fact that the surrounding normals sum up to zero,
! such that the cell i,j,k does not give a contribution.
! since the gradient is scaled by a factor of 2*vol, we need to account for that
    fact = 1.0/(vol(i, j, k)*2.0)
    dudx = (w(i+1, j, k, ivx)*si(i, j, k, 1)-w(i-1, j, k, ivx)*si(i-1, j&
&     , k, 1)+w(i, j+1, k, ivx)*sj(i, j, k, 1)-w(i, j-1, k, ivx)*sj(i, j&
&     -1, k, 1)+w(i, j, k+1, ivx)*sk(i, j, k, 1)-w(i, j, k-1, ivx)*sk(i&
&     , j, k-1, 1))*fact
    dudy = (w(i+1, j, k, ivx)*si(i, j, k, 2)-w(i-1, j, k, ivx)*si(i-1, j&
&     , k, 2)+w(i, j+1, k, ivx)*sj(i, j, k, 2)-w(i, j-1, k, ivx)*sj(i, j&
&     -1, k, 2)+w(i, j, k+1, ivx)*sk(i, j, k, 2)-w(i, j, k-1, ivx)*sk(i&
&     , j, k-1, 2))*fact
    dudz = (w(i+1, j, k, ivx)*si(i, j, k, 3)-w(i-1, j, k, ivx)*si(i-1, j&
&     , k, 3)+w(i, j+1, k, ivx)*sj(i, j, k, 3)-w(i, j-1, k, ivx)*sj(i, j&
&     -1, k, 3)+w(i, j, k+1, ivx)*sk(i, j, k, 3)-w(i, j, k-1, ivx)*sk(i&
&     , j, k-1, 3))*fact
! idem for the gradient of v.
    dvdx = (w(i+1, j, k, ivy)*si(i, j, k, 1)-w(i-1, j, k, ivy)*si(i-1, j&
&     , k, 1)+w(i, j+1, k, ivy)*sj(i, j, k, 1)-w(i, j-1, k, ivy)*sj(i, j&
&     -1, k, 1)+w(i, j, k+1, ivy)*sk(i, j, k, 1)-w(i, j, k-1, ivy)*sk(i&
&     , j, k-1, 1))*fact
    dvdy = (w(i+1, j, k, ivy)*si(i, j, k, 2)-w(i-1, j, k, ivy)*si(i-1, j&
&     , k, 2)+w(i, j+1, k, ivy)*sj(i, j, k, 2)-w(i, j-1, k, ivy)*sj(i, j&
&     -1, k, 2)+w(i, j, k+1, ivy)*sk(i, j, k, 2)-w(i, j, k-1, ivy)*sk(i&
&     , j, k-1, 2))*fact
    dvdz = (w(i+1, j, k, ivy)*si(i, j, k, 3)-w(i-1, j, k, ivy)*si(i-1, j&
&     , k, 3)+w(i, j+1, k, ivy)*sj(i, j, k, 3)-w(i, j-1, k, ivy)*sj(i, j&
&     -1, k, 3)+w(i, j, k+1, ivy)*sk(i, j, k, 3)-w(i, j, k-1, ivy)*sk(i&
&     , j, k-1, 3))*fact
! and for the gradient of w.
    dwdx = (w(i+1, j, k, ivz)*si(i, j, k, 1)-w(i-1, j, k, ivz)*si(i-1, j&
&     , k, 1)+w(i, j+1, k, ivz)*sj(i, j, k, 1)-w(i, j-1, k, ivz)*sj(i, j&
&     -1, k, 1)+w(i, j, k+1, ivz)*sk(i, j, k, 1)-w(i, j, k-1, ivz)*sk(i&
&     , j, k-1, 1))*fact
    dwdy = (w(i+1, j, k, ivz)*si(i, j, k, 2)-w(i-1, j, k, ivz)*si(i-1, j&
&     , k, 2)+w(i, j+1, k, ivz)*sj(i, j, k, 2)-w(i, j-1, k, ivz)*sj(i, j&
&     -1, k, 2)+w(i, j, k+1, ivz)*sk(i, j, k, 2)-w(i, j, k-1, ivz)*sk(i&
&     , j, k-1, 2))*fact
    dwdz = (w(i+1, j, k, ivz)*si(i, j, k, 3)-w(i-1, j, k, ivz)*si(i-1, j&
&     , k, 3)+w(i, j+1, k, ivz)*sj(i, j, k, 3)-w(i, j-1, k, ivz)*sj(i, j&
&     -1, k, 3)+w(i, j, k+1, ivz)*sk(i, j, k, 3)-w(i, j, k-1, ivz)*sk(i&
&     , j, k-1, 3))*fact
    du_dx = u_inv*(w(i, j, k, ivx)*dudx+w(i, j, k, ivy)*dudy+w(i, j, k, &
&     ivz)*dudz)
    du_dy = u_inv*(w(i, j, k, ivx)*dvdx+w(i, j, k, ivy)*dvdy+w(i, j, k, &
&     ivz)*dvdz)
    du_dz = u_inv*(w(i, j, k, ivx)*dwdx+w(i, j, k, ivy)*dwdy+w(i, j, k, &
&     ivz)*dwdz)
    du_ds = w(i, j, k, ivx)/u*du_dx + w(i, j, k, ivy)/u*du_dy + w(i, j, &
&     k, ivz)/u*du_dz
    tu = 100.0*sqrt(2*w(i, j, k, itu1)/3)/u
    if (tu .lt. 0.027) then
      tu = 0.027
    else
      tu = tu
    end if
! now we need to solve for theta through newton's method. the number of iterations is hard-coded so tapenade is 
! able to differentiate it
    thetat = 0.01
    do n=1,10
      lambda = w(i, j, k, irho)*thetat**2/rlv(i, j, k)*du_ds
      if (lambda .gt. 0.1) then
        x1 = 0.1
      else
        x1 = lambda
      end if
      if (x1 .lt. -0.1) then
        lambda = -0.1
      else
        lambda = x1
      end if
! compute f function
      f1 = 1.0 + 0.275*(1.0-exp(-(35.0*lambda)))*exp(-(tu/0.5))
      if (f1 .lt. 1.0) then
        f2 = 1.0
      else
        f2 = f1
      end if
      f3 = 1.0 - (-(12.986*lambda)-123.66*lambda**2-405.689*lambda**3)*&
&       exp(-((tu/1.5)**1.5))
      if (f2 .gt. f3) then
        f = f3
      else
        f = f2
      end if
      if (tu .gt. 1.3) then
        re_thetat_eq_1 = 331.50*(tu-0.5658)**(-0.671)*f
      else
        re_thetat_eq_1 = (1173.51-589.428*tu+0.2196*tu**(-2))*f
      end if
      re_thetat_eq_2 = w(i, j, k, irho)*u*thetat/rlv(i, j, k)
! residum which should go to 0
      residum = re_thetat_eq_1 - re_thetat_eq_2
! print *, 'iteration, thetat, residum, re_thetat_eq_1', n, thetat, residum, re_thetat_eq_1
! if we are in the first iteration, we need to kickstart the secant method first
      if (n .eq. 1) then
        residum_old = residum
        thetat_old = thetat
        thetat = 0.5*thetat
      else
        if (residum .ge. 0.) then
          abs0 = residum
        else
          abs0 = -residum
        end if
! if the residum is basically 0, we cycle until we reach the end. (we cant drop out because tapenade would be unable to
! differentiate it)
        if (abs0 .ge. 1e-9) then
! compute next step (secant method)
          thetat_new = (thetat_old*residum-thetat*residum_old)/(residum-&
&           residum_old)
! save values for next iteration
          residum_old = residum
          thetat_old = thetat
          thetat = thetat_new
        end if
      end if
    end do
    if (re_thetat_eq_1 .lt. 20.0) then
      re_thetat_eq = 20.0
    else
      re_thetat_eq = re_thetat_eq_1
    end if
  end subroutine solve_local_re_thetat_eq

!  differentiation of gammarethetasource in reverse (adjoint) mode (with options noisize i4 dr8 r8):
!   gradient     of useful results: *rev *w *scratch
!   with respect to varying inputs: *rev *w *scratch
!   rw status of diff variables: *rev:incr *w:incr *scratch:in-out
!   plus diff mem management of: rev:in w:in scratch:in
  subroutine gammarethetasource_b()
    use blockpointers
    use constants
    use variableconstants
    use paramturb
    implicit none
    integer(kind=inttype) :: i, j, k
    real(kind=realtype) :: re_thetat_eq, u2, u, lambda_theta, delta, &
&   f_theta_t, t, r_t, re_theta_c
    real(kind=realtype) :: re_thetat_eqd, u2d, ud, deltad, f_theta_td, &
&   td, r_td, re_theta_cd
    real(kind=realtype) :: re_s, f_length1, f_length, f_onset1, f_onset&
&   , f_turb, p_gamma, e_gamma, p_thetat
    real(kind=realtype) :: re_sd, f_length1d, f_lengthd, f_onset1d, &
&   f_onsetd, f_turbd, p_gammad, e_gammad, p_thetatd
    real(kind=realtype) :: re_omega, f_wake
    real(kind=realtype) :: re_omegad, f_waked
    intrinsic mod
    intrinsic sqrt
    intrinsic exp
    intrinsic max
    intrinsic min
    intrinsic sin
    intrinsic tanh
    real(kind=realtype) :: x1
    real(kind=realtype) :: x1d
    real(kind=realtype) :: x2
    real(kind=realtype) :: x2d
    real(kind=realtype) :: temp
    real(kind=realtype) :: tempd
    real(kind=realtype) :: temp0
    real(kind=realtype) :: temp1
    real(kind=realtype) :: temp2
    real(kind=realtype) :: temp3
    real(kind=realtype) :: tempd0
    real(kind=realtype) :: temp4
    real(kind=realtype) :: tempd1
    real(kind=realtype) :: tempd2
    real(kind=realtype) :: tempd3
    real(kind=realtype) :: temp5
    real(kind=realtype) :: temp6
    real(kind=realtype) :: tempd4
    real(kind=realtype) :: temp7
    real(kind=realtype) :: tempd5
    real(kind=realtype) :: tempd6
    real(kind=realtype) :: tempd7
    integer :: branch
    integer :: ii
!$bwd-of ii-loop 
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute re_thetat_eq
      call solve_local_re_thetat_eq(re_thetat_eq, i, j, k)
      u2 = w(i, j, k, ivx)**2 + w(i, j, k, ivy)**2 + w(i, j, k, ivz)**2
      u = sqrt(u2)
      re_omega = w(i, j, k, irho)*w(i, j, k, itu2)*d2wall(i, j, k)**2/&
&       rlv(i, j, k)
      f_wake = exp(-((re_omega/1e5)**2))
      delta = 375.0*sqrt(scratch(i, j, k, ivorticity))*w(i, j, k, &
&       itransition2)*d2wall(i, j, k)/(w(i, j, k, irho)*u)
      x2 = f_wake*exp(-((d2wall(i, j, k)/delta)**4))
      if (x2 .lt. 1.0 - ((rlmce2*w(i, j, k, itransition1)-1.0)/(rlmce2-1&
&         ))**2) then
        x1 = 1.0 - ((rlmce2*w(i, j, k, itransition1)-1.0)/(rlmce2-1))**2
        call pushcontrol1b(0)
      else
        x1 = x2
        call pushcontrol1b(1)
      end if
      if (x1 .gt. 1.0) then
        f_theta_t = 1.0
        call pushcontrol1b(0)
      else
        f_theta_t = x1
        call pushcontrol1b(1)
      end if
      t = 500.0*rlv(i, j, k)/(w(i, j, k, irho)*u2)
! todo: save this in scratch
      r_t = w(i, j, k, irho)*w(i, j, k, itu1)/(rlv(i, j, k)*w(i, j, k, &
&       itu2))
! todo: save this in scratch
      re_theta_c = 0.67*w(i, j, k, itransition2) + 24.0*sin(w(i, j, k, &
&       itransition2)/240.0+0.5) + 14.0
! todo: save this in scratch
      re_s = w(i, j, k, irho)*sqrt(scratch(i, j, k, istrain))*d2wall(i, &
&       j, k)**2/rev(i, j, k)
      f_length1 = exp(-(0.03*(w(i, j, k, itransition2)-460.0)))
      f_length = 44.0 - (44.0-(0.5-30000.0*(w(i, j, k, itransition2)-&
&       596.0)))/(1+f_length1)**(1/6)
! continue here
      f_onset1 = sqrt(re_s/(2.6*re_theta_c))
      f_onset = (tanh(6.0*(f_onset1-1.35))+1.0)/2.0
      f_turb = (1-f_onset)*exp(-r_t)
! since we need to divide by rho, rho does not appear here anymore
! print *, 'source terms: gamma, thetat', scratch(i, j, k, istransition1), scratch(i, j, k, istransition2)
      p_thetatd = scratchd(i, j, k, istransition2)
      scratchd(i, j, k, istransition2) = 0.0_8
      p_gammad = scratchd(i, j, k, istransition1)
      e_gammad = -scratchd(i, j, k, istransition1)
      scratchd(i, j, k, istransition1) = 0.0_8
      temp7 = (-f_theta_t+1.0)/t
      temp6 = w(i, j, k, irho)
      tempd6 = (re_thetat_eq-w(i, j, k, itransition2))*rlmcthetat*&
&       p_thetatd
      tempd7 = temp6*temp7*rlmcthetat*p_thetatd
      re_thetat_eqd = tempd7
      wd(i, j, k, itransition2) = wd(i, j, k, itransition2) - tempd7
      wd(i, j, k, irho) = wd(i, j, k, irho) + temp7*tempd6
      tempd5 = temp6*tempd6/t
      f_theta_td = -tempd5
      td = -(temp7*tempd5)
      temp7 = scratch(i, j, k, ivorticity)
      temp6 = sqrt(temp7)
      temp5 = rlmce2*w(i, j, k, itransition1) - 1.0
      temp3 = w(i, j, k, itransition1)
      temp2 = w(i, j, k, irho)
      temp4 = temp2*f_turb*temp3
      tempd6 = rlmca2*e_gammad
      tempd1 = temp5*temp6*tempd6
      wd(i, j, k, itransition1) = wd(i, j, k, itransition1) + rlmce2*&
&       temp4*temp6*tempd6
      if (.not.temp7 .eq. 0.0_8) scratchd(i, j, k, ivorticity) = &
&         scratchd(i, j, k, ivorticity) + temp4*temp5*tempd6/(2.0*temp6)
      wd(i, j, k, irho) = wd(i, j, k, irho) + f_turb*temp3*tempd1
      f_turbd = temp2*temp3*tempd1
      temp4 = -(rlmce1*w(i, j, k, itransition1)) + 1.0
      temp3 = w(i, j, k, irho)
      temp1 = w(i, j, k, itransition1)
      temp0 = temp1*f_onset
      temp = sqrt(temp0)
      temp5 = scratch(i, j, k, istrain)
      temp6 = sqrt(temp5)
      tempd3 = f_length*temp3*temp4*rlmca1*p_gammad
      tempd5 = temp6*temp*rlmca1*p_gammad
      wd(i, j, k, itransition1) = wd(i, j, k, itransition1) + temp2*&
&       f_turb*tempd1 - rlmce1*f_length*temp3*tempd5
      tempd6 = temp4*tempd5
      f_lengthd = temp3*tempd6
      wd(i, j, k, irho) = wd(i, j, k, irho) + f_length*tempd6
      if (.not.temp5 .eq. 0.0_8) scratchd(i, j, k, istrain) = scratchd(i&
&         , j, k, istrain) + temp*tempd3/(2.0*temp6)
      if (temp0 .eq. 0.0_8) then
        tempd4 = 0.0_8
      else
        tempd4 = temp6*tempd3/(2.0*temp)
      end if
      wd(i, j, k, itransition1) = wd(i, j, k, itransition1) + f_onset*&
&       tempd4
      f_onsetd = temp1*tempd4 - exp(-r_t)*f_turbd
      r_td = -(exp(-r_t)*(1-f_onset)*f_turbd)
      f_onset1d = 6.0*(1.0-tanh(6.0*(f_onset1-1.35))**2)*f_onsetd/2.0
      temp4 = re_s/(2.6*re_theta_c)
      if (temp4 .eq. 0.0_8) then
        tempd1 = 0.0_8
      else
        tempd1 = f_onset1d/(2.6*re_theta_c*2.0*sqrt(temp4))
      end if
      re_sd = tempd1
      re_theta_cd = -(2.6*temp4*tempd1)
      temp4 = (f_length1+1)**(1.0/6)
      if (f_length1 + 1 .le. 0.0_8 .and. (1.0/6 .eq. 0.0_8 .or. 1.0/6 &
&         .ne. int(1.0/6))) then
        f_length1d = 0.0_8
      else
        f_length1d = (f_length1+1)**(1.0/6-1)*(30000.0*(w(i, j, k, &
&         itransition2)-596.0)+43.5)*f_lengthd/(6*temp4**2)
      end if
      wd(i, j, k, itransition2) = wd(i, j, k, itransition2) - 30000.0*&
&       f_lengthd/temp4 - 0.03*exp(-(0.03*(w(i, j, k, itransition2)-&
&       460.0)))*f_length1d
      temp3 = scratch(i, j, k, istrain)
      temp2 = sqrt(temp3)
      temp1 = w(i, j, k, irho)/rev(i, j, k)
      tempd1 = d2wall(i, j, k)**2*re_sd
      tempd0 = temp2*tempd1/rev(i, j, k)
      if (.not.temp3 .eq. 0.0_8) scratchd(i, j, k, istrain) = scratchd(i&
&         , j, k, istrain) + temp1*tempd1/(2.0*temp2)
      wd(i, j, k, irho) = wd(i, j, k, irho) + tempd0
      revd(i, j, k) = revd(i, j, k) - temp1*tempd0
      wd(i, j, k, itransition2) = wd(i, j, k, itransition2) + (cos(w(i, &
&       j, k, itransition2)/240.0+0.5)*24.0/240.0+0.67)*re_theta_cd
      temp4 = rlv(i, j, k)*w(i, j, k, itu2)
      temp2 = w(i, j, k, itu1)
      temp1 = w(i, j, k, irho)
      tempd2 = r_td/temp4
      wd(i, j, k, irho) = wd(i, j, k, irho) + temp2*tempd2
      wd(i, j, k, itu1) = wd(i, j, k, itu1) + temp1*tempd2
      wd(i, j, k, itu2) = wd(i, j, k, itu2) - rlv(i, j, k)*temp1*temp2*&
&       tempd2/temp4
      temp4 = w(i, j, k, irho)
      tempd2 = -(rlv(i, j, k)*500.0*td/(temp4**2*u2**2))
      wd(i, j, k, irho) = wd(i, j, k, irho) + u2*tempd2
      u2d = temp4*tempd2
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        x1d = 0.0_8
      else
        x1d = f_theta_td
      end if
      call popcontrol1b(branch)
      if (branch .eq. 0) then
        wd(i, j, k, itransition1) = wd(i, j, k, itransition1) - rlmce2*2&
&         *(rlmce2*w(i, j, k, itransition1)-1.0)*x1d/(rlmce2-1)**2
        x2d = 0.0_8
      else
        x2d = x1d
      end if
      temp4 = d2wall(i, j, k)/delta
      temp3 = -(temp4**4)
      f_waked = exp(temp3)*x2d
      deltad = temp4**4*4*exp(temp3)*f_wake*x2d/delta
      temp0 = w(i, j, k, irho)
      temp1 = w(i, j, k, itransition2)/(temp0*u)
      temp2 = scratch(i, j, k, ivorticity)
      temp3 = sqrt(temp2)
      tempd = d2wall(i, j, k)*375.0*deltad
      if (.not.temp2 .eq. 0.0_8) scratchd(i, j, k, ivorticity) = &
&         scratchd(i, j, k, ivorticity) + temp1*tempd/(2.0*temp3)
      tempd0 = temp3*tempd/(temp0*u)
      wd(i, j, k, itransition2) = wd(i, j, k, itransition2) + tempd0
      tempd1 = -(temp1*tempd0)
      ud = temp0*tempd1
      re_omegad = -(2*re_omega*exp(-((re_omega/1e5)**2))*f_waked/1e5**2)
      tempd = d2wall(i, j, k)**2*re_omegad
      wd(i, j, k, irho) = wd(i, j, k, irho) + u*tempd1 + w(i, j, k, itu2&
&       )*tempd/rlv(i, j, k)
      wd(i, j, k, itu2) = wd(i, j, k, itu2) + w(i, j, k, irho)*tempd/rlv&
&       (i, j, k)
      if (.not.u2 .eq. 0.0_8) u2d = u2d + ud/(2.0*sqrt(u2))
      wd(i, j, k, ivx) = wd(i, j, k, ivx) + 2*w(i, j, k, ivx)*u2d
      wd(i, j, k, ivy) = wd(i, j, k, ivy) + 2*w(i, j, k, ivy)*u2d
      wd(i, j, k, ivz) = wd(i, j, k, ivz) + 2*w(i, j, k, ivz)*u2d
      call solve_local_re_thetat_eq_b(re_thetat_eq, re_thetat_eqd, i, j&
&                               , k)
    end do
  end subroutine gammarethetasource_b

  subroutine gammarethetasource()
    use blockpointers
    use constants
    use variableconstants
    use paramturb
    implicit none
    integer(kind=inttype) :: i, j, k
    real(kind=realtype) :: re_thetat_eq, u2, u, lambda_theta, delta, &
&   f_theta_t, t, r_t, re_theta_c
    real(kind=realtype) :: re_s, f_length1, f_length, f_onset1, f_onset&
&   , f_turb, p_gamma, e_gamma, p_thetat
    real(kind=realtype) :: re_omega, f_wake
    intrinsic mod
    intrinsic sqrt
    intrinsic exp
    intrinsic max
    intrinsic min
    intrinsic sin
    intrinsic tanh
    real(kind=realtype) :: x1
    real(kind=realtype) :: x2
    integer :: ii
!$ad ii-loop
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute re_thetat_eq
      call solve_local_re_thetat_eq(re_thetat_eq, i, j, k)
      u2 = w(i, j, k, ivx)**2 + w(i, j, k, ivy)**2 + w(i, j, k, ivz)**2
      u = sqrt(u2)
      re_omega = w(i, j, k, irho)*w(i, j, k, itu2)*d2wall(i, j, k)**2/&
&       rlv(i, j, k)
      f_wake = exp(-((re_omega/1e5)**2))
      delta = 375.0*sqrt(scratch(i, j, k, ivorticity))*w(i, j, k, &
&       itransition2)*d2wall(i, j, k)/(w(i, j, k, irho)*u)
      x2 = f_wake*exp(-((d2wall(i, j, k)/delta)**4))
      if (x2 .lt. 1.0 - ((rlmce2*w(i, j, k, itransition1)-1.0)/(rlmce2-1&
&         ))**2) then
        x1 = 1.0 - ((rlmce2*w(i, j, k, itransition1)-1.0)/(rlmce2-1))**2
      else
        x1 = x2
      end if
      if (x1 .gt. 1.0) then
        f_theta_t = 1.0
      else
        f_theta_t = x1
      end if
      t = 500.0*rlv(i, j, k)/(w(i, j, k, irho)*u2)
! todo: save this in scratch
      r_t = w(i, j, k, irho)*w(i, j, k, itu1)/(rlv(i, j, k)*w(i, j, k, &
&       itu2))
! todo: save this in scratch
      re_theta_c = 0.67*w(i, j, k, itransition2) + 24.0*sin(w(i, j, k, &
&       itransition2)/240.0+0.5) + 14.0
! todo: save this in scratch
      re_s = w(i, j, k, irho)*sqrt(scratch(i, j, k, istrain))*d2wall(i, &
&       j, k)**2/rev(i, j, k)
      f_length1 = exp(-(0.03*(w(i, j, k, itransition2)-460.0)))
      f_length = 44.0 - (44.0-(0.5-30000.0*(w(i, j, k, itransition2)-&
&       596.0)))/(1+f_length1)**(1/6)
! continue here
      f_onset1 = sqrt(re_s/(2.6*re_theta_c))
      f_onset = (tanh(6.0*(f_onset1-1.35))+1.0)/2.0
      f_turb = (1-f_onset)*exp(-r_t)
! since we need to divide by rho, rho does not appear here anymore
      p_gamma = f_length*rlmca1*w(i, j, k, irho)*sqrt(scratch(i, j, k, &
&       istrain))*sqrt(w(i, j, k, itransition1)*f_onset)*(1.0-rlmce1*w(i&
&       , j, k, itransition1))
      e_gamma = rlmca2*w(i, j, k, irho)*sqrt(scratch(i, j, k, ivorticity&
&       ))*w(i, j, k, itransition1)*f_turb*(rlmce2*w(i, j, k, &
&       itransition1)-1.0)
      p_thetat = rlmcthetat*w(i, j, k, irho)/t*(re_thetat_eq-w(i, j, k, &
&       itransition2))*(1.0-f_theta_t)
      scratch(i, j, k, istransition1) = p_gamma - e_gamma
      scratch(i, j, k, istransition2) = p_thetat
! print *, 'source terms: gamma, thetat', scratch(i, j, k, istransition1), scratch(i, j, k, istransition2)
    end do
  end subroutine gammarethetasource

!  differentiation of gammarethetaviscous in reverse (adjoint) mode (with options noisize i4 dr8 r8):
!   gradient     of useful results: *rev *w *rlv *scratch *vol
!                *si *sj *sk
!   with respect to varying inputs: *rev *w *rlv *scratch *vol
!                *si *sj *sk
!   rw status of diff variables: *rev:incr *w:incr *rlv:incr *scratch:in-out
!                *vol:incr *si:incr *sj:incr *sk:incr
!   plus diff mem management of: rev:in w:in rlv:in scratch:in
!                vol:in si:in sj:in sk:in
  subroutine gammarethetaviscous_b()
    use blockpointers
    use constants
    use variableconstants
    use paramturb
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rhoi
    real(kind=realtype) :: rhoid
    real(kind=realtype) :: voli, volmi, volpi
    real(kind=realtype) :: volid, volmid, volpid
    real(kind=realtype) :: xm, ym, zm, xp, yp, zp, xa, ya, za
    real(kind=realtype) :: xmd, ymd, zmd, xpd, ypd, zpd, xad, yad, zad
    real(kind=realtype) :: mulm, mulp, muem, muep
    real(kind=realtype) :: mulmd, mulpd, muemd, muepd
    real(kind=realtype) :: ttm, ttp
    real(kind=realtype) :: ttmd, ttpd
    real(kind=realtype) :: c1m, c1p, c10, c2m, c2p, c20
    real(kind=realtype) :: c1md, c1pd, c10d, c2md, c2pd, c20d
    real(kind=realtype) :: rblank
    intrinsic mod
    real(kind=realtype) :: temp
    real(kind=realtype) :: tempd
    real(kind=realtype) :: temp0
    real(kind=realtype) :: tempd0
!$bwd-of ii-loop 
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in xi-direction, i.e. along the
! line i = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i-1, j, k))
      volpi = two/(vol(i, j, k)+vol(i+1, j, k))
      xm = si(i-1, j, k, 1)*volmi
      ym = si(i-1, j, k, 2)*volmi
      zm = si(i-1, j, k, 3)*volmi
      xp = si(i, j, k, 1)*volpi
      yp = si(i, j, k, 2)*volpi
      zp = si(i, j, k, 3)*volpi
      xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
      ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
      za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in xi-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in xi-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dxi derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the gamma-term.
      rhoi = one/w(i, j, k, irho)
      mulm = half*(rlv(i-1, j, k)+rlv(i, j, k))
      mulp = half*(rlv(i+1, j, k)+rlv(i, j, k))
      muem = half*(rev(i-1, j, k)+rev(i, j, k))
      muep = half*(rev(i+1, j, k)+rev(i, j, k))
      c1m = ttm*(mulm+muem/rlmsigmaf)*rhoi
      c1p = ttp*(mulp+muep/rlmsigmaf)*rhoi
      c10 = c1m + c1p
! and the re_theta_t term.
      muem = half*(rev(i-1, j, k)+rev(i, j, k))
      muep = half*(rev(i+1, j, k)+rev(i, j, k))
      c2m = ttm*rlmsigmathetat*(mulm+muem)*rhoi
      c2p = ttp*rlmsigmathetat*(mulp+muep)*rhoi
      c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
! #ifndef 1
!                         b1 = -c1m
!                         c1 = c10
!                         d1 = -c1p
!                         b2 = -c2m
!                         c2 = c20
!                         d2 = -c2p
!                         ! update the central jacobian. for nonboundary cells this
!                         ! is simply c1 and c2. for boundary cells this is slightly
!                         ! more complicated, because the boundary conditions are
!                         ! treated implicitly and the off-diagonal terms b1, b2 and
!                         ! d1, d2 must be taken into account.
!                         ! the boundary conditions are only treated implicitly if
!                         ! the diagonal dominance of the matrix is increased.
!                         if (i == 2) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - b1 * max(bmti1(j, k, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - b1 * bmti1(j, k, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - b2 * bmti1(j, k, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - b2 * max(bmti1(j, k, itu2, itu2), zero)
!                         else if (i == il) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - d1 * max(bmti2(j, k, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - d1 * bmti2(j, k, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - d2 * bmti2(j, k, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - d2 * max(bmti2(j, k, itu2, itu2), zero)
!                         else
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2
!                         end if
! #endif
      c10d = -(w(i, j, k, itransition1)*scratchd(i, j, k, istransition1)&
&       )
      c20d = -(w(i, j, k, itransition2)*scratchd(i, j, k, istransition2)&
&       )
      c2md = w(i-1, j, k, itransition2)*scratchd(i, j, k, istransition2)&
&       + c20d
      wd(i-1, j, k, itransition2) = wd(i-1, j, k, itransition2) + c2m*&
&       scratchd(i, j, k, istransition2)
      c2pd = w(i+1, j, k, itransition2)*scratchd(i, j, k, istransition2)&
&       + c20d
      wd(i+1, j, k, itransition2) = wd(i+1, j, k, itransition2) + c2p*&
&       scratchd(i, j, k, istransition2)
      wd(i, j, k, itransition2) = wd(i, j, k, itransition2) - c20*&
&       scratchd(i, j, k, istransition2)
      c1md = w(i-1, j, k, itransition1)*scratchd(i, j, k, istransition1)&
&       + c10d
      wd(i-1, j, k, itransition1) = wd(i-1, j, k, itransition1) + c1m*&
&       scratchd(i, j, k, istransition1)
      c1pd = w(i+1, j, k, itransition1)*scratchd(i, j, k, istransition1)&
&       + c10d
      wd(i+1, j, k, itransition1) = wd(i+1, j, k, itransition1) + c1p*&
&       scratchd(i, j, k, istransition1)
      wd(i, j, k, itransition1) = wd(i, j, k, itransition1) - c10*&
&       scratchd(i, j, k, istransition1)
      tempd0 = rlmsigmathetat*c2pd
      tempd = ttp*rhoi*tempd0
      ttpd = rhoi*(mulp+muep)*tempd0
      rhoid = ttp*(mulp+muep)*tempd0
      mulpd = tempd
      muepd = tempd
      tempd0 = rlmsigmathetat*c2md
      tempd = ttm*rhoi*tempd0
      ttmd = rhoi*(mulm+muem)*tempd0
      rhoid = rhoid + ttm*(mulm+muem)*tempd0
      muemd = tempd
      revd(i+1, j, k) = revd(i+1, j, k) + half*muepd
      revd(i, j, k) = revd(i, j, k) + half*muepd + half*muemd
      muep = half*(rev(i+1, j, k)+rev(i, j, k))
      revd(i-1, j, k) = revd(i-1, j, k) + half*muemd
      muem = half*(rev(i-1, j, k)+rev(i, j, k))
      tempd0 = ttp*rhoi*c1pd
      mulpd = mulpd + tempd0
      muepd = tempd0/rlmsigmaf
      tempd0 = ttm*rhoi*c1md
      mulmd = tempd + tempd0
      tempd = (mulp+muep/rlmsigmaf)*c1pd
      ttpd = ttpd + rhoi*tempd
      rhoid = rhoid + ttp*tempd
      tempd = (mulm+muem/rlmsigmaf)*c1md
      ttmd = ttmd + rhoi*tempd
      rhoid = rhoid + ttm*tempd
      muemd = tempd0/rlmsigmaf
      revd(i+1, j, k) = revd(i+1, j, k) + half*muepd
      revd(i, j, k) = revd(i, j, k) + half*muepd + half*muemd
      revd(i-1, j, k) = revd(i-1, j, k) + half*muemd
      rlvd(i+1, j, k) = rlvd(i+1, j, k) + half*mulpd
      rlvd(i, j, k) = rlvd(i, j, k) + half*mulpd + half*mulmd
      rlvd(i-1, j, k) = rlvd(i-1, j, k) + half*mulmd
      temp0 = w(i, j, k, irho)
      wd(i, j, k, irho) = wd(i, j, k, irho) - one*rhoid/temp0**2
      xpd = xa*ttpd
      xad = xp*ttpd + xm*ttmd
      ypd = ya*ttpd
      yad = yp*ttpd + ym*ttmd
      zpd = za*ttpd
      zad = zp*ttpd + zm*ttmd
      xmd = xa*ttmd
      ymd = ya*ttmd
      zmd = za*ttmd
      tempd0 = half*zad
      sid(i, j, k, 3) = sid(i, j, k, 3) + voli*tempd0
      sid(i-1, j, k, 3) = sid(i-1, j, k, 3) + voli*tempd0
      volid = (si(i, j, k, 3)+si(i-1, j, k, 3))*tempd0
      tempd0 = half*yad
      sid(i, j, k, 2) = sid(i, j, k, 2) + voli*tempd0
      sid(i-1, j, k, 2) = sid(i-1, j, k, 2) + voli*tempd0
      volid = volid + (si(i, j, k, 2)+si(i-1, j, k, 2))*tempd0
      tempd0 = half*xad
      sid(i, j, k, 1) = sid(i, j, k, 1) + voli*tempd0
      sid(i-1, j, k, 1) = sid(i-1, j, k, 1) + voli*tempd0
      volid = volid + (si(i, j, k, 1)+si(i-1, j, k, 1))*tempd0
      sid(i, j, k, 3) = sid(i, j, k, 3) + volpi*zpd
      volpid = si(i, j, k, 3)*zpd + si(i, j, k, 2)*ypd + si(i, j, k, 1)*&
&       xpd
      sid(i, j, k, 2) = sid(i, j, k, 2) + volpi*ypd
      sid(i, j, k, 1) = sid(i, j, k, 1) + volpi*xpd
      sid(i-1, j, k, 3) = sid(i-1, j, k, 3) + volmi*zmd
      volmid = si(i-1, j, k, 3)*zmd + si(i-1, j, k, 2)*ymd + si(i-1, j, &
&       k, 1)*xmd
      sid(i-1, j, k, 2) = sid(i-1, j, k, 2) + volmi*ymd
      sid(i-1, j, k, 1) = sid(i-1, j, k, 1) + volmi*xmd
      temp0 = vol(i, j, k) + vol(i+1, j, k)
      tempd0 = -(two*volpid/temp0**2)
      vold(i, j, k) = vold(i, j, k) + tempd0
      vold(i+1, j, k) = vold(i+1, j, k) + tempd0
      temp0 = vol(i, j, k) + vol(i-1, j, k)
      tempd0 = -(two*volmid/temp0**2)
      vold(i-1, j, k) = vold(i-1, j, k) + tempd0
      vold(i, j, k) = vold(i, j, k) + tempd0 - one*volid/vol(i, j, k)**2
    end do
!$bwd-of ii-loop 
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in eta-direction, i.e. along the
! line j = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j-1, k))
      volpi = two/(vol(i, j, k)+vol(i, j+1, k))
      xm = sj(i, j-1, k, 1)*volmi
      ym = sj(i, j-1, k, 2)*volmi
      zm = sj(i, j-1, k, 3)*volmi
      xp = sj(i, j, k, 1)*volpi
      yp = sj(i, j, k, 2)*volpi
      zp = sj(i, j, k, 3)*volpi
      xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
      ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
      za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in eta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in eta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/deta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the gamma-term.
      rhoi = one/w(i, j, k, irho)
      mulm = half*(rlv(i, j-1, k)+rlv(i, j, k))
      mulp = half*(rlv(i, j+1, k)+rlv(i, j, k))
      muem = half*(rev(i, j-1, k)+rev(i, j, k))
      muep = half*(rev(i, j+1, k)+rev(i, j, k))
      c1m = ttm*(mulm+muem/rlmsigmaf)*rhoi
      c1p = ttp*(mulp+muep/rlmsigmaf)*rhoi
      c10 = c1m + c1p
! and the re_theta_t term.
      muem = half*(rev(i, j-1, k)+rev(i, j, k))
      muep = half*(rev(i, j+1, k)+rev(i, j, k))
      c2m = ttm*rlmsigmathetat*(mulm+muem)*rhoi
      c2p = ttp*rlmsigmathetat*(mulp+muep)*rhoi
      c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
! #ifndef 1
!                         b1 = -c1m
!                         c1 = c10
!                         d1 = -c1p
!                         b2 = -c2m
!                         c2 = c20
!                         d2 = -c2p
!                         ! update the central jacobian. for nonboundary cells this
!                         ! is simply c1 and c2. for boundary cells this is slightly
!                         ! more complicated, because the boundary conditions are
!                         ! treated implicitly and the off-diagonal terms b1, b2 and
!                         ! d1, d2 must be taken into account.
!                         ! the boundary conditions are only treated implicitly if
!                         ! the diagonal dominance of the matrix is increased.
!                         if (j == 2) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - b1 * max(bmtj1(i, k, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - b1 * bmtj1(i, k, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - b2 * bmtj1(i, k, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - b2 * max(bmtj1(i, k, itu2, itu2), zero)
!                         else if (j == jl) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - d1 * max(bmtj2(i, k, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - d1 * bmtj2(i, k, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - d2 * bmtj2(i, k, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - d2 * max(bmtj2(i, k, itu2, itu2), zero)
!                         else
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2
!                         end if
! #endif
      c10d = -(w(i, j, k, itransition1)*scratchd(i, j, k, istransition1)&
&       )
      c20d = -(w(i, j, k, itransition2)*scratchd(i, j, k, istransition2)&
&       )
      c2md = w(i, j-1, k, itransition2)*scratchd(i, j, k, istransition2)&
&       + c20d
      wd(i, j-1, k, itransition2) = wd(i, j-1, k, itransition2) + c2m*&
&       scratchd(i, j, k, istransition2)
      c2pd = w(i, j+1, k, itransition2)*scratchd(i, j, k, istransition2)&
&       + c20d
      wd(i, j+1, k, itransition2) = wd(i, j+1, k, itransition2) + c2p*&
&       scratchd(i, j, k, istransition2)
      wd(i, j, k, itransition2) = wd(i, j, k, itransition2) - c20*&
&       scratchd(i, j, k, istransition2)
      c1md = w(i, j-1, k, itransition1)*scratchd(i, j, k, istransition1)&
&       + c10d
      wd(i, j-1, k, itransition1) = wd(i, j-1, k, itransition1) + c1m*&
&       scratchd(i, j, k, istransition1)
      c1pd = w(i, j+1, k, itransition1)*scratchd(i, j, k, istransition1)&
&       + c10d
      wd(i, j+1, k, itransition1) = wd(i, j+1, k, itransition1) + c1p*&
&       scratchd(i, j, k, istransition1)
      wd(i, j, k, itransition1) = wd(i, j, k, itransition1) - c10*&
&       scratchd(i, j, k, istransition1)
      tempd0 = rlmsigmathetat*c2pd
      tempd = ttp*rhoi*tempd0
      ttpd = rhoi*(mulp+muep)*tempd0
      rhoid = ttp*(mulp+muep)*tempd0
      mulpd = tempd
      muepd = tempd
      tempd0 = rlmsigmathetat*c2md
      tempd = ttm*rhoi*tempd0
      ttmd = rhoi*(mulm+muem)*tempd0
      rhoid = rhoid + ttm*(mulm+muem)*tempd0
      muemd = tempd
      revd(i, j+1, k) = revd(i, j+1, k) + half*muepd
      revd(i, j, k) = revd(i, j, k) + half*muepd + half*muemd
      muep = half*(rev(i, j+1, k)+rev(i, j, k))
      revd(i, j-1, k) = revd(i, j-1, k) + half*muemd
      muem = half*(rev(i, j-1, k)+rev(i, j, k))
      tempd0 = ttp*rhoi*c1pd
      mulpd = mulpd + tempd0
      muepd = tempd0/rlmsigmaf
      tempd0 = ttm*rhoi*c1md
      mulmd = tempd + tempd0
      tempd = (mulp+muep/rlmsigmaf)*c1pd
      ttpd = ttpd + rhoi*tempd
      rhoid = rhoid + ttp*tempd
      tempd = (mulm+muem/rlmsigmaf)*c1md
      ttmd = ttmd + rhoi*tempd
      rhoid = rhoid + ttm*tempd
      muemd = tempd0/rlmsigmaf
      revd(i, j+1, k) = revd(i, j+1, k) + half*muepd
      revd(i, j, k) = revd(i, j, k) + half*muepd + half*muemd
      revd(i, j-1, k) = revd(i, j-1, k) + half*muemd
      rlvd(i, j+1, k) = rlvd(i, j+1, k) + half*mulpd
      rlvd(i, j, k) = rlvd(i, j, k) + half*mulpd + half*mulmd
      rlvd(i, j-1, k) = rlvd(i, j-1, k) + half*mulmd
      temp0 = w(i, j, k, irho)
      wd(i, j, k, irho) = wd(i, j, k, irho) - one*rhoid/temp0**2
      xpd = xa*ttpd
      xad = xp*ttpd + xm*ttmd
      ypd = ya*ttpd
      yad = yp*ttpd + ym*ttmd
      zpd = za*ttpd
      zad = zp*ttpd + zm*ttmd
      xmd = xa*ttmd
      ymd = ya*ttmd
      zmd = za*ttmd
      tempd0 = half*zad
      sjd(i, j, k, 3) = sjd(i, j, k, 3) + voli*tempd0
      sjd(i, j-1, k, 3) = sjd(i, j-1, k, 3) + voli*tempd0
      volid = (sj(i, j, k, 3)+sj(i, j-1, k, 3))*tempd0
      tempd0 = half*yad
      sjd(i, j, k, 2) = sjd(i, j, k, 2) + voli*tempd0
      sjd(i, j-1, k, 2) = sjd(i, j-1, k, 2) + voli*tempd0
      volid = volid + (sj(i, j, k, 2)+sj(i, j-1, k, 2))*tempd0
      tempd0 = half*xad
      sjd(i, j, k, 1) = sjd(i, j, k, 1) + voli*tempd0
      sjd(i, j-1, k, 1) = sjd(i, j-1, k, 1) + voli*tempd0
      volid = volid + (sj(i, j, k, 1)+sj(i, j-1, k, 1))*tempd0
      sjd(i, j, k, 3) = sjd(i, j, k, 3) + volpi*zpd
      volpid = sj(i, j, k, 3)*zpd + sj(i, j, k, 2)*ypd + sj(i, j, k, 1)*&
&       xpd
      sjd(i, j, k, 2) = sjd(i, j, k, 2) + volpi*ypd
      sjd(i, j, k, 1) = sjd(i, j, k, 1) + volpi*xpd
      sjd(i, j-1, k, 3) = sjd(i, j-1, k, 3) + volmi*zmd
      volmid = sj(i, j-1, k, 3)*zmd + sj(i, j-1, k, 2)*ymd + sj(i, j-1, &
&       k, 1)*xmd
      sjd(i, j-1, k, 2) = sjd(i, j-1, k, 2) + volmi*ymd
      sjd(i, j-1, k, 1) = sjd(i, j-1, k, 1) + volmi*xmd
      temp0 = vol(i, j, k) + vol(i, j+1, k)
      tempd0 = -(two*volpid/temp0**2)
      vold(i, j, k) = vold(i, j, k) + tempd0
      vold(i, j+1, k) = vold(i, j+1, k) + tempd0
      temp0 = vol(i, j, k) + vol(i, j-1, k)
      tempd0 = -(two*volmid/temp0**2)
      vold(i, j-1, k) = vold(i, j-1, k) + tempd0
      vold(i, j, k) = vold(i, j, k) + tempd0 - one*volid/vol(i, j, k)**2
    end do
!$bwd-of ii-loop 
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in zeta-direction, i.e. along the
! line k = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j, k-1))
      volpi = two/(vol(i, j, k)+vol(i, j, k+1))
      xm = sk(i, j, k-1, 1)*volmi
      ym = sk(i, j, k-1, 2)*volmi
      zm = sk(i, j, k-1, 3)*volmi
      xp = sk(i, j, k, 1)*volpi
      yp = sk(i, j, k, 2)*volpi
      zp = sk(i, j, k, 3)*volpi
      xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
      ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
      za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in zeta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in zeta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dzeta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the gamma-term.
      rhoi = one/w(i, j, k, irho)
      mulm = half*(rlv(i, j, k-1)+rlv(i, j, k))
      mulp = half*(rlv(i, j, k+1)+rlv(i, j, k))
      muem = half*(rev(i, j, k-1)+rev(i, j, k))
      muep = half*(rev(i, j, k+1)+rev(i, j, k))
      c1m = ttm*(mulm+muem/rlmsigmaf)*rhoi
      c1p = ttp*(mulp+muep/rlmsigmaf)*rhoi
      c10 = c1m + c1p
! and the re_theta_t term.
      muem = half*(rev(i, j, k-1)+rev(i, j, k))
      muep = half*(rev(i, j, k+1)+rev(i, j, k))
      c2m = ttm*rlmsigmathetat*(mulm+muem)*rhoi
      c2p = ttp*rlmsigmathetat*(mulp+muep)*rhoi
      c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
! #ifndef 1
!                         b1 = -c1m
!                         c1 = c10
!                         d1 = -c1p
!                         b2 = -c2m
!                         c2 = c20
!                         d2 = -c2p
!                         ! update the central jacobian. for nonboundary cells this
!                         ! is simply c1 and c2. for boundary cells this is slightly
!                         ! more complicated, because the boundary conditions are
!                         ! treated implicitly and the off-diagonal terms b1, b2 and
!                         ! d1, d2 must be taken into account.
!                         ! the boundary conditions are only treated implicitly if
!                         ! the diagonal dominance of the matrix is increased.
!                         if (k == 2) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - b1 * max(bmtk1(i, j, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - b1 * bmtk1(i, j, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - b2 * bmtk1(i, j, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - b2 * max(bmtk1(i, j, itu2, itu2), zero)
!                         else if (k == kl) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - d1 * max(bmtk2(i, j, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - d1 * bmtk2(i, j, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - d2 * bmtk2(i, j, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - d2 * max(bmtk2(i, j, itu2, itu2), zero)
!                         else
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2
!                         end if
! #endif
      c10d = -(w(i, j, k, itransition1)*scratchd(i, j, k, istransition1)&
&       )
      c20d = -(w(i, j, k, itransition2)*scratchd(i, j, k, istransition2)&
&       )
      c2md = w(i, j, k-1, itransition2)*scratchd(i, j, k, istransition2)&
&       + c20d
      wd(i, j, k-1, itransition2) = wd(i, j, k-1, itransition2) + c2m*&
&       scratchd(i, j, k, istransition2)
      c2pd = w(i, j, k+1, itransition2)*scratchd(i, j, k, istransition2)&
&       + c20d
      wd(i, j, k+1, itransition2) = wd(i, j, k+1, itransition2) + c2p*&
&       scratchd(i, j, k, istransition2)
      wd(i, j, k, itransition2) = wd(i, j, k, itransition2) - c20*&
&       scratchd(i, j, k, istransition2)
      c1md = w(i, j, k-1, itransition1)*scratchd(i, j, k, istransition1)&
&       + c10d
      wd(i, j, k-1, itransition1) = wd(i, j, k-1, itransition1) + c1m*&
&       scratchd(i, j, k, istransition1)
      c1pd = w(i, j, k+1, itransition1)*scratchd(i, j, k, istransition1)&
&       + c10d
      wd(i, j, k+1, itransition1) = wd(i, j, k+1, itransition1) + c1p*&
&       scratchd(i, j, k, istransition1)
      wd(i, j, k, itransition1) = wd(i, j, k, itransition1) - c10*&
&       scratchd(i, j, k, istransition1)
      tempd0 = rlmsigmathetat*c2pd
      tempd = ttp*rhoi*tempd0
      ttpd = rhoi*(mulp+muep)*tempd0
      rhoid = ttp*(mulp+muep)*tempd0
      mulpd = tempd
      muepd = tempd
      tempd0 = rlmsigmathetat*c2md
      tempd = ttm*rhoi*tempd0
      ttmd = rhoi*(mulm+muem)*tempd0
      rhoid = rhoid + ttm*(mulm+muem)*tempd0
      mulmd = tempd
      muemd = tempd
      revd(i, j, k+1) = revd(i, j, k+1) + half*muepd
      revd(i, j, k) = revd(i, j, k) + half*muepd + half*muemd
      muep = half*(rev(i, j, k+1)+rev(i, j, k))
      revd(i, j, k-1) = revd(i, j, k-1) + half*muemd
      muem = half*(rev(i, j, k-1)+rev(i, j, k))
      tempd0 = ttp*rhoi*c1pd
      tempd = (mulp+muep/rlmsigmaf)*c1pd
      ttpd = ttpd + rhoi*tempd
      mulpd = mulpd + tempd0
      muepd = tempd0/rlmsigmaf
      tempd0 = (mulm+muem/rlmsigmaf)*c1md
      rhoid = rhoid + ttp*tempd + ttm*tempd0
      tempd = ttm*rhoi*c1md
      ttmd = ttmd + rhoi*tempd0
      mulmd = mulmd + tempd
      muemd = tempd/rlmsigmaf
      revd(i, j, k+1) = revd(i, j, k+1) + half*muepd
      revd(i, j, k) = revd(i, j, k) + half*muepd + half*muemd
      revd(i, j, k-1) = revd(i, j, k-1) + half*muemd
      rlvd(i, j, k+1) = rlvd(i, j, k+1) + half*mulpd
      rlvd(i, j, k) = rlvd(i, j, k) + half*mulpd + half*mulmd
      rlvd(i, j, k-1) = rlvd(i, j, k-1) + half*mulmd
      temp = w(i, j, k, irho)
      wd(i, j, k, irho) = wd(i, j, k, irho) - one*rhoid/temp**2
      xpd = xa*ttpd
      xad = xp*ttpd + xm*ttmd
      ypd = ya*ttpd
      yad = yp*ttpd + ym*ttmd
      zpd = za*ttpd
      zad = zp*ttpd + zm*ttmd
      xmd = xa*ttmd
      ymd = ya*ttmd
      zmd = za*ttmd
      tempd = half*zad
      skd(i, j, k, 3) = skd(i, j, k, 3) + voli*tempd
      skd(i, j, k-1, 3) = skd(i, j, k-1, 3) + voli*tempd
      volid = (sk(i, j, k, 3)+sk(i, j, k-1, 3))*tempd
      tempd = half*yad
      skd(i, j, k, 2) = skd(i, j, k, 2) + voli*tempd
      skd(i, j, k-1, 2) = skd(i, j, k-1, 2) + voli*tempd
      volid = volid + (sk(i, j, k, 2)+sk(i, j, k-1, 2))*tempd
      tempd = half*xad
      skd(i, j, k, 1) = skd(i, j, k, 1) + voli*tempd
      skd(i, j, k-1, 1) = skd(i, j, k-1, 1) + voli*tempd
      volid = volid + (sk(i, j, k, 1)+sk(i, j, k-1, 1))*tempd
      skd(i, j, k, 3) = skd(i, j, k, 3) + volpi*zpd
      volpid = sk(i, j, k, 3)*zpd + sk(i, j, k, 2)*ypd + sk(i, j, k, 1)*&
&       xpd
      skd(i, j, k, 2) = skd(i, j, k, 2) + volpi*ypd
      skd(i, j, k, 1) = skd(i, j, k, 1) + volpi*xpd
      skd(i, j, k-1, 3) = skd(i, j, k-1, 3) + volmi*zmd
      volmid = sk(i, j, k-1, 3)*zmd + sk(i, j, k-1, 2)*ymd + sk(i, j, k-&
&       1, 1)*xmd
      skd(i, j, k-1, 2) = skd(i, j, k-1, 2) + volmi*ymd
      skd(i, j, k-1, 1) = skd(i, j, k-1, 1) + volmi*xmd
      temp = vol(i, j, k) + vol(i, j, k+1)
      tempd = -(two*volpid/temp**2)
      vold(i, j, k) = vold(i, j, k) + tempd
      vold(i, j, k+1) = vold(i, j, k+1) + tempd
      temp = vol(i, j, k) + vol(i, j, k-1)
      tempd = -(two*volmid/temp**2)
      vold(i, j, k-1) = vold(i, j, k-1) + tempd
      vold(i, j, k) = vold(i, j, k) + tempd - one*volid/vol(i, j, k)**2
    end do
  end subroutine gammarethetaviscous_b

  subroutine gammarethetaviscous()
    use blockpointers
    use constants
    use variableconstants
    use paramturb
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rhoi
    real(kind=realtype) :: voli, volmi, volpi
    real(kind=realtype) :: xm, ym, zm, xp, yp, zp, xa, ya, za
    real(kind=realtype) :: mulm, mulp, muem, muep
    real(kind=realtype) :: ttm, ttp
    real(kind=realtype) :: c1m, c1p, c10, c2m, c2p, c20
    real(kind=realtype) :: rblank
    intrinsic mod
!$ad ii-loop
!       advection and unsteady terms.
!
!
!       viscous terms in k-direction.
!
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in zeta-direction, i.e. along the
! line k = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j, k-1))
      volpi = two/(vol(i, j, k)+vol(i, j, k+1))
      xm = sk(i, j, k-1, 1)*volmi
      ym = sk(i, j, k-1, 2)*volmi
      zm = sk(i, j, k-1, 3)*volmi
      xp = sk(i, j, k, 1)*volpi
      yp = sk(i, j, k, 2)*volpi
      zp = sk(i, j, k, 3)*volpi
      xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
      ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
      za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in zeta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in zeta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dzeta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the gamma-term.
      rhoi = one/w(i, j, k, irho)
      mulm = half*(rlv(i, j, k-1)+rlv(i, j, k))
      mulp = half*(rlv(i, j, k+1)+rlv(i, j, k))
      muem = half*(rev(i, j, k-1)+rev(i, j, k))
      muep = half*(rev(i, j, k+1)+rev(i, j, k))
      c1m = ttm*(mulm+muem/rlmsigmaf)*rhoi
      c1p = ttp*(mulp+muep/rlmsigmaf)*rhoi
      c10 = c1m + c1p
! and the re_theta_t term.
      muem = half*(rev(i, j, k-1)+rev(i, j, k))
      muep = half*(rev(i, j, k+1)+rev(i, j, k))
      c2m = ttm*rlmsigmathetat*(mulm+muem)*rhoi
      c2p = ttp*rlmsigmathetat*(mulp+muep)*rhoi
      c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
      scratch(i, j, k, istransition1) = scratch(i, j, k, istransition1) &
&       + c1m*w(i, j, k-1, itransition1) - c10*w(i, j, k, itransition1) &
&       + c1p*w(i, j, k+1, itransition1)
      scratch(i, j, k, istransition2) = scratch(i, j, k, istransition2) &
&       + c2m*w(i, j, k-1, itransition2) - c20*w(i, j, k, itransition2) &
&       + c2p*w(i, j, k+1, itransition2)
! #ifndef 1
!                         b1 = -c1m
!                         c1 = c10
!                         d1 = -c1p
!                         b2 = -c2m
!                         c2 = c20
!                         d2 = -c2p
!                         ! update the central jacobian. for nonboundary cells this
!                         ! is simply c1 and c2. for boundary cells this is slightly
!                         ! more complicated, because the boundary conditions are
!                         ! treated implicitly and the off-diagonal terms b1, b2 and
!                         ! d1, d2 must be taken into account.
!                         ! the boundary conditions are only treated implicitly if
!                         ! the diagonal dominance of the matrix is increased.
!                         if (k == 2) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - b1 * max(bmtk1(i, j, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - b1 * bmtk1(i, j, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - b2 * bmtk1(i, j, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - b2 * max(bmtk1(i, j, itu2, itu2), zero)
!                         else if (k == kl) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - d1 * max(bmtk2(i, j, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - d1 * bmtk2(i, j, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - d2 * bmtk2(i, j, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - d2 * max(bmtk2(i, j, itu2, itu2), zero)
!                         else
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2
!                         end if
! #endif
    end do
!$ad ii-loop
!
!       viscous terms in j-direction.
!
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in eta-direction, i.e. along the
! line j = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j-1, k))
      volpi = two/(vol(i, j, k)+vol(i, j+1, k))
      xm = sj(i, j-1, k, 1)*volmi
      ym = sj(i, j-1, k, 2)*volmi
      zm = sj(i, j-1, k, 3)*volmi
      xp = sj(i, j, k, 1)*volpi
      yp = sj(i, j, k, 2)*volpi
      zp = sj(i, j, k, 3)*volpi
      xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
      ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
      za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in eta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in eta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/deta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the gamma-term.
      rhoi = one/w(i, j, k, irho)
      mulm = half*(rlv(i, j-1, k)+rlv(i, j, k))
      mulp = half*(rlv(i, j+1, k)+rlv(i, j, k))
      muem = half*(rev(i, j-1, k)+rev(i, j, k))
      muep = half*(rev(i, j+1, k)+rev(i, j, k))
      c1m = ttm*(mulm+muem/rlmsigmaf)*rhoi
      c1p = ttp*(mulp+muep/rlmsigmaf)*rhoi
      c10 = c1m + c1p
! and the re_theta_t term.
      muem = half*(rev(i, j-1, k)+rev(i, j, k))
      muep = half*(rev(i, j+1, k)+rev(i, j, k))
      c2m = ttm*rlmsigmathetat*(mulm+muem)*rhoi
      c2p = ttp*rlmsigmathetat*(mulp+muep)*rhoi
      c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
      scratch(i, j, k, istransition1) = scratch(i, j, k, istransition1) &
&       + c1m*w(i, j-1, k, itransition1) - c10*w(i, j, k, itransition1) &
&       + c1p*w(i, j+1, k, itransition1)
      scratch(i, j, k, istransition2) = scratch(i, j, k, istransition2) &
&       + c2m*w(i, j-1, k, itransition2) - c20*w(i, j, k, itransition2) &
&       + c2p*w(i, j+1, k, itransition2)
! #ifndef 1
!                         b1 = -c1m
!                         c1 = c10
!                         d1 = -c1p
!                         b2 = -c2m
!                         c2 = c20
!                         d2 = -c2p
!                         ! update the central jacobian. for nonboundary cells this
!                         ! is simply c1 and c2. for boundary cells this is slightly
!                         ! more complicated, because the boundary conditions are
!                         ! treated implicitly and the off-diagonal terms b1, b2 and
!                         ! d1, d2 must be taken into account.
!                         ! the boundary conditions are only treated implicitly if
!                         ! the diagonal dominance of the matrix is increased.
!                         if (j == 2) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - b1 * max(bmtj1(i, k, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - b1 * bmtj1(i, k, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - b2 * bmtj1(i, k, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - b2 * max(bmtj1(i, k, itu2, itu2), zero)
!                         else if (j == jl) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - d1 * max(bmtj2(i, k, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - d1 * bmtj2(i, k, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - d2 * bmtj2(i, k, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - d2 * max(bmtj2(i, k, itu2, itu2), zero)
!                         else
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2
!                         end if
! #endif
    end do
!$ad ii-loop
!
!       viscous terms in i-direction.
!
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in xi-direction, i.e. along the
! line i = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i-1, j, k))
      volpi = two/(vol(i, j, k)+vol(i+1, j, k))
      xm = si(i-1, j, k, 1)*volmi
      ym = si(i-1, j, k, 2)*volmi
      zm = si(i-1, j, k, 3)*volmi
      xp = si(i, j, k, 1)*volpi
      yp = si(i, j, k, 2)*volpi
      zp = si(i, j, k, 3)*volpi
      xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
      ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
      za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in xi-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in xi-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dxi derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the gamma-term.
      rhoi = one/w(i, j, k, irho)
      mulm = half*(rlv(i-1, j, k)+rlv(i, j, k))
      mulp = half*(rlv(i+1, j, k)+rlv(i, j, k))
      muem = half*(rev(i-1, j, k)+rev(i, j, k))
      muep = half*(rev(i+1, j, k)+rev(i, j, k))
      c1m = ttm*(mulm+muem/rlmsigmaf)*rhoi
      c1p = ttp*(mulp+muep/rlmsigmaf)*rhoi
      c10 = c1m + c1p
! and the re_theta_t term.
      muem = half*(rev(i-1, j, k)+rev(i, j, k))
      muep = half*(rev(i+1, j, k)+rev(i, j, k))
      c2m = ttm*rlmsigmathetat*(mulm+muem)*rhoi
      c2p = ttp*rlmsigmathetat*(mulp+muep)*rhoi
      c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
      scratch(i, j, k, istransition1) = scratch(i, j, k, istransition1) &
&       + c1m*w(i-1, j, k, itransition1) - c10*w(i, j, k, itransition1) &
&       + c1p*w(i+1, j, k, itransition1)
      scratch(i, j, k, istransition2) = scratch(i, j, k, istransition2) &
&       + c2m*w(i-1, j, k, itransition2) - c20*w(i, j, k, itransition2) &
&       + c2p*w(i+1, j, k, itransition2)
! #ifndef 1
!                         b1 = -c1m
!                         c1 = c10
!                         d1 = -c1p
!                         b2 = -c2m
!                         c2 = c20
!                         d2 = -c2p
!                         ! update the central jacobian. for nonboundary cells this
!                         ! is simply c1 and c2. for boundary cells this is slightly
!                         ! more complicated, because the boundary conditions are
!                         ! treated implicitly and the off-diagonal terms b1, b2 and
!                         ! d1, d2 must be taken into account.
!                         ! the boundary conditions are only treated implicitly if
!                         ! the diagonal dominance of the matrix is increased.
!                         if (i == 2) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - b1 * max(bmti1(j, k, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - b1 * bmti1(j, k, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - b2 * bmti1(j, k, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - b2 * max(bmti1(j, k, itu2, itu2), zero)
!                         else if (i == il) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - d1 * max(bmti2(j, k, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - d1 * bmti2(j, k, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - d2 * bmti2(j, k, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - d2 * max(bmti2(j, k, itu2, itu2), zero)
!                         else
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2
!                         end if
! #endif
    end do
  end subroutine gammarethetaviscous

!  differentiation of gammarethetaresscale in reverse (adjoint) mode (with options noisize i4 dr8 r8):
!   gradient     of useful results: *dw *scratch
!   with respect to varying inputs: *dw *scratch
!   rw status of diff variables: *dw:in-out *scratch:incr
!   plus diff mem management of: dw:in scratch:in
  subroutine gammarethetaresscale_b()
    use blockpointers
    use constants
    use variableconstants
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rblank
    intrinsic mod
    intrinsic real
!$bwd-of ii-loop 
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
      rblank = real(iblank(i, j, k), realtype)
! print *, 'dw transition 1 & 2', dw(i, j, k, itransition1), dw(i, j, k, itransition2)
      scratchd(i, j, k, istransition2) = scratchd(i, j, k, istransition2&
&       ) - volref(i, j, k)*rblank*dwd(i, j, k, itransition2)
      dwd(i, j, k, itransition2) = 0.0_8
      scratchd(i, j, k, istransition1) = scratchd(i, j, k, istransition1&
&       ) - volref(i, j, k)*rblank*dwd(i, j, k, itransition1)
      dwd(i, j, k, itransition1) = 0.0_8
    end do
  end subroutine gammarethetaresscale_b

  subroutine gammarethetaresscale()
    use blockpointers
    use constants
    use variableconstants
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rblank
    intrinsic mod
    intrinsic real
!$ad ii-loop
! multiply the residual by the volume and store this in dw; this
! is done for monitoring reasons only. the multiplication with the
! volume is present to be consistent with the flow residuals; also
! the negative value is taken, again to be consistent with the
! flow equations. also multiply by iblank so that no updates occur
! in holes or the overset boundary.
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
      rblank = real(iblank(i, j, k), realtype)
      dw(i, j, k, itransition1) = -(volref(i, j, k)*scratch(i, j, k, &
&       istransition1)*rblank)
      dw(i, j, k, itransition2) = -(volref(i, j, k)*scratch(i, j, k, &
&       istransition2)*rblank)
! print *, 'dw transition 1 & 2', dw(i, j, k, itransition1), dw(i, j, k, itransition2)
    end do
  end subroutine gammarethetaresscale

end module gammarethetamodel_b

