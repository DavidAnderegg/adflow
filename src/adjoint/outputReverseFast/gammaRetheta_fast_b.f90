!        generated by tapenade     (inria, ecuador team)
!  tapenade 3.16 (develop) - 10 nov 2023 18:24
!
module gammarethetamodel_fast_b
  use constants
  implicit none

contains
  subroutine solve_local_re_thetat_eq(re_thetat_eq, i, j, k)
    use blockpointers
    use constants
    use paramturb
    implicit none
! input/output variables
    integer(kind=inttype), intent(in) :: i, j, k
    real(kind=realtype), intent(out) :: re_thetat_eq
! local variables
    real(kind=realtype) :: u, u_inv, fact, du_dx, du_dy, du_dz, du_ds, &
&   tu, f1, f2, f3, f
    real(kind=realtype) :: dudx, dudy, dudz, dvdx, dvdy, dvdz, dwdx, &
&   dwdy, dwdz
    real(kind=realtype) :: lambda, thetat, residum, thetat_old, &
&   residum_old, thetat_new
    real(kind=realtype) :: re_thetat_eq_1, re_thetat_eq_2
    integer(kind=inttype) :: n
    intrinsic sqrt
    intrinsic exp
    intrinsic max
    intrinsic min
    intrinsic abs
    real(kind=realtype) :: abs0
    u = sqrt(w(i, j, k, ivx)**2 + w(i, j, k, ivy)**2 + w(i, j, k, ivz)**&
&     2)
    u_inv = 1.0/u
! compute the gradient of u in the cell center. use is made
! of the fact that the surrounding normals sum up to zero,
! such that the cell i,j,k does not give a contribution.
! since the gradient is scaled by a factor of 2*vol, we need to account for that
    fact = 1.0/(vol(i, j, k)*2.0)
    dudx = (w(i+1, j, k, ivx)*si(i, j, k, 1)-w(i-1, j, k, ivx)*si(i-1, j&
&     , k, 1)+w(i, j+1, k, ivx)*sj(i, j, k, 1)-w(i, j-1, k, ivx)*sj(i, j&
&     -1, k, 1)+w(i, j, k+1, ivx)*sk(i, j, k, 1)-w(i, j, k-1, ivx)*sk(i&
&     , j, k-1, 1))*fact
    dudy = (w(i+1, j, k, ivx)*si(i, j, k, 2)-w(i-1, j, k, ivx)*si(i-1, j&
&     , k, 2)+w(i, j+1, k, ivx)*sj(i, j, k, 2)-w(i, j-1, k, ivx)*sj(i, j&
&     -1, k, 2)+w(i, j, k+1, ivx)*sk(i, j, k, 2)-w(i, j, k-1, ivx)*sk(i&
&     , j, k-1, 2))*fact
    dudz = (w(i+1, j, k, ivx)*si(i, j, k, 3)-w(i-1, j, k, ivx)*si(i-1, j&
&     , k, 3)+w(i, j+1, k, ivx)*sj(i, j, k, 3)-w(i, j-1, k, ivx)*sj(i, j&
&     -1, k, 3)+w(i, j, k+1, ivx)*sk(i, j, k, 3)-w(i, j, k-1, ivx)*sk(i&
&     , j, k-1, 3))*fact
! idem for the gradient of v.
    dvdx = (w(i+1, j, k, ivy)*si(i, j, k, 1)-w(i-1, j, k, ivy)*si(i-1, j&
&     , k, 1)+w(i, j+1, k, ivy)*sj(i, j, k, 1)-w(i, j-1, k, ivy)*sj(i, j&
&     -1, k, 1)+w(i, j, k+1, ivy)*sk(i, j, k, 1)-w(i, j, k-1, ivy)*sk(i&
&     , j, k-1, 1))*fact
    dvdy = (w(i+1, j, k, ivy)*si(i, j, k, 2)-w(i-1, j, k, ivy)*si(i-1, j&
&     , k, 2)+w(i, j+1, k, ivy)*sj(i, j, k, 2)-w(i, j-1, k, ivy)*sj(i, j&
&     -1, k, 2)+w(i, j, k+1, ivy)*sk(i, j, k, 2)-w(i, j, k-1, ivy)*sk(i&
&     , j, k-1, 2))*fact
    dvdz = (w(i+1, j, k, ivy)*si(i, j, k, 3)-w(i-1, j, k, ivy)*si(i-1, j&
&     , k, 3)+w(i, j+1, k, ivy)*sj(i, j, k, 3)-w(i, j-1, k, ivy)*sj(i, j&
&     -1, k, 3)+w(i, j, k+1, ivy)*sk(i, j, k, 3)-w(i, j, k-1, ivy)*sk(i&
&     , j, k-1, 3))*fact
! and for the gradient of w.
    dwdx = (w(i+1, j, k, ivz)*si(i, j, k, 1)-w(i-1, j, k, ivz)*si(i-1, j&
&     , k, 1)+w(i, j+1, k, ivz)*sj(i, j, k, 1)-w(i, j-1, k, ivz)*sj(i, j&
&     -1, k, 1)+w(i, j, k+1, ivz)*sk(i, j, k, 1)-w(i, j, k-1, ivz)*sk(i&
&     , j, k-1, 1))*fact
    dwdy = (w(i+1, j, k, ivz)*si(i, j, k, 2)-w(i-1, j, k, ivz)*si(i-1, j&
&     , k, 2)+w(i, j+1, k, ivz)*sj(i, j, k, 2)-w(i, j-1, k, ivz)*sj(i, j&
&     -1, k, 2)+w(i, j, k+1, ivz)*sk(i, j, k, 2)-w(i, j, k-1, ivz)*sk(i&
&     , j, k-1, 2))*fact
    dwdz = (w(i+1, j, k, ivz)*si(i, j, k, 3)-w(i-1, j, k, ivz)*si(i-1, j&
&     , k, 3)+w(i, j+1, k, ivz)*sj(i, j, k, 3)-w(i, j-1, k, ivz)*sj(i, j&
&     -1, k, 3)+w(i, j, k+1, ivz)*sk(i, j, k, 3)-w(i, j, k-1, ivz)*sk(i&
&     , j, k-1, 3))*fact
    du_dx = u_inv*(w(i, j, k, ivx)*dudx+w(i, j, k, ivy)*dudy+w(i, j, k, &
&     ivz)*dudz)
    du_dy = u_inv*(w(i, j, k, ivx)*dvdx+w(i, j, k, ivy)*dvdy+w(i, j, k, &
&     ivz)*dvdz)
    du_dz = u_inv*(w(i, j, k, ivx)*dwdx+w(i, j, k, ivy)*dwdy+w(i, j, k, &
&     ivz)*dwdz)
    du_ds = w(i, j, k, ivx)/u*du_dx + w(i, j, k, ivy)/u*du_dy + w(i, j, &
&     k, ivz)/u*du_dz
    tu = 100.0*sqrt(2*w(i, j, k, itu1)/3)/u
! tu = max(tu, 0.027) ! clip for numerical robustness
! now we need to solve for theta through newton's method. the number of iterations is hard-coded so tapenade is 
! able to differentiate it
    thetat = 0.01
    do n=1,10
      lambda = w(i, j, k, irho)*thetat**2/rlv(i, j, k)*du_ds
! lambda = max(min(lambda, 0.1), -0.1) ! clip for numerical robustness
! compute f function
      f1 = 1.0 + 0.275*(1.0-exp(-(35.0*lambda)))*exp(-(tu/0.5))
      if (f1 .lt. 1.0) then
        f2 = 1.0
      else
        f2 = f1
      end if
      f3 = 1.0 - (-(12.986*lambda)-123.66*lambda**2-405.689*lambda**3)*&
&       exp(-((tu/1.5)**1.5))
      if (f2 .gt. f3) then
        f = f3
      else
        f = f2
      end if
      if (tu .gt. 1.3) then
        re_thetat_eq_1 = 331.50*(tu-0.5658)**(-0.671)*f
      else
        re_thetat_eq_1 = (1173.51-589.428*tu+0.2196*tu**(-2))*f
      end if
      re_thetat_eq_2 = w(i, j, k, irho)*u*thetat/rlv(i, j, k)
! residum which should go to 0
      residum = re_thetat_eq_1 - re_thetat_eq_2
! print *, 'iteration, thetat, residum, re_thetat_eq_1', n, thetat, residum, re_thetat_eq_1
! if we are in the first iteration, we need to kickstart the secant method first
      if (n .eq. 1) then
        residum_old = residum
        thetat_old = thetat
        thetat = 0.5*thetat
      else
        if (residum .ge. 0.) then
          abs0 = residum
        else
          abs0 = -residum
        end if
! if the residum is basically 0, we cycle until we reach the end. (we cant drop out because tapenade would be unable to
! differentiate it)
        if (abs0 .gt. 1e-9) then
! cycle
          thetat_new = (thetat_old*residum-thetat*residum_old)/(residum-&
&           residum_old)
        else
          thetat_new = thetat
        end if
! compute next step (secant method)
! thetat_new = (thetat_old*residum - thetat*residum_old) / (residum - residum_old)
! save values for next iteration
        residum_old = residum
        thetat_old = thetat
        thetat = thetat_new
! todo: make sure this still works after getting rid of 'cycle'
      end if
    end do
! save result in output-variable
! re_thetat_eq = max(re_thetat_eq_1, 20.0) ! clip for numerical robustness
! print *, 'thetat, lambda, re_thetat_eq', thetat, lambda, re_thetat_eq

  end subroutine solve_local_re_thetat_eq

  subroutine gammarethetasource()
    use blockpointers
    use constants
    use variableconstants
    use paramturb
    implicit none
    integer(kind=inttype) :: i, j, k
    real(kind=realtype) :: re_thetat_eq, u2, u, lambda_theta, delta, &
&   f_theta_t, t, r_t, re_theta_c
    real(kind=realtype) :: re_s, f_length1, f_length, f_onset1, f_onset&
&   , f_turb, p_gamma, e_gamma, p_thetat
    real(kind=realtype) :: re_omega, f_wake
    real(kind=realtype) :: rhoi, vort
    intrinsic mod
    intrinsic sqrt
    intrinsic max
    intrinsic exp
    intrinsic min
    intrinsic sin
    intrinsic tanh
    real(kind=realtype) :: x1
    real(kind=realtype) :: x2
    real(kind=realtype) :: x3
    integer :: ii
!$ad ii-loop
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
      rhoi = one/w(i, j, k, irho)
      x1 = sqrt(scratch(i, j, k, ivorticity))
      if (x1 .lt. eps) then
        vort = eps
      else
        vort = x1
      end if
! compute re_thetat_eq
      call solve_local_re_thetat_eq(re_thetat_eq, i, j, k)
      u2 = w(i, j, k, ivx)**2 + w(i, j, k, ivy)**2 + w(i, j, k, ivz)**2
      u = sqrt(u2)
      re_omega = w(i, j, k, irho)*w(i, j, k, itu2)*d2wall(i, j, k)**2/&
&       rlv(i, j, k)
      f_wake = exp(-((re_omega/1e5)**2))
      delta = 375.0*vort*w(i, j, k, itransition2)*d2wall(i, j, k)/(w(i, &
&       j, k, irho)*u)
      x3 = f_wake*exp(-((d2wall(i, j, k)/delta)**4))
      if (x3 .lt. 1.0 - ((rlmce2*w(i, j, k, itransition1)-1.0)/(rlmce2-1&
&         ))**2) then
        x2 = 1.0 - ((rlmce2*w(i, j, k, itransition1)-1.0)/(rlmce2-1))**2
      else
        x2 = x3
      end if
      if (x2 .gt. 1.0) then
        f_theta_t = 1.0
      else
        f_theta_t = x2
      end if
      t = 500.0*rlv(i, j, k)/(w(i, j, k, irho)*u2)
! todo: save this in scratch
      r_t = w(i, j, k, irho)*w(i, j, k, itu1)/(rlv(i, j, k)*w(i, j, k, &
&       itu2))
! todo: save this in scratch
      re_theta_c = 0.67*w(i, j, k, itransition2) + 24.0*sin(w(i, j, k, &
&       itransition2)/240.0+0.5) + 14.0
! todo: save this in scratch
      re_s = w(i, j, k, irho)*sqrt(scratch(i, j, k, istrain))*d2wall(i, &
&       j, k)**2/rev(i, j, k)
      f_length1 = exp(-(0.03*(w(i, j, k, itransition2)-460.0)))
      f_length = 44.0 - (44.0-(0.5-30000.0*(w(i, j, k, itransition2)-&
&       596.0)))/(1+f_length1)**(1/6)
! continue here
      f_onset1 = sqrt(re_s/(2.6*re_theta_c))
      f_onset = (tanh(6.0*(f_onset1-1.35))+1.0)/2.0
      f_turb = (1-f_onset)*exp(-r_t)
! since we need to divide by rho, rho does not appear here anymore
      p_gamma = f_length*rlmca1*w(i, j, k, irho)*sqrt(scratch(i, j, k, &
&       istrain))*sqrt(w(i, j, k, itransition1)*f_onset)*(1.0-rlmce1*w(i&
&       , j, k, itransition1))
      e_gamma = rlmca2*w(i, j, k, irho)*vort*w(i, j, k, itransition1)*&
&       f_turb*(rlmce2*w(i, j, k, itransition1)-1.0)
! somewhere here is the problem regarding partials not matching
      p_thetat = rlmcthetat*w(i, j, k, irho)/t*(re_thetat_eq-w(i, j, k, &
&       itransition2))*(1.0-f_theta_t)
      scratch(i, j, k, istransition1) = (p_gamma-e_gamma)*rhoi
      scratch(i, j, k, istransition2) = p_thetat*rhoi
! print *, 'source terms: gamma, thetat', scratch(i, j, k, istransition1), scratch(i, j, k, istransition2)
    end do
  end subroutine gammarethetasource

  subroutine gammarethetaviscous()
    use blockpointers
    use constants
    use variableconstants
    use paramturb
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rhoi
    real(kind=realtype) :: voli, volmi, volpi
    real(kind=realtype) :: xm, ym, zm, xp, yp, zp, xa, ya, za
    real(kind=realtype) :: mulm, mulp, muem, muep
    real(kind=realtype) :: ttm, ttp
    real(kind=realtype) :: c1m, c1p, c10, c2m, c2p, c20
    real(kind=realtype) :: rblank
    intrinsic mod
!$ad ii-loop
!       advection and unsteady terms.
!
!
!       viscous terms in k-direction.
!
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in zeta-direction, i.e. along the
! line k = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j, k-1))
      volpi = two/(vol(i, j, k)+vol(i, j, k+1))
      xm = sk(i, j, k-1, 1)*volmi
      ym = sk(i, j, k-1, 2)*volmi
      zm = sk(i, j, k-1, 3)*volmi
      xp = sk(i, j, k, 1)*volpi
      yp = sk(i, j, k, 2)*volpi
      zp = sk(i, j, k, 3)*volpi
      xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
      ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
      za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in zeta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in zeta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dzeta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the gamma-term.
      rhoi = one/w(i, j, k, irho)
      mulm = half*(rlv(i, j, k-1)+rlv(i, j, k))
      mulp = half*(rlv(i, j, k+1)+rlv(i, j, k))
      muem = half*(rev(i, j, k-1)+rev(i, j, k))
      muep = half*(rev(i, j, k+1)+rev(i, j, k))
      c1m = ttm*(mulm+muem/rlmsigmaf)*rhoi
      c1p = ttp*(mulp+muep/rlmsigmaf)*rhoi
      c10 = c1m + c1p
! and the re_theta_t term.
      muem = half*(rev(i, j, k-1)+rev(i, j, k))
      muep = half*(rev(i, j, k+1)+rev(i, j, k))
      c2m = ttm*rlmsigmathetat*(mulm+muem)*rhoi
      c2p = ttp*rlmsigmathetat*(mulp+muep)*rhoi
      c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
      scratch(i, j, k, istransition1) = scratch(i, j, k, istransition1) &
&       + c1m*w(i, j, k-1, itransition1) - c10*w(i, j, k, itransition1) &
&       + c1p*w(i, j, k+1, itransition1)
      scratch(i, j, k, istransition2) = scratch(i, j, k, istransition2) &
&       + c2m*w(i, j, k-1, itransition2) - c20*w(i, j, k, itransition2) &
&       + c2p*w(i, j, k+1, itransition2)
! #ifndef 1
!                         b1 = -c1m
!                         c1 = c10
!                         d1 = -c1p
!                         b2 = -c2m
!                         c2 = c20
!                         d2 = -c2p
!                         ! update the central jacobian. for nonboundary cells this
!                         ! is simply c1 and c2. for boundary cells this is slightly
!                         ! more complicated, because the boundary conditions are
!                         ! treated implicitly and the off-diagonal terms b1, b2 and
!                         ! d1, d2 must be taken into account.
!                         ! the boundary conditions are only treated implicitly if
!                         ! the diagonal dominance of the matrix is increased.
!                         if (k == 2) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - b1 * max(bmtk1(i, j, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - b1 * bmtk1(i, j, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - b2 * bmtk1(i, j, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - b2 * max(bmtk1(i, j, itu2, itu2), zero)
!                         else if (k == kl) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - d1 * max(bmtk2(i, j, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - d1 * bmtk2(i, j, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - d2 * bmtk2(i, j, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - d2 * max(bmtk2(i, j, itu2, itu2), zero)
!                         else
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2
!                         end if
! #endif
    end do
!$ad ii-loop
!
!       viscous terms in j-direction.
!
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in eta-direction, i.e. along the
! line j = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i, j-1, k))
      volpi = two/(vol(i, j, k)+vol(i, j+1, k))
      xm = sj(i, j-1, k, 1)*volmi
      ym = sj(i, j-1, k, 2)*volmi
      zm = sj(i, j-1, k, 3)*volmi
      xp = sj(i, j, k, 1)*volpi
      yp = sj(i, j, k, 2)*volpi
      zp = sj(i, j, k, 3)*volpi
      xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
      ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
      za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in eta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in eta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/deta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the gamma-term.
      rhoi = one/w(i, j, k, irho)
      mulm = half*(rlv(i, j-1, k)+rlv(i, j, k))
      mulp = half*(rlv(i, j+1, k)+rlv(i, j, k))
      muem = half*(rev(i, j-1, k)+rev(i, j, k))
      muep = half*(rev(i, j+1, k)+rev(i, j, k))
      c1m = ttm*(mulm+muem/rlmsigmaf)*rhoi
      c1p = ttp*(mulp+muep/rlmsigmaf)*rhoi
      c10 = c1m + c1p
! and the re_theta_t term.
      muem = half*(rev(i, j-1, k)+rev(i, j, k))
      muep = half*(rev(i, j+1, k)+rev(i, j, k))
      c2m = ttm*rlmsigmathetat*(mulm+muem)*rhoi
      c2p = ttp*rlmsigmathetat*(mulp+muep)*rhoi
      c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
      scratch(i, j, k, istransition1) = scratch(i, j, k, istransition1) &
&       + c1m*w(i, j-1, k, itransition1) - c10*w(i, j, k, itransition1) &
&       + c1p*w(i, j+1, k, itransition1)
      scratch(i, j, k, istransition2) = scratch(i, j, k, istransition2) &
&       + c2m*w(i, j-1, k, itransition2) - c20*w(i, j, k, itransition2) &
&       + c2p*w(i, j+1, k, itransition2)
! #ifndef 1
!                         b1 = -c1m
!                         c1 = c10
!                         d1 = -c1p
!                         b2 = -c2m
!                         c2 = c20
!                         d2 = -c2p
!                         ! update the central jacobian. for nonboundary cells this
!                         ! is simply c1 and c2. for boundary cells this is slightly
!                         ! more complicated, because the boundary conditions are
!                         ! treated implicitly and the off-diagonal terms b1, b2 and
!                         ! d1, d2 must be taken into account.
!                         ! the boundary conditions are only treated implicitly if
!                         ! the diagonal dominance of the matrix is increased.
!                         if (j == 2) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - b1 * max(bmtj1(i, k, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - b1 * bmtj1(i, k, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - b2 * bmtj1(i, k, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - b2 * max(bmtj1(i, k, itu2, itu2), zero)
!                         else if (j == jl) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - d1 * max(bmtj2(i, k, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - d1 * bmtj2(i, k, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - d2 * bmtj2(i, k, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - d2 * max(bmtj2(i, k, itu2, itu2), zero)
!                         else
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2
!                         end if
! #endif
    end do
!$ad ii-loop
!
!       viscous terms in i-direction.
!
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
! compute the metrics in xi-direction, i.e. along the
! line i = constant.
      voli = one/vol(i, j, k)
      volmi = two/(vol(i, j, k)+vol(i-1, j, k))
      volpi = two/(vol(i, j, k)+vol(i+1, j, k))
      xm = si(i-1, j, k, 1)*volmi
      ym = si(i-1, j, k, 2)*volmi
      zm = si(i-1, j, k, 3)*volmi
      xp = si(i, j, k, 1)*volpi
      yp = si(i, j, k, 2)*volpi
      zp = si(i, j, k, 3)*volpi
      xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
      ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
      za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
      ttm = xm*xa + ym*ya + zm*za
      ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in xi-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in xi-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dxi derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the gamma-term.
      rhoi = one/w(i, j, k, irho)
      mulm = half*(rlv(i-1, j, k)+rlv(i, j, k))
      mulp = half*(rlv(i+1, j, k)+rlv(i, j, k))
      muem = half*(rev(i-1, j, k)+rev(i, j, k))
      muep = half*(rev(i+1, j, k)+rev(i, j, k))
      c1m = ttm*(mulm+muem/rlmsigmaf)*rhoi
      c1p = ttp*(mulp+muep/rlmsigmaf)*rhoi
      c10 = c1m + c1p
! and the re_theta_t term.
      muem = half*(rev(i-1, j, k)+rev(i, j, k))
      muep = half*(rev(i+1, j, k)+rev(i, j, k))
      c2m = ttm*rlmsigmathetat*(mulm+muem)*rhoi
      c2p = ttp*rlmsigmathetat*(mulp+muep)*rhoi
      c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
      scratch(i, j, k, istransition1) = scratch(i, j, k, istransition1) &
&       + c1m*w(i-1, j, k, itransition1) - c10*w(i, j, k, itransition1) &
&       + c1p*w(i+1, j, k, itransition1)
      scratch(i, j, k, istransition2) = scratch(i, j, k, istransition2) &
&       + c2m*w(i-1, j, k, itransition2) - c20*w(i, j, k, itransition2) &
&       + c2p*w(i+1, j, k, itransition2)
! #ifndef 1
!                         b1 = -c1m
!                         c1 = c10
!                         d1 = -c1p
!                         b2 = -c2m
!                         c2 = c20
!                         d2 = -c2p
!                         ! update the central jacobian. for nonboundary cells this
!                         ! is simply c1 and c2. for boundary cells this is slightly
!                         ! more complicated, because the boundary conditions are
!                         ! treated implicitly and the off-diagonal terms b1, b2 and
!                         ! d1, d2 must be taken into account.
!                         ! the boundary conditions are only treated implicitly if
!                         ! the diagonal dominance of the matrix is increased.
!                         if (i == 2) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - b1 * max(bmti1(j, k, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - b1 * bmti1(j, k, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - b2 * bmti1(j, k, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - b2 * max(bmti1(j, k, itu2, itu2), zero)
!                         else if (i == il) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - d1 * max(bmti2(j, k, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - d1 * bmti2(j, k, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - d2 * bmti2(j, k, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - d2 * max(bmti2(j, k, itu2, itu2), zero)
!                         else
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2
!                         end if
! #endif
    end do
  end subroutine gammarethetaviscous

  subroutine gammarethetaresscale()
    use blockpointers
    use constants
    use variableconstants
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rblank
    intrinsic mod
    intrinsic real
!$ad ii-loop
! multiply the residual by the volume and store this in dw; this
! is done for monitoring reasons only. the multiplication with the
! volume is present to be consistent with the flow residuals; also
! the negative value is taken, again to be consistent with the
! flow equations. also multiply by iblank so that no updates occur
! in holes or the overset boundary.
    do ii=0,nx*ny*nz-1
      i = mod(ii, nx) + 2
      j = mod(ii/nx, ny) + 2
      k = ii/(nx*ny) + 2
      rblank = real(iblank(i, j, k), realtype)
      dw(i, j, k, itransition1) = -(volref(i, j, k)*scratch(i, j, k, &
&       istransition1)*rblank)
      dw(i, j, k, itransition2) = -(volref(i, j, k)*scratch(i, j, k, &
&       istransition2)*rblank)
! print *, 'dw transition 1 & 2', dw(i, j, k, itransition1), dw(i, j, k, itransition2)
    end do
  end subroutine gammarethetaresscale

end module gammarethetamodel_fast_b

