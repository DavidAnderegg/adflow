!        generated by tapenade     (inria, ecuador team)
!  tapenade 3.16 (develop) - 10 nov 2023 18:24
!
module sst_d
! this module contains the source code related to the sst turbulence
! model. it is slightly more modularized than the original which makes
! performing reverse mode ad simplier.
  use constants
  implicit none
  real(kind=realtype), dimension(:, :, :, :, :), allocatable :: qq
  real(kind=realtype), dimension(:, :, :), pointer :: ddw, ww, ddvt
  real(kind=realtype), dimension(:, :), pointer :: rrlv
  real(kind=realtype), dimension(:, :), pointer :: dd2wall

contains
!  differentiation of sstsource in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *scratch
!   with respect to varying inputs: *rev *w *rlv *scratch *d2wall
!   rw status of diff variables: *rev:in *w:in *rlv:in *scratch:in-out
!                *d2wall:in
!   plus diff mem management of: rev:in w:in rlv:in scratch:in
!                d2wall:in
  subroutine sstsource_d()
!
!       sstsolve solves the turbulent transport equations for
!       menter's sst variant of the k-omega model in a decoupled
!       manner using a diagonal dominant adi-scheme.
!
    use blockpointers
    use constants
    use variableconstants
    use inputphysics
    use inputdiscretization, only : approxturb
    use paramturb
    use utils_d, only : smoothmin, smoothmin_d, smoothmax
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k
    real(kind=realtype) :: rsstgam1, rsstgam2, t1, t2
    real(kind=realtype) :: t1d, t2d
    real(kind=realtype) :: rsstgam, rsstbeta
    real(kind=realtype) :: rsstgamd, rsstbetad
    real(kind=realtype) :: rhoi, ss, spk, sdk
    real(kind=realtype) :: rhoid, ssd, spkd, sdkd
    real(kind=realtype) :: xm, ym, zm, xp, yp, zp, xa, ya, za
    real(kind=realtype) :: re_w, u, f_wake, delta, r_t, re_s, f_theta_t
    real(kind=realtype) :: re_wd, ud, f_waked, deltad, r_td, re_sd, &
&   f_theta_td
    real(kind=realtype) :: re_theta_c, f_reattach, gamma_sep, gamma_eff
    real(kind=realtype) :: re_theta, f_reattachd, gamma_sepd, &
&   gamma_effd
    real(kind=realtype) :: vort, phi
    real(kind=realtype) :: vortd
    intrinsic sqrt
    intrinsic max
    intrinsic exp
    intrinsic min
    intrinsic sin
    real(kind=realtype) :: x1
    real(kind=realtype) :: x1d
    real(kind=realtype) :: x2
    real(kind=realtype) :: x2d
    real(kind=realtype) :: x3
    real(kind=realtype) :: x3d
    real(kind=realtype) :: x4
    real(kind=realtype) :: x4d
    real(kind=realtype) :: x5
    real(kind=realtype) :: x5d
    real(kind=realtype) :: min1
    real(kind=realtype) :: min1d
    real(kind=realtype) :: min2
    real(kind=realtype) :: min2d
    real(kind=realtype) :: max1
    real(kind=realtype) :: max1d
    real(kind=realtype) :: result1
    real(kind=realtype) :: result1d
    real(kind=realtype) :: arg1
    real(kind=realtype) :: arg1d
    real(kind=realtype) :: temp
    real(kind=realtype) :: temp0
    real(kind=realtype) :: temp1
    real(kind=realtype) :: temp2
    real(kind=realtype) :: temp3
! set model constants
    if (use2003sst) then
      rsstgam1 = 5.0_realtype/9.0_realtype
      rsstgam2 = 0.44_realtype
      pklim = 20.0
    else
      result1 = sqrt(rsstbetas)
      rsstgam1 = rsstbeta1/rsstbetas - rsstsigw1*rsstk*rsstk/result1
      result1 = sqrt(rsstbetas)
      rsstgam2 = rsstbeta2/rsstbetas - rsstsigw2*rsstk*rsstk/result1
      pklim = 20.0
    end if
! control value for smooth min/max functions. needs to be declared in advance because of 'complexify'
    phi = 1.0e15_realtype
!       source terms.
!       determine the source term and its derivative w.r.t. k and
!       omega for all internal cells of the block.
!       note that the blending function f1 and the cross diffusion
!       were computed earlier in f1sst.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the blended value of rsstgam and rsstbeta,
! which occur in the production terms of k and omega.
          t1d = scratchd(i, j, k, if1sst)
          t1 = scratch(i, j, k, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstgamd = rsstgam1*t1d + rsstgam2*t2d
          rsstgam = t1*rsstgam1 + t2*rsstgam2
          rsstbetad = rsstbeta1*t1d + rsstbeta2*t2d
          rsstbeta = t1*rsstbeta1 + t2*rsstbeta2
! compute the source terms for both the k and the omega
! equation. note that dw(i,j,k,iprod) currently contains the
! unscaled source term. furthermore the production term of
! k is limited to a certain times the destruction term.
! these are the same equations as in https://turbmodels.larc.nasa.gov/sst.html
! except that everything is divided by rho here
          temp = one/w(i, j, k, irho)
          rhoid = -(temp*wd(i, j, k, irho)/w(i, j, k, irho))
          rhoi = temp
          ssd = scratchd(i, j, k, iprod)
          ss = scratch(i, j, k, iprod)
          if (approxturb) then
            spk = zero
            spkd = 0.0_8
          else
            spkd = ss*rhoi*revd(i, j, k) + rev(i, j, k)*(rhoi*ssd+ss*&
&             rhoid)
            spk = rev(i, j, k)*ss*rhoi
          end if
          temp = w(i, j, k, itu2)
          temp0 = w(i, j, k, itu1)
          sdkd = rsstbetas*(temp*wd(i, j, k, itu1)+temp0*wd(i, j, k, &
&           itu2))
          sdk = rsstbetas*(temp0*temp)
          call smoothmin_d(spk, spkd, spk, spkd, pklim*sdk, pklim*sdkd, &
&                    phi)
          if (transitionmodel .eq. gammaretheta) then
            temp0 = scratch(i, j, k, ivorticity)
            temp = sqrt(temp0)
            if (temp0 .eq. 0.0_8) then
              x1d = 0.0_8
            else
              x1d = scratchd(i, j, k, ivorticity)/(2.0*temp)
            end if
            x1 = temp
            if (x1 .lt. eps) then
              vort = eps
              vortd = 0.0_8
            else
              vortd = x1d
              vort = x1
            end if
            temp0 = d2wall(i, j, k)
            temp = w(i, j, k, itu2)
            temp1 = temp*(temp0*temp0)
            temp2 = w(i, j, k, irho)/rlv(i, j, k)
            re_wd = temp1*(wd(i, j, k, irho)-temp2*rlvd(i, j, k))/rlv(i&
&             , j, k) + temp2*(temp0**2*wd(i, j, k, itu2)+temp*2*temp0*&
&             d2walld(i, j, k))
            re_w = temp2*temp1
            temp2 = w(i, j, k, ivx)
            temp1 = w(i, j, k, ivy)
            temp0 = w(i, j, k, ivz)
            arg1d = 2*temp2*wd(i, j, k, ivx) + 2*temp1*wd(i, j, k, ivy) &
&             + 2*temp0*wd(i, j, k, ivz)
            arg1 = temp2*temp2 + temp1*temp1 + temp0*temp0
            temp2 = sqrt(arg1)
            if (arg1 .eq. 0.0_8) then
              ud = 0.0_8
            else
              ud = arg1d/(2.0*temp2)
            end if
            u = temp2
            arg1d = -(2*re_w*re_wd/100000.0**2)
            arg1 = -((re_w/100000.0)**2)
            f_waked = exp(arg1)*arg1d
            f_wake = exp(arg1)
! todo: pull out of scratch
            temp2 = w(i, j, k, itu2)
            temp1 = rlv(i, j, k)*temp2
            temp0 = w(i, j, k, itu1)
            temp = w(i, j, k, irho)
            temp3 = temp*temp0/temp1
            r_td = (temp0*wd(i, j, k, irho)+temp*wd(i, j, k, itu1)-temp3&
&             *(temp2*rlvd(i, j, k)+rlv(i, j, k)*wd(i, j, k, itu2)))/&
&             temp1
            r_t = temp3
! todo: pull out of scratch
            temp3 = scratch(i, j, k, istrain)
            temp2 = sqrt(temp3)
            if (temp3 .eq. 0.0_8) then
              result1d = 0.0_8
            else
              result1d = scratchd(i, j, k, istrain)/(2.0*temp2)
            end if
            result1 = temp2
            temp3 = result1/rev(i, j, k)
            temp2 = d2wall(i, j, k)
            temp1 = w(i, j, k, irho)
            temp0 = temp1*(temp2*temp2)
            re_sd = temp3*(temp2**2*wd(i, j, k, irho)+temp1*2*temp2*&
&             d2walld(i, j, k)) + temp0*(result1d-temp3*revd(i, j, k))/&
&             rev(i, j, k)
            re_s = temp0*temp3
            temp3 = w(i, j, k, irho)
            temp2 = d2wall(i, j, k)
            temp1 = w(i, j, k, itransition2)
            temp0 = temp1*vort*temp2/(temp3*u)
            deltad = 375.0*(vort*temp2*wd(i, j, k, itransition2)+temp1*(&
&             temp2*vortd+vort*d2walld(i, j, k))-temp0*(u*wd(i, j, k, &
&             irho)+temp3*ud))/(temp3*u)
            delta = 375.0*temp0
            temp3 = d2wall(i, j, k)/delta
            arg1d = -(4*temp3**3*(d2walld(i, j, k)-temp3*deltad)/delta)
            arg1 = -(temp3**4)
            temp3 = exp(arg1)
            x5d = temp3*f_waked + f_wake*exp(arg1)*arg1d
            x5 = f_wake*temp3
            if (x5 .lt. 1.0 - ((rlmce2*w(i, j, k, itransition1)-1.0)/(&
&               rlmce2-1))**2) then
              temp3 = (rlmce2*w(i, j, k, itransition1)-1.0)/(rlmce2-1)
              x2d = -(2*temp3*rlmce2*wd(i, j, k, itransition1)/(rlmce2-1&
&               ))
              x2 = 1.0 - temp3*temp3
            else
              x2d = x5d
              x2 = x5
            end if
            if (x2 .gt. 1.0) then
              f_theta_t = 1.0
              f_theta_td = 0.0_8
            else
              f_theta_td = x2d
              f_theta_t = x2
            end if
! this comes from the smooth variant
            arg1d = wd(i, j, k, itransition2)/240.0
            arg1 = w(i, j, k, itransition2)/240.0 + 0.5
            re_theta = 0.67*wd(i, j, k, itransition2) + 24.0*cos(arg1&
&             )*arg1d
            re_theta_c = 0.67*w(i, j, k, itransition2) + 24.0*sin(arg1) &
&             + 14.0
            arg1d = -(4*r_t**3*r_td/20.0**4)
            arg1 = -((r_t/20.0)**4)
            f_reattachd = exp(arg1)*arg1d
            f_reattach = exp(arg1)
            if (0.0 .lt. re_s/3.235*re_theta_c - 1.0) then
              max1d = re_theta_c*re_sd/3.235 + re_s*re_theta/3.235
              max1 = re_s/3.235*re_theta_c - 1.0
            else
              max1 = 0.0
              max1d = 0.0_8
            end if
            x3d = rlms1*(f_reattach*max1d+max1*f_reattachd)
            x3 = rlms1*max1*f_reattach
            if (x3 .gt. 2.0) then
              min1 = 2.0
              min1d = 0.0_8
            else
              min1d = x3d
              min1 = x3
            end if
            gamma_sepd = f_theta_t*min1d + min1*f_theta_td
            gamma_sep = min1*f_theta_t
            if (w(i, j, k, itransition1) .lt. gamma_sep) then
              gamma_effd = gamma_sepd
              gamma_eff = gamma_sep
            else
              gamma_effd = wd(i, j, k, itransition1)
              gamma_eff = w(i, j, k, itransition1)
            end if
! if gamma_eff = 1, the original sst should come out
            spkd = spk*gamma_effd + gamma_eff*spkd
            spk = gamma_eff*spk
            if (gamma_eff .lt. 0.1) then
              x4 = 0.1
              x4d = 0.0_8
            else
              x4d = gamma_effd
              x4 = gamma_eff
            end if
            if (x4 .gt. 1.0) then
              min2 = 1.0
              min2d = 0.0_8
            else
              min2d = x4d
              min2 = x4
            end if
            sdkd = sdk*min2d + min2*sdkd
            sdk = min2*sdk
          end if
          scratchd(i, j, k, idvt) = spkd - sdkd
          scratch(i, j, k, idvt) = spk - sdk
          if (use2003sst) then
            temp3 = rsstgam*spk/rev(i, j, k)
            temp2 = scratch(i, j, k, icd)
            temp1 = w(i, j, k, itu2)
            scratchd(i, j, k, idvt+1) = (spk*rsstgamd+rsstgam*spkd-temp3&
&             *revd(i, j, k))/rev(i, j, k) + two*rsstsigw2*(temp2*t2d+t2&
&             *scratchd(i, j, k, icd)) - temp1**2*rsstbetad - rsstbeta*2&
&             *temp1*wd(i, j, k, itu2)
            scratch(i, j, k, idvt+1) = temp3 + two*rsstsigw2*(t2*temp2) &
&             - rsstbeta*(temp1*temp1)
          else
            temp3 = scratch(i, j, k, icd)
            temp2 = w(i, j, k, itu2)
            scratchd(i, j, k, idvt+1) = ss*rsstgamd + rsstgam*ssd + two*&
&             rsstsigw2*(temp3*t2d+t2*scratchd(i, j, k, icd)) - temp2**2&
&             *rsstbetad - rsstbeta*2*temp2*wd(i, j, k, itu2)
            scratch(i, j, k, idvt+1) = rsstgam*ss + two*rsstsigw2*(t2*&
&             temp3) - rsstbeta*(temp2*temp2)
          end if
! compute the source term jacobian. note that only the
! destruction terms are linearized to increase the diagonal
! dominance of the matrix. furthermore minus the source
! term jacobian is stored.

        end do
      end do
    end do
  end subroutine sstsource_d

  subroutine sstsource()
!
!       sstsolve solves the turbulent transport equations for
!       menter's sst variant of the k-omega model in a decoupled
!       manner using a diagonal dominant adi-scheme.
!
    use blockpointers
    use constants
    use variableconstants
    use inputphysics
    use inputdiscretization, only : approxturb
    use paramturb
    use utils_d, only : smoothmin, smoothmax
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k
    real(kind=realtype) :: rsstgam1, rsstgam2, t1, t2
    real(kind=realtype) :: rsstgam, rsstbeta
    real(kind=realtype) :: rhoi, ss, spk, sdk
    real(kind=realtype) :: xm, ym, zm, xp, yp, zp, xa, ya, za
    real(kind=realtype) :: re_w, u, f_wake, delta, r_t, re_s, f_theta_t
    real(kind=realtype) :: re_theta_c, f_reattach, gamma_sep, gamma_eff
    real(kind=realtype) :: vort, phi
    intrinsic sqrt
    intrinsic max
    intrinsic exp
    intrinsic min
    intrinsic sin
    real(kind=realtype) :: x1
    real(kind=realtype) :: x2
    real(kind=realtype) :: x3
    real(kind=realtype) :: x4
    real(kind=realtype) :: x5
    real(kind=realtype) :: min1
    real(kind=realtype) :: min2
    real(kind=realtype) :: max1
    real(kind=realtype) :: result1
    real(kind=realtype) :: arg1
! set model constants
    if (use2003sst) then
      rsstgam1 = 5.0_realtype/9.0_realtype
      rsstgam2 = 0.44_realtype
      pklim = 20.0
    else
      result1 = sqrt(rsstbetas)
      rsstgam1 = rsstbeta1/rsstbetas - rsstsigw1*rsstk*rsstk/result1
      result1 = sqrt(rsstbetas)
      rsstgam2 = rsstbeta2/rsstbetas - rsstsigw2*rsstk*rsstk/result1
      pklim = 20.0
    end if
! control value for smooth min/max functions. needs to be declared in advance because of 'complexify'
    phi = 1.0e15_realtype
!       source terms.
!       determine the source term and its derivative w.r.t. k and
!       omega for all internal cells of the block.
!       note that the blending function f1 and the cross diffusion
!       were computed earlier in f1sst.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the blended value of rsstgam and rsstbeta,
! which occur in the production terms of k and omega.
          t1 = scratch(i, j, k, if1sst)
          t2 = one - t1
          rsstgam = t1*rsstgam1 + t2*rsstgam2
          rsstbeta = t1*rsstbeta1 + t2*rsstbeta2
! compute the source terms for both the k and the omega
! equation. note that dw(i,j,k,iprod) currently contains the
! unscaled source term. furthermore the production term of
! k is limited to a certain times the destruction term.
! these are the same equations as in https://turbmodels.larc.nasa.gov/sst.html
! except that everything is divided by rho here
          rhoi = one/w(i, j, k, irho)
          ss = scratch(i, j, k, iprod)
          if (approxturb) then
            spk = zero
          else
            spk = rev(i, j, k)*ss*rhoi
          end if
          sdk = rsstbetas*w(i, j, k, itu1)*w(i, j, k, itu2)
          call smoothmin(spk, spk, pklim*sdk, phi)
          if (transitionmodel .eq. gammaretheta) then
            x1 = sqrt(scratch(i, j, k, ivorticity))
            if (x1 .lt. eps) then
              vort = eps
            else
              vort = x1
            end if
            re_w = w(i, j, k, irho)*w(i, j, k, itu2)*d2wall(i, j, k)**2/&
&             rlv(i, j, k)
            arg1 = w(i, j, k, ivx)**2 + w(i, j, k, ivy)**2 + w(i, j, k, &
&             ivz)**2
            u = sqrt(arg1)
            arg1 = -((re_w/100000.0)**2)
            f_wake = exp(arg1)
! todo: pull out of scratch
            r_t = w(i, j, k, irho)*w(i, j, k, itu1)/(rlv(i, j, k)*w(i, j&
&             , k, itu2))
! todo: pull out of scratch
            result1 = sqrt(scratch(i, j, k, istrain))
            re_s = w(i, j, k, irho)*result1*d2wall(i, j, k)**2/rev(i, j&
&             , k)
            delta = 375.0*vort*w(i, j, k, itransition2)*d2wall(i, j, k)/&
&             (w(i, j, k, irho)*u)
            arg1 = -((d2wall(i, j, k)/delta)**4)
            x5 = f_wake*exp(arg1)
            if (x5 .lt. 1.0 - ((rlmce2*w(i, j, k, itransition1)-1.0)/(&
&               rlmce2-1))**2) then
              x2 = 1.0 - ((rlmce2*w(i, j, k, itransition1)-1.0)/(rlmce2-&
&               1))**2
            else
              x2 = x5
            end if
            if (x2 .gt. 1.0) then
              f_theta_t = 1.0
            else
              f_theta_t = x2
            end if
! this comes from the smooth variant
            arg1 = w(i, j, k, itransition2)/240.0 + 0.5
            re_theta_c = 0.67*w(i, j, k, itransition2) + 24.0*sin(arg1) &
&             + 14.0
            arg1 = -((r_t/20.0)**4)
            f_reattach = exp(arg1)
            if (0.0 .lt. re_s/3.235*re_theta_c - 1.0) then
              max1 = re_s/3.235*re_theta_c - 1.0
            else
              max1 = 0.0
            end if
            x3 = rlms1*max1*f_reattach
            if (x3 .gt. 2.0) then
              min1 = 2.0
            else
              min1 = x3
            end if
            gamma_sep = min1*f_theta_t
            if (w(i, j, k, itransition1) .lt. gamma_sep) then
              gamma_eff = gamma_sep
            else
              gamma_eff = w(i, j, k, itransition1)
            end if
! if gamma_eff = 1, the original sst should come out
            spk = gamma_eff*spk
            if (gamma_eff .lt. 0.1) then
              x4 = 0.1
            else
              x4 = gamma_eff
            end if
            if (x4 .gt. 1.0) then
              min2 = 1.0
            else
              min2 = x4
            end if
            sdk = min2*sdk
          end if
          scratch(i, j, k, idvt) = spk - sdk
          if (use2003sst) then
            scratch(i, j, k, idvt+1) = rsstgam*spk/rev(i, j, k) + two*t2&
&             *rsstsigw2*scratch(i, j, k, icd) - rsstbeta*w(i, j, k, &
&             itu2)**2
          else
            scratch(i, j, k, idvt+1) = rsstgam*ss + two*t2*rsstsigw2*&
&             scratch(i, j, k, icd) - rsstbeta*w(i, j, k, itu2)**2
          end if
! compute the source term jacobian. note that only the
! destruction terms are linearized to increase the diagonal
! dominance of the matrix. furthermore minus the source
! term jacobian is stored.

        end do
      end do
    end do
  end subroutine sstsource

!  differentiation of sstviscous in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *scratch
!   with respect to varying inputs: *rev *w *rlv *scratch *vol
!                *si *sj *sk
!   rw status of diff variables: *rev:in *w:in *rlv:in *scratch:in-out
!                *vol:in *si:in *sj:in *sk:in
!   plus diff mem management of: rev:in w:in rlv:in scratch:in
!                vol:in si:in sj:in sk:in
  subroutine sstviscous_d()
    use blockpointers
    use constants
    use paramturb
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: t1, t2
    real(kind=realtype) :: t1d, t2d
    real(kind=realtype) :: rhoi
    real(kind=realtype) :: rhoid
    real(kind=realtype) :: voli, volmi, volpi
    real(kind=realtype) :: volid, volmid, volpid
    real(kind=realtype) :: xm, ym, zm, xp, yp, zp, xa, ya, za
    real(kind=realtype) :: xmd, ymd, zmd, xpd, ypd, zpd, xad, yad, zad
    real(kind=realtype) :: mulm, mulp, muem, muep
    real(kind=realtype) :: mulmd, mulpd, muemd, muepd
    real(kind=realtype) :: ttm, ttp
    real(kind=realtype) :: ttmd, ttpd
    real(kind=realtype) :: rsstsigkp1, rsstsigk, rsstsigkm1
    real(kind=realtype) :: rsstsigkp1d, rsstsigkd, rsstsigkm1d
    real(kind=realtype) :: rsstsigwp1, rsstsigw, rsstsigwm1
    real(kind=realtype) :: rsstsigwp1d, rsstsigwd, rsstsigwm1d
    real(kind=realtype) :: c1m, c1p, c10, c2m, c2p, c20
    real(kind=realtype) :: c1md, c1pd, c10d, c2md, c2pd, c20d
    real(kind=realtype) :: b1, b2, c1, c2, d1, d2
    real(kind=realtype) :: rblank
    real(kind=realtype) :: temp
    real(kind=realtype) :: temp0
    real(kind=realtype) :: temp1
!       advection and unsteady terms.
!
!
!       viscous terms in k-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in zeta-direction, i.e. along the
! line k = constant.
          temp = one/vol(i, j, k)
          volid = -(temp*vold(i, j, k)/vol(i, j, k))
          voli = temp
          temp = two/(vol(i, j, k)+vol(i, j, k-1))
          volmid = -(temp*(vold(i, j, k)+vold(i, j, k-1))/(vol(i, j, k)+&
&           vol(i, j, k-1)))
          volmi = temp
          temp = two/(vol(i, j, k)+vol(i, j, k+1))
          volpid = -(temp*(vold(i, j, k)+vold(i, j, k+1))/(vol(i, j, k)+&
&           vol(i, j, k+1)))
          volpi = temp
          temp = sk(i, j, k-1, 1)
          xmd = volmi*skd(i, j, k-1, 1) + temp*volmid
          xm = temp*volmi
          temp = sk(i, j, k-1, 2)
          ymd = volmi*skd(i, j, k-1, 2) + temp*volmid
          ym = temp*volmi
          temp = sk(i, j, k-1, 3)
          zmd = volmi*skd(i, j, k-1, 3) + temp*volmid
          zm = temp*volmi
          temp = sk(i, j, k, 1)
          xpd = volpi*skd(i, j, k, 1) + temp*volpid
          xp = temp*volpi
          temp = sk(i, j, k, 2)
          ypd = volpi*skd(i, j, k, 2) + temp*volpid
          yp = temp*volpi
          temp = sk(i, j, k, 3)
          zpd = volpi*skd(i, j, k, 3) + temp*volpid
          zp = temp*volpi
          temp = sk(i, j, k, 1) + sk(i, j, k-1, 1)
          xad = half*(voli*(skd(i, j, k, 1)+skd(i, j, k-1, 1))+temp*&
&           volid)
          xa = half*(temp*voli)
          temp = sk(i, j, k, 2) + sk(i, j, k-1, 2)
          yad = half*(voli*(skd(i, j, k, 2)+skd(i, j, k-1, 2))+temp*&
&           volid)
          ya = half*(temp*voli)
          temp = sk(i, j, k, 3) + sk(i, j, k-1, 3)
          zad = half*(voli*(skd(i, j, k, 3)+skd(i, j, k-1, 3))+temp*&
&           volid)
          za = half*(temp*voli)
          ttmd = xa*xmd + xm*xad + ya*ymd + ym*yad + za*zmd + zm*zad
          ttm = xm*xa + ym*ya + zm*za
          ttpd = xa*xpd + xp*xad + ya*ypd + yp*yad + za*zpd + zp*zad
          ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for k-1,
! k and k+1.
! caution: f1 must be known in neighbouring cells (including halos!)
          t1d = scratchd(i, j, k+1, if1sst)
          t1 = scratch(i, j, k+1, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstsigkp1d = rsstsigk1*t1d + rsstsigk2*t2d
          rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwp1d = rsstsigw1*t1d + rsstsigw2*t2d
          rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
          t1d = scratchd(i, j, k, if1sst)
          t1 = scratch(i, j, k, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstsigkd = rsstsigk1*t1d + rsstsigk2*t2d
          rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwd = rsstsigw1*t1d + rsstsigw2*t2d
          rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
          t1d = scratchd(i, j, k-1, if1sst)
          t1 = scratch(i, j, k-1, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstsigkm1d = rsstsigk1*t1d + rsstsigk2*t2d
          rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwm1d = rsstsigw1*t1d + rsstsigw2*t2d
          rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in zeta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in zeta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dzeta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
          temp = one/w(i, j, k, irho)
          rhoid = -(temp*wd(i, j, k, irho)/w(i, j, k, irho))
          rhoi = temp
          mulmd = half*(rlvd(i, j, k-1)+rlvd(i, j, k))
          mulm = half*(rlv(i, j, k-1)+rlv(i, j, k))
          mulpd = half*(rlvd(i, j, k+1)+rlvd(i, j, k))
          mulp = half*(rlv(i, j, k+1)+rlv(i, j, k))
          temp = rev(i, j, k-1)
          muemd = half*(temp*rsstsigkm1d+rsstsigkm1*revd(i, j, k-1)+rev(&
&           i, j, k)*rsstsigkd+rsstsigk*revd(i, j, k))
          muem = half*(rsstsigkm1*temp+rsstsigk*rev(i, j, k))
          temp = rev(i, j, k+1)
          muepd = half*(temp*rsstsigkp1d+rsstsigkp1*revd(i, j, k+1)+rev(&
&           i, j, k)*rsstsigkd+rsstsigk*revd(i, j, k))
          muep = half*(rsstsigkp1*temp+rsstsigk*rev(i, j, k))
          c1md = ttm*rhoi*(mulmd+muemd) + (mulm+muem)*(rhoi*ttmd+ttm*&
&           rhoid)
          c1m = ttm*(mulm+muem)*rhoi
          c1pd = ttp*rhoi*(mulpd+muepd) + (mulp+muep)*(rhoi*ttpd+ttp*&
&           rhoid)
          c1p = ttp*(mulp+muep)*rhoi
          c10d = c1md + c1pd
          c10 = c1m + c1p
! and the omega term.
          temp = rev(i, j, k-1)
          muemd = half*(temp*rsstsigwm1d+rsstsigwm1*revd(i, j, k-1)+rev(&
&           i, j, k)*rsstsigwd+rsstsigw*revd(i, j, k))
          muem = half*(rsstsigwm1*temp+rsstsigw*rev(i, j, k))
          temp = rev(i, j, k+1)
          muepd = half*(temp*rsstsigwp1d+rsstsigwp1*revd(i, j, k+1)+rev(&
&           i, j, k)*rsstsigwd+rsstsigw*revd(i, j, k))
          muep = half*(rsstsigwp1*temp+rsstsigw*rev(i, j, k))
          c2md = ttm*rhoi*(mulmd+muemd) + (mulm+muem)*(rhoi*ttmd+ttm*&
&           rhoid)
          c2m = ttm*(mulm+muem)*rhoi
          c2pd = ttp*rhoi*(mulpd+muepd) + (mulp+muep)*(rhoi*ttpd+ttp*&
&           rhoid)
          c2p = ttp*(mulp+muep)*rhoi
          c20d = c2md + c2pd
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          temp = w(i, j, k-1, itu1)
          temp0 = w(i, j, k+1, itu1)
          temp1 = w(i, j, k, itu1)
          scratchd(i, j, k, idvt) = scratchd(i, j, k, idvt) + temp*c1md &
&           + c1m*wd(i, j, k-1, itu1) + temp0*c1pd + c1p*wd(i, j, k+1, &
&           itu1) - temp1*c10d - c10*wd(i, j, k, itu1)
          scratch(i, j, k, idvt) = scratch(i, j, k, idvt) + c1m*temp + &
&           c1p*temp0 - c10*temp1
          temp1 = w(i, j, k-1, itu2)
          temp0 = w(i, j, k+1, itu2)
          temp = w(i, j, k, itu2)
          scratchd(i, j, k, idvt+1) = scratchd(i, j, k, idvt+1) + temp1*&
&           c2md + c2m*wd(i, j, k-1, itu2) + temp0*c2pd + c2p*wd(i, j, k&
&           +1, itu2) - temp*c20d - c20*wd(i, j, k, itu2)
          scratch(i, j, k, idvt+1) = scratch(i, j, k, idvt+1) + c2m*&
&           temp1 + c2p*temp0 - c20*temp
        end do
      end do
    end do
!
!       viscous terms in j-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in eta-direction, i.e. along the
! line j = constant.
          temp1 = one/vol(i, j, k)
          volid = -(temp1*vold(i, j, k)/vol(i, j, k))
          voli = temp1
          temp1 = two/(vol(i, j, k)+vol(i, j-1, k))
          volmid = -(temp1*(vold(i, j, k)+vold(i, j-1, k))/(vol(i, j, k)&
&           +vol(i, j-1, k)))
          volmi = temp1
          temp1 = two/(vol(i, j, k)+vol(i, j+1, k))
          volpid = -(temp1*(vold(i, j, k)+vold(i, j+1, k))/(vol(i, j, k)&
&           +vol(i, j+1, k)))
          volpi = temp1
          temp1 = sj(i, j-1, k, 1)
          xmd = volmi*sjd(i, j-1, k, 1) + temp1*volmid
          xm = temp1*volmi
          temp1 = sj(i, j-1, k, 2)
          ymd = volmi*sjd(i, j-1, k, 2) + temp1*volmid
          ym = temp1*volmi
          temp1 = sj(i, j-1, k, 3)
          zmd = volmi*sjd(i, j-1, k, 3) + temp1*volmid
          zm = temp1*volmi
          temp1 = sj(i, j, k, 1)
          xpd = volpi*sjd(i, j, k, 1) + temp1*volpid
          xp = temp1*volpi
          temp1 = sj(i, j, k, 2)
          ypd = volpi*sjd(i, j, k, 2) + temp1*volpid
          yp = temp1*volpi
          temp1 = sj(i, j, k, 3)
          zpd = volpi*sjd(i, j, k, 3) + temp1*volpid
          zp = temp1*volpi
          temp1 = sj(i, j, k, 1) + sj(i, j-1, k, 1)
          xad = half*(voli*(sjd(i, j, k, 1)+sjd(i, j-1, k, 1))+temp1*&
&           volid)
          xa = half*(temp1*voli)
          temp1 = sj(i, j, k, 2) + sj(i, j-1, k, 2)
          yad = half*(voli*(sjd(i, j, k, 2)+sjd(i, j-1, k, 2))+temp1*&
&           volid)
          ya = half*(temp1*voli)
          temp1 = sj(i, j, k, 3) + sj(i, j-1, k, 3)
          zad = half*(voli*(sjd(i, j, k, 3)+sjd(i, j-1, k, 3))+temp1*&
&           volid)
          za = half*(temp1*voli)
          ttmd = xa*xmd + xm*xad + ya*ymd + ym*yad + za*zmd + zm*zad
          ttm = xm*xa + ym*ya + zm*za
          ttpd = xa*xpd + xp*xad + ya*ypd + yp*yad + za*zpd + zp*zad
          ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for j-1,
! j and j+1.
          t1d = scratchd(i, j+1, k, if1sst)
          t1 = scratch(i, j+1, k, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstsigkp1d = rsstsigk1*t1d + rsstsigk2*t2d
          rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwp1d = rsstsigw1*t1d + rsstsigw2*t2d
          rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
          t1d = scratchd(i, j, k, if1sst)
          t1 = scratch(i, j, k, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstsigkd = rsstsigk1*t1d + rsstsigk2*t2d
          rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwd = rsstsigw1*t1d + rsstsigw2*t2d
          rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
          t1d = scratchd(i, j-1, k, if1sst)
          t1 = scratch(i, j-1, k, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstsigkm1d = rsstsigk1*t1d + rsstsigk2*t2d
          rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwm1d = rsstsigw1*t1d + rsstsigw2*t2d
          rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in eta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in eta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/deta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
          temp1 = one/w(i, j, k, irho)
          rhoid = -(temp1*wd(i, j, k, irho)/w(i, j, k, irho))
          rhoi = temp1
          mulmd = half*(rlvd(i, j-1, k)+rlvd(i, j, k))
          mulm = half*(rlv(i, j-1, k)+rlv(i, j, k))
          mulpd = half*(rlvd(i, j+1, k)+rlvd(i, j, k))
          mulp = half*(rlv(i, j+1, k)+rlv(i, j, k))
          temp1 = rev(i, j-1, k)
          muemd = half*(temp1*rsstsigkm1d+rsstsigkm1*revd(i, j-1, k)+rev&
&           (i, j, k)*rsstsigkd+rsstsigk*revd(i, j, k))
          muem = half*(rsstsigkm1*temp1+rsstsigk*rev(i, j, k))
          temp1 = rev(i, j+1, k)
          muepd = half*(temp1*rsstsigkp1d+rsstsigkp1*revd(i, j+1, k)+rev&
&           (i, j, k)*rsstsigkd+rsstsigk*revd(i, j, k))
          muep = half*(rsstsigkp1*temp1+rsstsigk*rev(i, j, k))
          c1md = ttm*rhoi*(mulmd+muemd) + (mulm+muem)*(rhoi*ttmd+ttm*&
&           rhoid)
          c1m = ttm*(mulm+muem)*rhoi
          c1pd = ttp*rhoi*(mulpd+muepd) + (mulp+muep)*(rhoi*ttpd+ttp*&
&           rhoid)
          c1p = ttp*(mulp+muep)*rhoi
          c10d = c1md + c1pd
          c10 = c1m + c1p
! and the omega term.
          temp1 = rev(i, j-1, k)
          muemd = half*(temp1*rsstsigwm1d+rsstsigwm1*revd(i, j-1, k)+rev&
&           (i, j, k)*rsstsigwd+rsstsigw*revd(i, j, k))
          muem = half*(rsstsigwm1*temp1+rsstsigw*rev(i, j, k))
          temp1 = rev(i, j+1, k)
          muepd = half*(temp1*rsstsigwp1d+rsstsigwp1*revd(i, j+1, k)+rev&
&           (i, j, k)*rsstsigwd+rsstsigw*revd(i, j, k))
          muep = half*(rsstsigwp1*temp1+rsstsigw*rev(i, j, k))
          c2md = ttm*rhoi*(mulmd+muemd) + (mulm+muem)*(rhoi*ttmd+ttm*&
&           rhoid)
          c2m = ttm*(mulm+muem)*rhoi
          c2pd = ttp*rhoi*(mulpd+muepd) + (mulp+muep)*(rhoi*ttpd+ttp*&
&           rhoid)
          c2p = ttp*(mulp+muep)*rhoi
          c20d = c2md + c2pd
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          temp1 = w(i, j-1, k, itu1)
          temp0 = w(i, j+1, k, itu1)
          temp = w(i, j, k, itu1)
          scratchd(i, j, k, idvt) = scratchd(i, j, k, idvt) + temp1*c1md&
&           + c1m*wd(i, j-1, k, itu1) + temp0*c1pd + c1p*wd(i, j+1, k, &
&           itu1) - temp*c10d - c10*wd(i, j, k, itu1)
          scratch(i, j, k, idvt) = scratch(i, j, k, idvt) + c1m*temp1 + &
&           c1p*temp0 - c10*temp
          temp1 = w(i, j-1, k, itu2)
          temp0 = w(i, j+1, k, itu2)
          temp = w(i, j, k, itu2)
          scratchd(i, j, k, idvt+1) = scratchd(i, j, k, idvt+1) + temp1*&
&           c2md + c2m*wd(i, j-1, k, itu2) + temp0*c2pd + c2p*wd(i, j+1&
&           , k, itu2) - temp*c20d - c20*wd(i, j, k, itu2)
          scratch(i, j, k, idvt+1) = scratch(i, j, k, idvt+1) + c2m*&
&           temp1 + c2p*temp0 - c20*temp
        end do
      end do
    end do
!
!       viscous terms in i-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in xi-direction, i.e. along the
! line i = constant.
          temp1 = one/vol(i, j, k)
          volid = -(temp1*vold(i, j, k)/vol(i, j, k))
          voli = temp1
          temp1 = two/(vol(i, j, k)+vol(i-1, j, k))
          volmid = -(temp1*(vold(i, j, k)+vold(i-1, j, k))/(vol(i, j, k)&
&           +vol(i-1, j, k)))
          volmi = temp1
          temp1 = two/(vol(i, j, k)+vol(i+1, j, k))
          volpid = -(temp1*(vold(i, j, k)+vold(i+1, j, k))/(vol(i, j, k)&
&           +vol(i+1, j, k)))
          volpi = temp1
          temp1 = si(i-1, j, k, 1)
          xmd = volmi*sid(i-1, j, k, 1) + temp1*volmid
          xm = temp1*volmi
          temp1 = si(i-1, j, k, 2)
          ymd = volmi*sid(i-1, j, k, 2) + temp1*volmid
          ym = temp1*volmi
          temp1 = si(i-1, j, k, 3)
          zmd = volmi*sid(i-1, j, k, 3) + temp1*volmid
          zm = temp1*volmi
          temp1 = si(i, j, k, 1)
          xpd = volpi*sid(i, j, k, 1) + temp1*volpid
          xp = temp1*volpi
          temp1 = si(i, j, k, 2)
          ypd = volpi*sid(i, j, k, 2) + temp1*volpid
          yp = temp1*volpi
          temp1 = si(i, j, k, 3)
          zpd = volpi*sid(i, j, k, 3) + temp1*volpid
          zp = temp1*volpi
          temp1 = si(i, j, k, 1) + si(i-1, j, k, 1)
          xad = half*(voli*(sid(i, j, k, 1)+sid(i-1, j, k, 1))+temp1*&
&           volid)
          xa = half*(temp1*voli)
          temp1 = si(i, j, k, 2) + si(i-1, j, k, 2)
          yad = half*(voli*(sid(i, j, k, 2)+sid(i-1, j, k, 2))+temp1*&
&           volid)
          ya = half*(temp1*voli)
          temp1 = si(i, j, k, 3) + si(i-1, j, k, 3)
          zad = half*(voli*(sid(i, j, k, 3)+sid(i-1, j, k, 3))+temp1*&
&           volid)
          za = half*(temp1*voli)
          ttmd = xa*xmd + xm*xad + ya*ymd + ym*yad + za*zmd + zm*zad
          ttm = xm*xa + ym*ya + zm*za
          ttpd = xa*xpd + xp*xad + ya*ypd + yp*yad + za*zpd + zp*zad
          ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for i-1,
! i and i+1.
          t1d = scratchd(i+1, j, k, if1sst)
          t1 = scratch(i+1, j, k, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstsigkp1d = rsstsigk1*t1d + rsstsigk2*t2d
          rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwp1d = rsstsigw1*t1d + rsstsigw2*t2d
          rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
          t1d = scratchd(i, j, k, if1sst)
          t1 = scratch(i, j, k, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstsigkd = rsstsigk1*t1d + rsstsigk2*t2d
          rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwd = rsstsigw1*t1d + rsstsigw2*t2d
          rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
          t1d = scratchd(i-1, j, k, if1sst)
          t1 = scratch(i-1, j, k, if1sst)
          t2d = -t1d
          t2 = one - t1
          rsstsigkm1d = rsstsigk1*t1d + rsstsigk2*t2d
          rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwm1d = rsstsigw1*t1d + rsstsigw2*t2d
          rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in xi-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in xi-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dxi derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
          temp1 = one/w(i, j, k, irho)
          rhoid = -(temp1*wd(i, j, k, irho)/w(i, j, k, irho))
          rhoi = temp1
          mulmd = half*(rlvd(i-1, j, k)+rlvd(i, j, k))
          mulm = half*(rlv(i-1, j, k)+rlv(i, j, k))
          mulpd = half*(rlvd(i+1, j, k)+rlvd(i, j, k))
          mulp = half*(rlv(i+1, j, k)+rlv(i, j, k))
          temp1 = rev(i-1, j, k)
          muemd = half*(temp1*rsstsigkm1d+rsstsigkm1*revd(i-1, j, k)+rev&
&           (i, j, k)*rsstsigkd+rsstsigk*revd(i, j, k))
          muem = half*(rsstsigkm1*temp1+rsstsigk*rev(i, j, k))
          temp1 = rev(i+1, j, k)
          muepd = half*(temp1*rsstsigkp1d+rsstsigkp1*revd(i+1, j, k)+rev&
&           (i, j, k)*rsstsigkd+rsstsigk*revd(i, j, k))
          muep = half*(rsstsigkp1*temp1+rsstsigk*rev(i, j, k))
          c1md = ttm*rhoi*(mulmd+muemd) + (mulm+muem)*(rhoi*ttmd+ttm*&
&           rhoid)
          c1m = ttm*(mulm+muem)*rhoi
          c1pd = ttp*rhoi*(mulpd+muepd) + (mulp+muep)*(rhoi*ttpd+ttp*&
&           rhoid)
          c1p = ttp*(mulp+muep)*rhoi
          c10d = c1md + c1pd
          c10 = c1m + c1p
! and the omega term.
          temp1 = rev(i-1, j, k)
          muemd = half*(temp1*rsstsigwm1d+rsstsigwm1*revd(i-1, j, k)+rev&
&           (i, j, k)*rsstsigwd+rsstsigw*revd(i, j, k))
          muem = half*(rsstsigwm1*temp1+rsstsigw*rev(i, j, k))
          temp1 = rev(i+1, j, k)
          muepd = half*(temp1*rsstsigwp1d+rsstsigwp1*revd(i+1, j, k)+rev&
&           (i, j, k)*rsstsigwd+rsstsigw*revd(i, j, k))
          muep = half*(rsstsigwp1*temp1+rsstsigw*rev(i, j, k))
          c2md = ttm*rhoi*(mulmd+muemd) + (mulm+muem)*(rhoi*ttmd+ttm*&
&           rhoid)
          c2m = ttm*(mulm+muem)*rhoi
          c2pd = ttp*rhoi*(mulpd+muepd) + (mulp+muep)*(rhoi*ttpd+ttp*&
&           rhoid)
          c2p = ttp*(mulp+muep)*rhoi
          c20d = c2md + c2pd
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          temp1 = w(i-1, j, k, itu1)
          temp0 = w(i+1, j, k, itu1)
          temp = w(i, j, k, itu1)
          scratchd(i, j, k, idvt) = scratchd(i, j, k, idvt) + temp1*c1md&
&           + c1m*wd(i-1, j, k, itu1) + temp0*c1pd + c1p*wd(i+1, j, k, &
&           itu1) - temp*c10d - c10*wd(i, j, k, itu1)
          scratch(i, j, k, idvt) = scratch(i, j, k, idvt) + c1m*temp1 + &
&           c1p*temp0 - c10*temp
          temp1 = w(i-1, j, k, itu2)
          temp0 = w(i+1, j, k, itu2)
          temp = w(i, j, k, itu2)
          scratchd(i, j, k, idvt+1) = scratchd(i, j, k, idvt+1) + temp1*&
&           c2md + c2m*wd(i-1, j, k, itu2) + temp0*c2pd + c2p*wd(i+1, j&
&           , k, itu2) - temp*c20d - c20*wd(i, j, k, itu2)
          scratch(i, j, k, idvt+1) = scratch(i, j, k, idvt+1) + c2m*&
&           temp1 + c2p*temp0 - c20*temp
        end do
      end do
    end do
  end subroutine sstviscous_d

  subroutine sstviscous()
    use blockpointers
    use constants
    use paramturb
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: t1, t2
    real(kind=realtype) :: rhoi
    real(kind=realtype) :: voli, volmi, volpi
    real(kind=realtype) :: xm, ym, zm, xp, yp, zp, xa, ya, za
    real(kind=realtype) :: mulm, mulp, muem, muep
    real(kind=realtype) :: ttm, ttp
    real(kind=realtype) :: rsstsigkp1, rsstsigk, rsstsigkm1
    real(kind=realtype) :: rsstsigwp1, rsstsigw, rsstsigwm1
    real(kind=realtype) :: c1m, c1p, c10, c2m, c2p, c20
    real(kind=realtype) :: b1, b2, c1, c2, d1, d2
    real(kind=realtype) :: rblank
!       advection and unsteady terms.
!
!
!       viscous terms in k-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in zeta-direction, i.e. along the
! line k = constant.
          voli = one/vol(i, j, k)
          volmi = two/(vol(i, j, k)+vol(i, j, k-1))
          volpi = two/(vol(i, j, k)+vol(i, j, k+1))
          xm = sk(i, j, k-1, 1)*volmi
          ym = sk(i, j, k-1, 2)*volmi
          zm = sk(i, j, k-1, 3)*volmi
          xp = sk(i, j, k, 1)*volpi
          yp = sk(i, j, k, 2)*volpi
          zp = sk(i, j, k, 3)*volpi
          xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
          ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
          za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
          ttm = xm*xa + ym*ya + zm*za
          ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for k-1,
! k and k+1.
! caution: f1 must be known in neighbouring cells (including halos!)
          t1 = scratch(i, j, k+1, if1sst)
          t2 = one - t1
          rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
          t1 = scratch(i, j, k, if1sst)
          t2 = one - t1
          rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
          t1 = scratch(i, j, k-1, if1sst)
          t2 = one - t1
          rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in zeta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in zeta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dzeta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
          rhoi = one/w(i, j, k, irho)
          mulm = half*(rlv(i, j, k-1)+rlv(i, j, k))
          mulp = half*(rlv(i, j, k+1)+rlv(i, j, k))
          muem = half*(rsstsigkm1*rev(i, j, k-1)+rsstsigk*rev(i, j, k))
          muep = half*(rsstsigkp1*rev(i, j, k+1)+rsstsigk*rev(i, j, k))
          c1m = ttm*(mulm+muem)*rhoi
          c1p = ttp*(mulp+muep)*rhoi
          c10 = c1m + c1p
! and the omega term.
          muem = half*(rsstsigwm1*rev(i, j, k-1)+rsstsigw*rev(i, j, k))
          muep = half*(rsstsigwp1*rev(i, j, k+1)+rsstsigw*rev(i, j, k))
          c2m = ttm*(mulm+muem)*rhoi
          c2p = ttp*(mulp+muep)*rhoi
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          scratch(i, j, k, idvt) = scratch(i, j, k, idvt) + c1m*w(i, j, &
&           k-1, itu1) - c10*w(i, j, k, itu1) + c1p*w(i, j, k+1, itu1)
          scratch(i, j, k, idvt+1) = scratch(i, j, k, idvt+1) + c2m*w(i&
&           , j, k-1, itu2) - c20*w(i, j, k, itu2) + c2p*w(i, j, k+1, &
&           itu2)
        end do
      end do
    end do
!
!       viscous terms in j-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in eta-direction, i.e. along the
! line j = constant.
          voli = one/vol(i, j, k)
          volmi = two/(vol(i, j, k)+vol(i, j-1, k))
          volpi = two/(vol(i, j, k)+vol(i, j+1, k))
          xm = sj(i, j-1, k, 1)*volmi
          ym = sj(i, j-1, k, 2)*volmi
          zm = sj(i, j-1, k, 3)*volmi
          xp = sj(i, j, k, 1)*volpi
          yp = sj(i, j, k, 2)*volpi
          zp = sj(i, j, k, 3)*volpi
          xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
          ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
          za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
          ttm = xm*xa + ym*ya + zm*za
          ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for j-1,
! j and j+1.
          t1 = scratch(i, j+1, k, if1sst)
          t2 = one - t1
          rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
          t1 = scratch(i, j, k, if1sst)
          t2 = one - t1
          rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
          t1 = scratch(i, j-1, k, if1sst)
          t2 = one - t1
          rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in eta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in eta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/deta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
          rhoi = one/w(i, j, k, irho)
          mulm = half*(rlv(i, j-1, k)+rlv(i, j, k))
          mulp = half*(rlv(i, j+1, k)+rlv(i, j, k))
          muem = half*(rsstsigkm1*rev(i, j-1, k)+rsstsigk*rev(i, j, k))
          muep = half*(rsstsigkp1*rev(i, j+1, k)+rsstsigk*rev(i, j, k))
          c1m = ttm*(mulm+muem)*rhoi
          c1p = ttp*(mulp+muep)*rhoi
          c10 = c1m + c1p
! and the omega term.
          muem = half*(rsstsigwm1*rev(i, j-1, k)+rsstsigw*rev(i, j, k))
          muep = half*(rsstsigwp1*rev(i, j+1, k)+rsstsigw*rev(i, j, k))
          c2m = ttm*(mulm+muem)*rhoi
          c2p = ttp*(mulp+muep)*rhoi
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          scratch(i, j, k, idvt) = scratch(i, j, k, idvt) + c1m*w(i, j-1&
&           , k, itu1) - c10*w(i, j, k, itu1) + c1p*w(i, j+1, k, itu1)
          scratch(i, j, k, idvt+1) = scratch(i, j, k, idvt+1) + c2m*w(i&
&           , j-1, k, itu2) - c20*w(i, j, k, itu2) + c2p*w(i, j+1, k, &
&           itu2)
        end do
      end do
    end do
!
!       viscous terms in i-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in xi-direction, i.e. along the
! line i = constant.
          voli = one/vol(i, j, k)
          volmi = two/(vol(i, j, k)+vol(i-1, j, k))
          volpi = two/(vol(i, j, k)+vol(i+1, j, k))
          xm = si(i-1, j, k, 1)*volmi
          ym = si(i-1, j, k, 2)*volmi
          zm = si(i-1, j, k, 3)*volmi
          xp = si(i, j, k, 1)*volpi
          yp = si(i, j, k, 2)*volpi
          zp = si(i, j, k, 3)*volpi
          xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
          ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
          za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
          ttm = xm*xa + ym*ya + zm*za
          ttp = xp*xa + yp*ya + zp*za
! compute the blended diffusion coefficients for i-1,
! i and i+1.
          t1 = scratch(i+1, j, k, if1sst)
          t2 = one - t1
          rsstsigkp1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwp1 = t1*rsstsigw1 + t2*rsstsigw2
          t1 = scratch(i, j, k, if1sst)
          t2 = one - t1
          rsstsigk = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigw = t1*rsstsigw1 + t2*rsstsigw2
          t1 = scratch(i-1, j, k, if1sst)
          t2 = one - t1
          rsstsigkm1 = t1*rsstsigk1 + t2*rsstsigk2
          rsstsigwm1 = t1*rsstsigw1 + t2*rsstsigw2
! computation of the viscous terms in xi-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in xi-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dxi derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the k-term.
          rhoi = one/w(i, j, k, irho)
          mulm = half*(rlv(i-1, j, k)+rlv(i, j, k))
          mulp = half*(rlv(i+1, j, k)+rlv(i, j, k))
          muem = half*(rsstsigkm1*rev(i-1, j, k)+rsstsigk*rev(i, j, k))
          muep = half*(rsstsigkp1*rev(i+1, j, k)+rsstsigk*rev(i, j, k))
          c1m = ttm*(mulm+muem)*rhoi
          c1p = ttp*(mulp+muep)*rhoi
          c10 = c1m + c1p
! and the omega term.
          muem = half*(rsstsigwm1*rev(i-1, j, k)+rsstsigw*rev(i, j, k))
          muep = half*(rsstsigwp1*rev(i+1, j, k)+rsstsigw*rev(i, j, k))
          c2m = ttm*(mulm+muem)*rhoi
          c2p = ttp*(mulp+muep)*rhoi
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          scratch(i, j, k, idvt) = scratch(i, j, k, idvt) + c1m*w(i-1, j&
&           , k, itu1) - c10*w(i, j, k, itu1) + c1p*w(i+1, j, k, itu1)
          scratch(i, j, k, idvt+1) = scratch(i, j, k, idvt+1) + c2m*w(i-&
&           1, j, k, itu2) - c20*w(i, j, k, itu2) + c2p*w(i+1, j, k, &
&           itu2)
        end do
      end do
    end do
  end subroutine sstviscous

!  differentiation of sstresscale in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *dw
!   with respect to varying inputs: *dw *scratch
!   rw status of diff variables: *dw:in-out *scratch:in
!   plus diff mem management of: dw:in scratch:in
  subroutine sstresscale_d()
    use blockpointers
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rblank
    intrinsic real
    real(kind=realtype) :: temp
! multiply the residual by the volume and store this in dw; this
! is done for monitoring reasons only. the multiplication with the
! volume is present to be consistent with the flow residuals; also
! the negative value is taken, again to be consistent with the
! flow equations. also multiply by iblank so that no updates occur
! in holes or the overset boundary.
    do k=2,kl
      do j=2,jl
        do i=2,il
          rblank = real(iblank(i, j, k), realtype)
          temp = volref(i, j, k)*rblank
          dwd(i, j, k, itu1) = -(temp*scratchd(i, j, k, idvt))
          dw(i, j, k, itu1) = -(temp*scratch(i, j, k, idvt))
          temp = volref(i, j, k)*rblank
          dwd(i, j, k, itu2) = -(temp*scratchd(i, j, k, idvt+1))
          dw(i, j, k, itu2) = -(temp*scratch(i, j, k, idvt+1))
        end do
      end do
    end do
  end subroutine sstresscale_d

  subroutine sstresscale()
    use blockpointers
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rblank
    intrinsic real
! multiply the residual by the volume and store this in dw; this
! is done for monitoring reasons only. the multiplication with the
! volume is present to be consistent with the flow residuals; also
! the negative value is taken, again to be consistent with the
! flow equations. also multiply by iblank so that no updates occur
! in holes or the overset boundary.
    do k=2,kl
      do j=2,jl
        do i=2,il
          rblank = real(iblank(i, j, k), realtype)
          dw(i, j, k, itu1) = -(volref(i, j, k)*scratch(i, j, k, idvt)*&
&           rblank)
          dw(i, j, k, itu2) = -(volref(i, j, k)*scratch(i, j, k, idvt+1)&
&           *rblank)
        end do
      end do
    end do
  end subroutine sstresscale

!  differentiation of f1sst in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *scratch
!   with respect to varying inputs: *w *rlv *scratch *d2wall
!   rw status of diff variables: *w:in *rlv:in *scratch:in-out
!                *d2wall:in
!   plus diff mem management of: w:in rlv:in scratch:in d2wall:in
  subroutine f1sst_d()
!
!       f1sst computes the blending function f1 in both the owned
!       cells and the first layer of halo's. the result is stored in
!       scratch(:,:,:,if1sst). for the computation of f1 also the cross
!       diffusion term is needed. this is stored in scratch(:,:,:,icd) such
!       that it can be used in sstsolve later on.
!
    use constants
    use blockpointers
    use inputtimespectral
    use iteration
    use paramturb, only : rsstsigw2
    use inputphysics, only : use2003sst, transitionmodel
    use utils_d, only : smoothmin, smoothmin_d, smoothmax, smoothmax_d
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: sps, nn, mm, i, j, k, ii
    integer(kind=inttype) :: isize, ibeg, iend
    integer(kind=inttype) :: jsize, jbeg, jend
    integer(kind=inttype) :: ksize, kbeg, kend
    real(kind=realtype) :: t1, t2, arg1, myeps, f1, f3, ry, phi1, phi2
    real(kind=realtype) :: t1d, t2d, arg1d
    intrinsic sqrt
    intrinsic max
    intrinsic tanh
    intrinsic exp
    real(kind=realtype) :: max1
    real(kind=realtype) :: max1d
    real(kind=realtype) :: max2
    real(kind=realtype) :: max2d
    real(kind=realtype) :: result1
    real(kind=realtype) :: result1d
    real(kind=realtype) :: arg10
    real(kind=realtype) :: arg10d
    real(kind=realtype) :: temp
    real(kind=realtype) :: temp0
    real(realtype) :: temp1
    real(kind=realtype) :: temp2
    real(kind=realtype) :: temp3
    real(kind=realtype) :: temp4
    real(kind=realtype) :: temp5
! control value for smooth min/max functions. needs to be declared in advance because of 'complexify'
    phi1 = 1.0e3_realtype
    phi2 = 1.0e4_realtype
    myeps = 1e-10_realtype/two/rsstsigw2
    ibeg = 1
    jbeg = 1
    kbeg = 1
    iend = ie
    jend = je
    kend = ke
    do nn=1,nbocos
      select case  (bcfaceid(nn)) 
      case (imin) 
        ibeg = 2
      case (imax) 
        iend = il
      case (jmin) 
        jbeg = 2
      case (jmax) 
        jend = jl
      case (kmin) 
        kbeg = 2
      case (kmax) 
        kend = kl
      end select
    end do
! compute the blending function f1 for all owned cells.
    do k=kbeg,kend
      do j=jbeg,jend
        do i=ibeg,iend
! if the turbulent kinetic energy falls below 0, this sqrt produces a nan. this presumably only happens if
! the dadi (for turbulence) solver is used. the ank solver should check and prevent this. since t1 is later
! max-ed with t2, we just set it to 0 if the turbulent kinetic energy is below 0
          if (w(i, j, k, itu1) .gt. 0) then
            temp = w(i, j, k, itu1)
            temp0 = sqrt(temp)
            if (temp .eq. 0.0_8) then
              result1d = 0.0_8
            else
              result1d = wd(i, j, k, itu1)/(2.0*temp0)
            end if
            result1 = temp0
            temp1 = 0.09_realtype*d2wall(i, j, k)
            temp0 = w(i, j, k, itu2)
            temp = temp0*temp1
            t1d = (result1d-result1*(temp1*wd(i, j, k, itu2)+temp0*&
&             0.09_realtype*d2walld(i, j, k))/temp)/temp
            t1 = result1/temp
          else
            t1 = 0_realtype
            t1d = 0.0_8
          end if
          temp0 = d2wall(i, j, k)
          temp = w(i, j, k, itu2)
          temp2 = w(i, j, k, irho)
          temp3 = temp2*temp
          temp4 = temp3*(temp0*temp0)
          temp5 = rlv(i, j, k)/temp4
          t2d = 500.0_realtype*(rlvd(i, j, k)-temp5*(temp0**2*(temp*wd(i&
&           , j, k, irho)+temp2*wd(i, j, k, itu2))+temp3*2*temp0*d2walld&
&           (i, j, k)))/temp4
          t2 = 500.0_realtype*temp5
! 1e3
          call smoothmax_d(t1, t1d, t1, t1d, t2, t2d, phi1)
          if (use2003sst) then
            if (myeps/w(i, j, k, irho) .lt. scratch(i, j, k, icd)) then
              max1d = scratchd(i, j, k, icd)
              max1 = scratch(i, j, k, icd)
            else
              temp5 = myeps/w(i, j, k, irho)
              max1d = -(temp5*wd(i, j, k, irho)/w(i, j, k, irho))
              max1 = temp5
            end if
            temp5 = d2wall(i, j, k)*d2wall(i, j, k)
            temp4 = w(i, j, k, itu1)/(max1*temp5)
            t2d = two*(wd(i, j, k, itu1)-temp4*(temp5*max1d+max1*2*&
&             d2wall(i, j, k)*d2walld(i, j, k)))/(max1*temp5)
            t2 = two*temp4
          else
            if (eps .lt. scratch(i, j, k, icd)) then
              max2d = scratchd(i, j, k, icd)
              max2 = scratch(i, j, k, icd)
            else
              max2 = eps
              max2d = 0.0_8
            end if
            temp5 = d2wall(i, j, k)*d2wall(i, j, k)
            temp4 = w(i, j, k, itu1)/(max2*temp5)
            t2d = two*(wd(i, j, k, itu1)-temp4*(temp5*max2d+max2*2*&
&             d2wall(i, j, k)*d2walld(i, j, k)))/(max2*temp5)
            t2 = two*temp4
          end if
! 1e4
          arg1d = 0.0_8
          call smoothmin_d(arg1, arg1d, t1, t1d, t2, t2d, phi2)
          arg10 = arg1**4
          f1 = tanh(arg10)
          if (transitionmodel .eq. gammaretheta) then
            result1 = sqrt(w(i, j, k, itu1))
            ry = w(i, j, k, irho)*d2wall(i, j, k)*result1/rlv(i, j, k)
            arg10 = -((ry/120.0)**8)
            f3 = exp(arg10)
            if (f1 .lt. f3) then
              f1 = f3
            else
              f1 = f1
            end if
          end if
          arg10d = 4*arg1**3*arg1d
          arg10 = arg1**4
          scratchd(i, j, k, if1sst) = (1.0-tanh(arg10)**2)*arg10d
          scratch(i, j, k, if1sst) = tanh(arg10)
        end do
      end do
    end do
! loop over the boundary conditions to set f1 in the boundary
! halo's. a neumann boundary condition is used for all bc's.
bocos:do nn=1,nbocos
! determine the face on which this subface is located, loop
! over its range and copy f1. although the range may include
! indirect halo's which are not computed, this is no problem,
! because in sstsolve only direct halo's are used.
      select case  (bcfaceid(nn)) 
      case (imin) 
        do k=kcbeg(nn),kcend(nn)
          do j=jcbeg(nn),jcend(nn)
            scratchd(1, j, k, if1sst) = scratchd(2, j, k, if1sst)
            scratch(1, j, k, if1sst) = scratch(2, j, k, if1sst)
          end do
        end do
      case (imax) 
!              ==========================================================
        do k=kcbeg(nn),kcend(nn)
          do j=jcbeg(nn),jcend(nn)
            scratchd(ie, j, k, if1sst) = scratchd(il, j, k, if1sst)
            scratch(ie, j, k, if1sst) = scratch(il, j, k, if1sst)
          end do
        end do
      case (jmin) 
!              ==========================================================
        do k=kcbeg(nn),kcend(nn)
          do i=icbeg(nn),icend(nn)
            scratchd(i, 1, k, if1sst) = scratchd(i, 2, k, if1sst)
            scratch(i, 1, k, if1sst) = scratch(i, 2, k, if1sst)
          end do
        end do
      case (jmax) 
!              ==========================================================
        do k=kcbeg(nn),kcend(nn)
          do i=icbeg(nn),icend(nn)
            scratchd(i, je, k, if1sst) = scratchd(i, jl, k, if1sst)
            scratch(i, je, k, if1sst) = scratch(i, jl, k, if1sst)
          end do
        end do
      case (kmin) 
!              ==========================================================
        do j=jcbeg(nn),jcend(nn)
          do i=icbeg(nn),icend(nn)
            scratchd(i, j, 1, if1sst) = scratchd(i, j, 2, if1sst)
            scratch(i, j, 1, if1sst) = scratch(i, j, 2, if1sst)
          end do
        end do
      case (kmax) 
!              ==========================================================
        do j=jcbeg(nn),jcend(nn)
          do i=icbeg(nn),icend(nn)
            scratchd(i, j, ke, if1sst) = scratchd(i, j, kl, if1sst)
            scratch(i, j, ke, if1sst) = scratch(i, j, kl, if1sst)
          end do
        end do
      end select
    end do bocos
  end subroutine f1sst_d

  subroutine f1sst()
!
!       f1sst computes the blending function f1 in both the owned
!       cells and the first layer of halo's. the result is stored in
!       scratch(:,:,:,if1sst). for the computation of f1 also the cross
!       diffusion term is needed. this is stored in scratch(:,:,:,icd) such
!       that it can be used in sstsolve later on.
!
    use constants
    use blockpointers
    use inputtimespectral
    use iteration
    use paramturb, only : rsstsigw2
    use inputphysics, only : use2003sst, transitionmodel
    use utils_d, only : smoothmin, smoothmax
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: sps, nn, mm, i, j, k, ii
    integer(kind=inttype) :: isize, ibeg, iend
    integer(kind=inttype) :: jsize, jbeg, jend
    integer(kind=inttype) :: ksize, kbeg, kend
    real(kind=realtype) :: t1, t2, arg1, myeps, f1, f3, ry, phi1, phi2
    intrinsic sqrt
    intrinsic max
    intrinsic tanh
    intrinsic exp
    real(kind=realtype) :: max1
    real(kind=realtype) :: max2
    real(kind=realtype) :: result1
    real(kind=realtype) :: arg10
! control value for smooth min/max functions. needs to be declared in advance because of 'complexify'
    phi1 = 1.0e3_realtype
    phi2 = 1.0e4_realtype
    myeps = 1e-10_realtype/two/rsstsigw2
    ibeg = 1
    jbeg = 1
    kbeg = 1
    iend = ie
    jend = je
    kend = ke
    do nn=1,nbocos
      select case  (bcfaceid(nn)) 
      case (imin) 
        ibeg = 2
      case (imax) 
        iend = il
      case (jmin) 
        jbeg = 2
      case (jmax) 
        jend = jl
      case (kmin) 
        kbeg = 2
      case (kmax) 
        kend = kl
      end select
    end do
! compute the blending function f1 for all owned cells.
    do k=kbeg,kend
      do j=jbeg,jend
        do i=ibeg,iend
! if the turbulent kinetic energy falls below 0, this sqrt produces a nan. this presumably only happens if
! the dadi (for turbulence) solver is used. the ank solver should check and prevent this. since t1 is later
! max-ed with t2, we just set it to 0 if the turbulent kinetic energy is below 0
          if (w(i, j, k, itu1) .gt. 0) then
            result1 = sqrt(w(i, j, k, itu1))
            t1 = result1/(0.09_realtype*w(i, j, k, itu2)*d2wall(i, j, k)&
&             )
          else
            t1 = 0_realtype
          end if
          t2 = 500.0_realtype*rlv(i, j, k)/(w(i, j, k, irho)*w(i, j, k, &
&           itu2)*d2wall(i, j, k)**2)
! 1e3
          call smoothmax(t1, t1, t2, phi1)
          if (use2003sst) then
            if (myeps/w(i, j, k, irho) .lt. scratch(i, j, k, icd)) then
              max1 = scratch(i, j, k, icd)
            else
              max1 = myeps/w(i, j, k, irho)
            end if
            t2 = two*w(i, j, k, itu1)/(max1*d2wall(i, j, k)**2)
          else
            if (eps .lt. scratch(i, j, k, icd)) then
              max2 = scratch(i, j, k, icd)
            else
              max2 = eps
            end if
            t2 = two*w(i, j, k, itu1)/(max2*d2wall(i, j, k)**2)
          end if
! 1e4
          call smoothmin(arg1, t1, t2, phi2)
          arg10 = arg1**4
          f1 = tanh(arg10)
          if (transitionmodel .eq. gammaretheta) then
            result1 = sqrt(w(i, j, k, itu1))
            ry = w(i, j, k, irho)*d2wall(i, j, k)*result1/rlv(i, j, k)
            arg10 = -((ry/120.0)**8)
            f3 = exp(arg10)
            if (f1 .lt. f3) then
              f1 = f3
            else
              f1 = f1
            end if
          end if
          arg10 = arg1**4
          scratch(i, j, k, if1sst) = tanh(arg10)
        end do
      end do
    end do
! loop over the boundary conditions to set f1 in the boundary
! halo's. a neumann boundary condition is used for all bc's.
bocos:do nn=1,nbocos
! determine the face on which this subface is located, loop
! over its range and copy f1. although the range may include
! indirect halo's which are not computed, this is no problem,
! because in sstsolve only direct halo's are used.
      select case  (bcfaceid(nn)) 
      case (imin) 
        do k=kcbeg(nn),kcend(nn)
          do j=jcbeg(nn),jcend(nn)
            scratch(1, j, k, if1sst) = scratch(2, j, k, if1sst)
          end do
        end do
      case (imax) 
!              ==========================================================
        do k=kcbeg(nn),kcend(nn)
          do j=jcbeg(nn),jcend(nn)
            scratch(ie, j, k, if1sst) = scratch(il, j, k, if1sst)
          end do
        end do
      case (jmin) 
!              ==========================================================
        do k=kcbeg(nn),kcend(nn)
          do i=icbeg(nn),icend(nn)
            scratch(i, 1, k, if1sst) = scratch(i, 2, k, if1sst)
          end do
        end do
      case (jmax) 
!              ==========================================================
        do k=kcbeg(nn),kcend(nn)
          do i=icbeg(nn),icend(nn)
            scratch(i, je, k, if1sst) = scratch(i, jl, k, if1sst)
          end do
        end do
      case (kmin) 
!              ==========================================================
        do j=jcbeg(nn),jcend(nn)
          do i=icbeg(nn),icend(nn)
            scratch(i, j, 1, if1sst) = scratch(i, j, 2, if1sst)
          end do
        end do
      case (kmax) 
!              ==========================================================
        do j=jcbeg(nn),jcend(nn)
          do i=icbeg(nn),icend(nn)
            scratch(i, j, ke, if1sst) = scratch(i, j, kl, if1sst)
          end do
        end do
      end select
    end do bocos
  end subroutine f1sst

end module sst_d

