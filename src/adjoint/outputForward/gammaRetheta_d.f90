!        generated by tapenade     (inria, ecuador team)
!  tapenade 3.16 (develop) - 10 nov 2023 18:24
!
module gammarethetamodel_d
  use constants
  implicit none

contains
!  differentiation of solve_local_re_thetat_eq in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: re_thetat_eq
!   with respect to varying inputs: *w *rlv *vol *si *sj *sk
!   plus diff mem management of: w:in rlv:in vol:in si:in sj:in
!                sk:in
  subroutine solve_local_re_thetat_eq_d(re_thetat_eq, re_thetat_eqd, i, &
&   j, k)
    use blockpointers
    use constants
    use paramturb
    implicit none
! input/output variables
    integer(kind=inttype), intent(in) :: i, j, k
    real(kind=realtype), intent(out) :: re_thetat_eq
    real(kind=realtype), intent(out) :: re_thetat_eqd
! local variables
    real(kind=realtype) :: u, u_inv, fact, du_dx, du_dy, du_dz, du_ds, &
&   tu, f1, f2, f3, f
    real(kind=realtype) :: ud, u_invd, factd, du_dxd, du_dyd, du_dzd, &
&   du_dsd, tud, f1d, f2d, f3d, fd
    real(kind=realtype) :: dudx, dudy, dudz, dvdx, dvdy, dvdz, dwdx, &
&   dwdy, dwdz
    real(kind=realtype) :: dudxd, dudyd, dudzd, dvdxd, dvdyd, dvdzd, &
&   dwdxd, dwdyd, dwdzd
    real(kind=realtype) :: lambda, thetat, residum, thetat_old, &
&   residum_old, thetat_new
    real(kind=realtype) :: lambdad, thetatd, residumd, thetat_oldd, &
&   residum_oldd, thetat_newd
    real(kind=realtype) :: re_thetat_eq_1, re_thetat_eq_2
    real(kind=realtype) :: re_thetat_eq_1d, re_thetat_eq_2d
    integer(kind=inttype) :: n
    intrinsic sqrt
    intrinsic max
    intrinsic min
    intrinsic exp
    intrinsic abs
    real(kind=realtype) :: x1
    real(kind=realtype) :: x1d
    real(kind=realtype) :: abs0
    real(kind=realtype) :: arg1
    real(kind=realtype) :: arg1d
    real(kind=realtype) :: result1
    real(kind=realtype) :: result1d
    real(kind=realtype) :: temp
    real(kind=realtype) :: temp0
    real(kind=realtype) :: temp1
    real(kind=realtype) :: temp2
    real(kind=realtype) :: temp3
    real(kind=realtype) :: temp4
    real(kind=realtype) :: temp5
    real(kind=realtype) :: temp6
    real(kind=realtype) :: temp7
    real(kind=realtype) :: temp8
    real(kind=realtype) :: temp9
    real(kind=realtype) :: temp10
    real(kind=realtype) :: temp11
    temp = w(i, j, k, ivx)
    temp0 = w(i, j, k, ivy)
    temp1 = w(i, j, k, ivz)
    arg1d = 2*temp*wd(i, j, k, ivx) + 2*temp0*wd(i, j, k, ivy) + 2*temp1&
&     *wd(i, j, k, ivz)
    arg1 = temp*temp + temp0*temp0 + temp1*temp1
    temp1 = sqrt(arg1)
    if (arg1 .eq. 0.0_8) then
      ud = 0.0_8
    else
      ud = arg1d/(2.0*temp1)
    end if
    u = temp1
    u_invd = -(ud/u**2)
    u_inv = 1.0/u
! compute the gradient of u in the cell center. use is made
! of the fact that the surrounding normals sum up to zero,
! such that the cell i,j,k does not give a contribution.
! since the gradient is scaled by a factor of 2*vol, we need to account for that
    temp1 = 1.0/(2.0*vol(i, j, k))
    factd = -(temp1*vold(i, j, k)/vol(i, j, k))
    fact = temp1
    temp1 = si(i, j, k, 1)
    temp0 = w(i+1, j, k, ivx)
    temp = si(i-1, j, k, 1)
    temp2 = w(i-1, j, k, ivx)
    temp3 = sj(i, j, k, 1)
    temp4 = w(i, j+1, k, ivx)
    temp5 = sk(i, j, k, 1)
    temp6 = w(i, j, k+1, ivx)
    temp7 = sj(i, j-1, k, 1)
    temp8 = w(i, j-1, k, ivx)
    temp9 = sk(i, j, k-1, 1)
    temp10 = w(i, j, k-1, ivx)
    temp11 = temp0*temp1 - temp2*temp + temp4*temp3 + temp6*temp5 - &
&     temp8*temp7 - temp10*temp9
    dudxd = fact*(temp1*wd(i+1, j, k, ivx)+temp0*sid(i, j, k, 1)-temp*wd&
&     (i-1, j, k, ivx)-temp2*sid(i-1, j, k, 1)+temp3*wd(i, j+1, k, ivx)+&
&     temp4*sjd(i, j, k, 1)+temp5*wd(i, j, k+1, ivx)+temp6*skd(i, j, k, &
&     1)-temp7*wd(i, j-1, k, ivx)-temp8*sjd(i, j-1, k, 1)-temp9*wd(i, j&
&     , k-1, ivx)-temp10*skd(i, j, k-1, 1)) + temp11*factd
    dudx = temp11*fact
    temp11 = si(i, j, k, 2)
    temp10 = w(i+1, j, k, ivx)
    temp9 = si(i-1, j, k, 2)
    temp8 = w(i-1, j, k, ivx)
    temp7 = sj(i, j, k, 2)
    temp6 = w(i, j+1, k, ivx)
    temp5 = sk(i, j, k, 2)
    temp4 = w(i, j, k+1, ivx)
    temp3 = sj(i, j-1, k, 2)
    temp2 = w(i, j-1, k, ivx)
    temp1 = sk(i, j, k-1, 2)
    temp0 = w(i, j, k-1, ivx)
    temp = temp10*temp11 - temp8*temp9 + temp6*temp7 + temp4*temp5 - &
&     temp2*temp3 - temp0*temp1
    dudyd = fact*(temp11*wd(i+1, j, k, ivx)+temp10*sid(i, j, k, 2)-temp9&
&     *wd(i-1, j, k, ivx)-temp8*sid(i-1, j, k, 2)+temp7*wd(i, j+1, k, &
&     ivx)+temp6*sjd(i, j, k, 2)+temp5*wd(i, j, k+1, ivx)+temp4*skd(i, j&
&     , k, 2)-temp3*wd(i, j-1, k, ivx)-temp2*sjd(i, j-1, k, 2)-temp1*wd(&
&     i, j, k-1, ivx)-temp0*skd(i, j, k-1, 2)) + temp*factd
    dudy = temp*fact
    temp11 = si(i, j, k, 3)
    temp10 = w(i+1, j, k, ivx)
    temp9 = si(i-1, j, k, 3)
    temp8 = w(i-1, j, k, ivx)
    temp7 = sj(i, j, k, 3)
    temp6 = w(i, j+1, k, ivx)
    temp5 = sk(i, j, k, 3)
    temp4 = w(i, j, k+1, ivx)
    temp3 = sj(i, j-1, k, 3)
    temp2 = w(i, j-1, k, ivx)
    temp1 = sk(i, j, k-1, 3)
    temp0 = w(i, j, k-1, ivx)
    temp = temp10*temp11 - temp8*temp9 + temp6*temp7 + temp4*temp5 - &
&     temp2*temp3 - temp0*temp1
    dudzd = fact*(temp11*wd(i+1, j, k, ivx)+temp10*sid(i, j, k, 3)-temp9&
&     *wd(i-1, j, k, ivx)-temp8*sid(i-1, j, k, 3)+temp7*wd(i, j+1, k, &
&     ivx)+temp6*sjd(i, j, k, 3)+temp5*wd(i, j, k+1, ivx)+temp4*skd(i, j&
&     , k, 3)-temp3*wd(i, j-1, k, ivx)-temp2*sjd(i, j-1, k, 3)-temp1*wd(&
&     i, j, k-1, ivx)-temp0*skd(i, j, k-1, 3)) + temp*factd
    dudz = temp*fact
! idem for the gradient of v.
    temp11 = si(i, j, k, 1)
    temp10 = w(i+1, j, k, ivy)
    temp9 = si(i-1, j, k, 1)
    temp8 = w(i-1, j, k, ivy)
    temp7 = sj(i, j, k, 1)
    temp6 = w(i, j+1, k, ivy)
    temp5 = sk(i, j, k, 1)
    temp4 = w(i, j, k+1, ivy)
    temp3 = sj(i, j-1, k, 1)
    temp2 = w(i, j-1, k, ivy)
    temp1 = sk(i, j, k-1, 1)
    temp0 = w(i, j, k-1, ivy)
    temp = temp10*temp11 - temp8*temp9 + temp6*temp7 + temp4*temp5 - &
&     temp2*temp3 - temp0*temp1
    dvdxd = fact*(temp11*wd(i+1, j, k, ivy)+temp10*sid(i, j, k, 1)-temp9&
&     *wd(i-1, j, k, ivy)-temp8*sid(i-1, j, k, 1)+temp7*wd(i, j+1, k, &
&     ivy)+temp6*sjd(i, j, k, 1)+temp5*wd(i, j, k+1, ivy)+temp4*skd(i, j&
&     , k, 1)-temp3*wd(i, j-1, k, ivy)-temp2*sjd(i, j-1, k, 1)-temp1*wd(&
&     i, j, k-1, ivy)-temp0*skd(i, j, k-1, 1)) + temp*factd
    dvdx = temp*fact
    temp11 = si(i, j, k, 2)
    temp10 = w(i+1, j, k, ivy)
    temp9 = si(i-1, j, k, 2)
    temp8 = w(i-1, j, k, ivy)
    temp7 = sj(i, j, k, 2)
    temp6 = w(i, j+1, k, ivy)
    temp5 = sk(i, j, k, 2)
    temp4 = w(i, j, k+1, ivy)
    temp3 = sj(i, j-1, k, 2)
    temp2 = w(i, j-1, k, ivy)
    temp1 = sk(i, j, k-1, 2)
    temp0 = w(i, j, k-1, ivy)
    temp = temp10*temp11 - temp8*temp9 + temp6*temp7 + temp4*temp5 - &
&     temp2*temp3 - temp0*temp1
    dvdyd = fact*(temp11*wd(i+1, j, k, ivy)+temp10*sid(i, j, k, 2)-temp9&
&     *wd(i-1, j, k, ivy)-temp8*sid(i-1, j, k, 2)+temp7*wd(i, j+1, k, &
&     ivy)+temp6*sjd(i, j, k, 2)+temp5*wd(i, j, k+1, ivy)+temp4*skd(i, j&
&     , k, 2)-temp3*wd(i, j-1, k, ivy)-temp2*sjd(i, j-1, k, 2)-temp1*wd(&
&     i, j, k-1, ivy)-temp0*skd(i, j, k-1, 2)) + temp*factd
    dvdy = temp*fact
    temp11 = si(i, j, k, 3)
    temp10 = w(i+1, j, k, ivy)
    temp9 = si(i-1, j, k, 3)
    temp8 = w(i-1, j, k, ivy)
    temp7 = sj(i, j, k, 3)
    temp6 = w(i, j+1, k, ivy)
    temp5 = sk(i, j, k, 3)
    temp4 = w(i, j, k+1, ivy)
    temp3 = sj(i, j-1, k, 3)
    temp2 = w(i, j-1, k, ivy)
    temp1 = sk(i, j, k-1, 3)
    temp0 = w(i, j, k-1, ivy)
    temp = temp10*temp11 - temp8*temp9 + temp6*temp7 + temp4*temp5 - &
&     temp2*temp3 - temp0*temp1
    dvdzd = fact*(temp11*wd(i+1, j, k, ivy)+temp10*sid(i, j, k, 3)-temp9&
&     *wd(i-1, j, k, ivy)-temp8*sid(i-1, j, k, 3)+temp7*wd(i, j+1, k, &
&     ivy)+temp6*sjd(i, j, k, 3)+temp5*wd(i, j, k+1, ivy)+temp4*skd(i, j&
&     , k, 3)-temp3*wd(i, j-1, k, ivy)-temp2*sjd(i, j-1, k, 3)-temp1*wd(&
&     i, j, k-1, ivy)-temp0*skd(i, j, k-1, 3)) + temp*factd
    dvdz = temp*fact
! and for the gradient of w.
    temp11 = si(i, j, k, 1)
    temp10 = w(i+1, j, k, ivz)
    temp9 = si(i-1, j, k, 1)
    temp8 = w(i-1, j, k, ivz)
    temp7 = sj(i, j, k, 1)
    temp6 = w(i, j+1, k, ivz)
    temp5 = sk(i, j, k, 1)
    temp4 = w(i, j, k+1, ivz)
    temp3 = sj(i, j-1, k, 1)
    temp2 = w(i, j-1, k, ivz)
    temp1 = sk(i, j, k-1, 1)
    temp0 = w(i, j, k-1, ivz)
    temp = temp10*temp11 - temp8*temp9 + temp6*temp7 + temp4*temp5 - &
&     temp2*temp3 - temp0*temp1
    dwdxd = fact*(temp11*wd(i+1, j, k, ivz)+temp10*sid(i, j, k, 1)-temp9&
&     *wd(i-1, j, k, ivz)-temp8*sid(i-1, j, k, 1)+temp7*wd(i, j+1, k, &
&     ivz)+temp6*sjd(i, j, k, 1)+temp5*wd(i, j, k+1, ivz)+temp4*skd(i, j&
&     , k, 1)-temp3*wd(i, j-1, k, ivz)-temp2*sjd(i, j-1, k, 1)-temp1*wd(&
&     i, j, k-1, ivz)-temp0*skd(i, j, k-1, 1)) + temp*factd
    dwdx = temp*fact
    temp11 = si(i, j, k, 2)
    temp10 = w(i+1, j, k, ivz)
    temp9 = si(i-1, j, k, 2)
    temp8 = w(i-1, j, k, ivz)
    temp7 = sj(i, j, k, 2)
    temp6 = w(i, j+1, k, ivz)
    temp5 = sk(i, j, k, 2)
    temp4 = w(i, j, k+1, ivz)
    temp3 = sj(i, j-1, k, 2)
    temp2 = w(i, j-1, k, ivz)
    temp1 = sk(i, j, k-1, 2)
    temp0 = w(i, j, k-1, ivz)
    temp = temp10*temp11 - temp8*temp9 + temp6*temp7 + temp4*temp5 - &
&     temp2*temp3 - temp0*temp1
    dwdyd = fact*(temp11*wd(i+1, j, k, ivz)+temp10*sid(i, j, k, 2)-temp9&
&     *wd(i-1, j, k, ivz)-temp8*sid(i-1, j, k, 2)+temp7*wd(i, j+1, k, &
&     ivz)+temp6*sjd(i, j, k, 2)+temp5*wd(i, j, k+1, ivz)+temp4*skd(i, j&
&     , k, 2)-temp3*wd(i, j-1, k, ivz)-temp2*sjd(i, j-1, k, 2)-temp1*wd(&
&     i, j, k-1, ivz)-temp0*skd(i, j, k-1, 2)) + temp*factd
    dwdy = temp*fact
    temp11 = si(i, j, k, 3)
    temp10 = w(i+1, j, k, ivz)
    temp9 = si(i-1, j, k, 3)
    temp8 = w(i-1, j, k, ivz)
    temp7 = sj(i, j, k, 3)
    temp6 = w(i, j+1, k, ivz)
    temp5 = sk(i, j, k, 3)
    temp4 = w(i, j, k+1, ivz)
    temp3 = sj(i, j-1, k, 3)
    temp2 = w(i, j-1, k, ivz)
    temp1 = sk(i, j, k-1, 3)
    temp0 = w(i, j, k-1, ivz)
    temp = temp10*temp11 - temp8*temp9 + temp6*temp7 + temp4*temp5 - &
&     temp2*temp3 - temp0*temp1
    dwdzd = fact*(temp11*wd(i+1, j, k, ivz)+temp10*sid(i, j, k, 3)-temp9&
&     *wd(i-1, j, k, ivz)-temp8*sid(i-1, j, k, 3)+temp7*wd(i, j+1, k, &
&     ivz)+temp6*sjd(i, j, k, 3)+temp5*wd(i, j, k+1, ivz)+temp4*skd(i, j&
&     , k, 3)-temp3*wd(i, j-1, k, ivz)-temp2*sjd(i, j-1, k, 3)-temp1*wd(&
&     i, j, k-1, ivz)-temp0*skd(i, j, k-1, 3)) + temp*factd
    dwdz = temp*fact
    temp11 = w(i, j, k, ivz)
    temp10 = w(i, j, k, ivy)
    temp9 = w(i, j, k, ivx)
    temp8 = temp9*dudx + temp10*dudy + temp11*dudz
    du_dxd = temp8*u_invd + u_inv*(dudx*wd(i, j, k, ivx)+temp9*dudxd+&
&     dudy*wd(i, j, k, ivy)+temp10*dudyd+dudz*wd(i, j, k, ivz)+temp11*&
&     dudzd)
    du_dx = u_inv*temp8
    temp11 = w(i, j, k, ivz)
    temp10 = w(i, j, k, ivy)
    temp9 = w(i, j, k, ivx)
    temp8 = temp9*dvdx + temp10*dvdy + temp11*dvdz
    du_dyd = temp8*u_invd + u_inv*(dvdx*wd(i, j, k, ivx)+temp9*dvdxd+&
&     dvdy*wd(i, j, k, ivy)+temp10*dvdyd+dvdz*wd(i, j, k, ivz)+temp11*&
&     dvdzd)
    du_dy = u_inv*temp8
    temp11 = w(i, j, k, ivz)
    temp10 = w(i, j, k, ivy)
    temp9 = w(i, j, k, ivx)
    temp8 = temp9*dwdx + temp10*dwdy + temp11*dwdz
    du_dzd = temp8*u_invd + u_inv*(dwdx*wd(i, j, k, ivx)+temp9*dwdxd+&
&     dwdy*wd(i, j, k, ivy)+temp10*dwdyd+dwdz*wd(i, j, k, ivz)+temp11*&
&     dwdzd)
    du_dz = u_inv*temp8
    temp11 = du_dx/u
    temp10 = w(i, j, k, ivx)
    temp9 = du_dy/u
    temp8 = w(i, j, k, ivy)
    temp7 = du_dz/u
    temp6 = w(i, j, k, ivz)
    du_dsd = temp11*wd(i, j, k, ivx) + temp10*(du_dxd-temp11*ud)/u + &
&     temp9*wd(i, j, k, ivy) + temp8*(du_dyd-temp9*ud)/u + temp7*wd(i, j&
&     , k, ivz) + temp6*(du_dzd-temp7*ud)/u
    du_ds = temp10*temp11 + temp8*temp9 + temp6*temp7
    arg1d = 2*wd(i, j, k, itu1)/3
    arg1 = 2*w(i, j, k, itu1)/3
    temp11 = sqrt(arg1)
    if (arg1 .eq. 0.0_8) then
      result1d = 0.0_8
    else
      result1d = arg1d/(2.0*temp11)
    end if
    result1 = temp11
    tud = 100.0*(result1d-result1*ud/u)/u
    tu = 100.0*result1/u
    if (tu .lt. 0.027) then
      tu = 0.027
      tud = 0.0_8
    else
      tu = tu
    end if
! now we need to solve for theta through newton's method. the number of iterations is hard-coded so tapenade is 
! able to differentiate it
    thetat = 0.01
    thetat_oldd = 0.0_8
    re_thetat_eq_1d = 0.0_8
    residum_oldd = 0.0_8
    thetatd = 0.0_8
    do n=1,10
      temp11 = thetat*thetat*du_ds
      temp10 = w(i, j, k, irho)/rlv(i, j, k)
      lambdad = temp11*(wd(i, j, k, irho)-temp10*rlvd(i, j, k))/rlv(i, j&
&       , k) + temp10*(du_ds*2*thetat*thetatd+thetat**2*du_dsd)
      lambda = temp10*temp11
      if (lambda .gt. 0.1) then
        x1 = 0.1
        x1d = 0.0_8
      else
        x1d = lambdad
        x1 = lambda
      end if
      if (x1 .lt. -0.1) then
        lambda = -0.1
        lambdad = 0.0_8
      else
        lambdad = x1d
        lambda = x1
      end if
! compute f function
      temp11 = exp(-(tu/0.5))
      temp10 = -exp(-(35.0*lambda)) + 1.0
      f1d = 0.275*(temp11*exp(-(35.0*lambda))*35.0*lambdad-temp10*exp(-(&
&       tu/0.5))*tud/0.5)
      f1 = 0.275*(temp10*temp11) + 1.0
      if (f1 .lt. 1.0) then
        f2 = 1.0
        f2d = 0.0_8
      else
        f2d = f1d
        f2 = f1
      end if
      arg1d = -((tu/1.5)**0.5*tud)
      arg1 = -((tu/1.5)**1.5)
      temp11 = exp(arg1)
      temp10 = -(12.986*lambda) - 123.66*(lambda*lambda) - 405.689*(&
&       lambda*lambda*lambda)
      f3d = -(temp10*exp(arg1)*arg1d-temp11*(123.66*2*lambda+405.689*3*&
&       lambda**2+12.986)*lambdad)
      f3 = 1.0 - temp10*temp11
      if (f2 .gt. f3) then
        fd = f3d
        f = f3
      else
        fd = f2d
        f = f2
      end if
      if (tu .gt. 1.3) then
        temp11 = (tu-0.5658)**(-0.671)
        re_thetat_eq_1d = 331.50*(temp11*fd-f*0.671*(tu-0.5658)**(-1.671&
&         )*tud)
        re_thetat_eq_1 = 331.50*(temp11*f)
      else
        temp11 = 0.2196/(tu*tu)
        re_thetat_eq_1d = (temp11-589.428*tu+1173.51)*fd - f*(temp11*2/&
&         tu+589.428)*tud
        re_thetat_eq_1 = (temp11-589.428*tu+1173.51)*f
      end if
      temp11 = u*thetat/rlv(i, j, k)
      temp10 = w(i, j, k, irho)
      re_thetat_eq_2d = temp11*wd(i, j, k, irho) + temp10*(thetat*ud+u*&
&       thetatd-temp11*rlvd(i, j, k))/rlv(i, j, k)
      re_thetat_eq_2 = temp10*temp11
! residum which should go to 0
      residumd = re_thetat_eq_1d - re_thetat_eq_2d
      residum = re_thetat_eq_1 - re_thetat_eq_2
! print *, 'iteration, thetat, residum, re_thetat_eq_1', n, thetat, residum, re_thetat_eq_1
! if we are in the first iteration, we need to kickstart the secant method first
      if (n .eq. 1) then
        residum_oldd = residumd
        residum_old = residum
        thetat_oldd = thetatd
        thetat_old = thetat
        thetatd = 0.5*thetatd
        thetat = 0.5*thetat
      else
        if (residum .ge. 0.) then
          abs0 = residum
        else
          abs0 = -residum
        end if
! if the residum is basically 0, we cycle until we reach the end. (we cant drop out because tapenade would be unable to
! differentiate it)
        if (abs0 .ge. 1e-9) then
! compute next step (secant method)
          temp11 = (thetat_old*residum-thetat*residum_old)/(residum-&
&           residum_old)
          thetat_newd = (residum*thetat_oldd+thetat_old*residumd-&
&           residum_old*thetatd-thetat*residum_oldd-temp11*(residumd-&
&           residum_oldd))/(residum-residum_old)
          thetat_new = temp11
! save values for next iteration
          residum_oldd = residumd
          residum_old = residum
          thetat_oldd = thetatd
          thetat_old = thetat
          thetatd = thetat_newd
          thetat = thetat_new
        end if
      end if
    end do
    if (re_thetat_eq_1 .lt. 20.0) then
      re_thetat_eq = 20.0
      re_thetat_eqd = 0.0_8
    else
      re_thetat_eqd = re_thetat_eq_1d
      re_thetat_eq = re_thetat_eq_1
    end if
  end subroutine solve_local_re_thetat_eq_d

  subroutine solve_local_re_thetat_eq(re_thetat_eq, i, j, k)
    use blockpointers
    use constants
    use paramturb
    implicit none
! input/output variables
    integer(kind=inttype), intent(in) :: i, j, k
    real(kind=realtype), intent(out) :: re_thetat_eq
! local variables
    real(kind=realtype) :: u, u_inv, fact, du_dx, du_dy, du_dz, du_ds, &
&   tu, f1, f2, f3, f
    real(kind=realtype) :: dudx, dudy, dudz, dvdx, dvdy, dvdz, dwdx, &
&   dwdy, dwdz
    real(kind=realtype) :: lambda, thetat, residum, thetat_old, &
&   residum_old, thetat_new
    real(kind=realtype) :: re_thetat_eq_1, re_thetat_eq_2
    integer(kind=inttype) :: n
    intrinsic sqrt
    intrinsic max
    intrinsic min
    intrinsic exp
    intrinsic abs
    real(kind=realtype) :: x1
    real(kind=realtype) :: abs0
    real(kind=realtype) :: arg1
    real(kind=realtype) :: result1
    arg1 = w(i, j, k, ivx)**2 + w(i, j, k, ivy)**2 + w(i, j, k, ivz)**2
    u = sqrt(arg1)
    u_inv = 1.0/u
! compute the gradient of u in the cell center. use is made
! of the fact that the surrounding normals sum up to zero,
! such that the cell i,j,k does not give a contribution.
! since the gradient is scaled by a factor of 2*vol, we need to account for that
    fact = 1.0/(vol(i, j, k)*2.0)
    dudx = (w(i+1, j, k, ivx)*si(i, j, k, 1)-w(i-1, j, k, ivx)*si(i-1, j&
&     , k, 1)+w(i, j+1, k, ivx)*sj(i, j, k, 1)-w(i, j-1, k, ivx)*sj(i, j&
&     -1, k, 1)+w(i, j, k+1, ivx)*sk(i, j, k, 1)-w(i, j, k-1, ivx)*sk(i&
&     , j, k-1, 1))*fact
    dudy = (w(i+1, j, k, ivx)*si(i, j, k, 2)-w(i-1, j, k, ivx)*si(i-1, j&
&     , k, 2)+w(i, j+1, k, ivx)*sj(i, j, k, 2)-w(i, j-1, k, ivx)*sj(i, j&
&     -1, k, 2)+w(i, j, k+1, ivx)*sk(i, j, k, 2)-w(i, j, k-1, ivx)*sk(i&
&     , j, k-1, 2))*fact
    dudz = (w(i+1, j, k, ivx)*si(i, j, k, 3)-w(i-1, j, k, ivx)*si(i-1, j&
&     , k, 3)+w(i, j+1, k, ivx)*sj(i, j, k, 3)-w(i, j-1, k, ivx)*sj(i, j&
&     -1, k, 3)+w(i, j, k+1, ivx)*sk(i, j, k, 3)-w(i, j, k-1, ivx)*sk(i&
&     , j, k-1, 3))*fact
! idem for the gradient of v.
    dvdx = (w(i+1, j, k, ivy)*si(i, j, k, 1)-w(i-1, j, k, ivy)*si(i-1, j&
&     , k, 1)+w(i, j+1, k, ivy)*sj(i, j, k, 1)-w(i, j-1, k, ivy)*sj(i, j&
&     -1, k, 1)+w(i, j, k+1, ivy)*sk(i, j, k, 1)-w(i, j, k-1, ivy)*sk(i&
&     , j, k-1, 1))*fact
    dvdy = (w(i+1, j, k, ivy)*si(i, j, k, 2)-w(i-1, j, k, ivy)*si(i-1, j&
&     , k, 2)+w(i, j+1, k, ivy)*sj(i, j, k, 2)-w(i, j-1, k, ivy)*sj(i, j&
&     -1, k, 2)+w(i, j, k+1, ivy)*sk(i, j, k, 2)-w(i, j, k-1, ivy)*sk(i&
&     , j, k-1, 2))*fact
    dvdz = (w(i+1, j, k, ivy)*si(i, j, k, 3)-w(i-1, j, k, ivy)*si(i-1, j&
&     , k, 3)+w(i, j+1, k, ivy)*sj(i, j, k, 3)-w(i, j-1, k, ivy)*sj(i, j&
&     -1, k, 3)+w(i, j, k+1, ivy)*sk(i, j, k, 3)-w(i, j, k-1, ivy)*sk(i&
&     , j, k-1, 3))*fact
! and for the gradient of w.
    dwdx = (w(i+1, j, k, ivz)*si(i, j, k, 1)-w(i-1, j, k, ivz)*si(i-1, j&
&     , k, 1)+w(i, j+1, k, ivz)*sj(i, j, k, 1)-w(i, j-1, k, ivz)*sj(i, j&
&     -1, k, 1)+w(i, j, k+1, ivz)*sk(i, j, k, 1)-w(i, j, k-1, ivz)*sk(i&
&     , j, k-1, 1))*fact
    dwdy = (w(i+1, j, k, ivz)*si(i, j, k, 2)-w(i-1, j, k, ivz)*si(i-1, j&
&     , k, 2)+w(i, j+1, k, ivz)*sj(i, j, k, 2)-w(i, j-1, k, ivz)*sj(i, j&
&     -1, k, 2)+w(i, j, k+1, ivz)*sk(i, j, k, 2)-w(i, j, k-1, ivz)*sk(i&
&     , j, k-1, 2))*fact
    dwdz = (w(i+1, j, k, ivz)*si(i, j, k, 3)-w(i-1, j, k, ivz)*si(i-1, j&
&     , k, 3)+w(i, j+1, k, ivz)*sj(i, j, k, 3)-w(i, j-1, k, ivz)*sj(i, j&
&     -1, k, 3)+w(i, j, k+1, ivz)*sk(i, j, k, 3)-w(i, j, k-1, ivz)*sk(i&
&     , j, k-1, 3))*fact
    du_dx = u_inv*(w(i, j, k, ivx)*dudx+w(i, j, k, ivy)*dudy+w(i, j, k, &
&     ivz)*dudz)
    du_dy = u_inv*(w(i, j, k, ivx)*dvdx+w(i, j, k, ivy)*dvdy+w(i, j, k, &
&     ivz)*dvdz)
    du_dz = u_inv*(w(i, j, k, ivx)*dwdx+w(i, j, k, ivy)*dwdy+w(i, j, k, &
&     ivz)*dwdz)
    du_ds = w(i, j, k, ivx)/u*du_dx + w(i, j, k, ivy)/u*du_dy + w(i, j, &
&     k, ivz)/u*du_dz
    arg1 = 2*w(i, j, k, itu1)/3
    result1 = sqrt(arg1)
    tu = 100.0*result1/u
    if (tu .lt. 0.027) then
      tu = 0.027
    else
      tu = tu
    end if
! now we need to solve for theta through newton's method. the number of iterations is hard-coded so tapenade is 
! able to differentiate it
    thetat = 0.01
    do n=1,10
      lambda = w(i, j, k, irho)*thetat**2/rlv(i, j, k)*du_ds
      if (lambda .gt. 0.1) then
        x1 = 0.1
      else
        x1 = lambda
      end if
      if (x1 .lt. -0.1) then
        lambda = -0.1
      else
        lambda = x1
      end if
! compute f function
      f1 = 1.0 + 0.275*(1.0-exp(-(35.0*lambda)))*exp(-(tu/0.5))
      if (f1 .lt. 1.0) then
        f2 = 1.0
      else
        f2 = f1
      end if
      arg1 = -((tu/1.5)**1.5)
      f3 = 1.0 - (-(12.986*lambda)-123.66*lambda**2-405.689*lambda**3)*&
&       exp(arg1)
      if (f2 .gt. f3) then
        f = f3
      else
        f = f2
      end if
      if (tu .gt. 1.3) then
        re_thetat_eq_1 = 331.50*(tu-0.5658)**(-0.671)*f
      else
        re_thetat_eq_1 = (1173.51-589.428*tu+0.2196*tu**(-2))*f
      end if
      re_thetat_eq_2 = w(i, j, k, irho)*u*thetat/rlv(i, j, k)
! residum which should go to 0
      residum = re_thetat_eq_1 - re_thetat_eq_2
! print *, 'iteration, thetat, residum, re_thetat_eq_1', n, thetat, residum, re_thetat_eq_1
! if we are in the first iteration, we need to kickstart the secant method first
      if (n .eq. 1) then
        residum_old = residum
        thetat_old = thetat
        thetat = 0.5*thetat
      else
        if (residum .ge. 0.) then
          abs0 = residum
        else
          abs0 = -residum
        end if
! if the residum is basically 0, we cycle until we reach the end. (we cant drop out because tapenade would be unable to
! differentiate it)
        if (abs0 .ge. 1e-9) then
! compute next step (secant method)
          thetat_new = (thetat_old*residum-thetat*residum_old)/(residum-&
&           residum_old)
! save values for next iteration
          residum_old = residum
          thetat_old = thetat
          thetat = thetat_new
        end if
      end if
    end do
    if (re_thetat_eq_1 .lt. 20.0) then
      re_thetat_eq = 20.0
    else
      re_thetat_eq = re_thetat_eq_1
    end if
  end subroutine solve_local_re_thetat_eq

!  differentiation of gammarethetasource in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *scratch
!   with respect to varying inputs: *rev *w *rlv *scratch *vol
!                *d2wall *si *sj *sk
!   rw status of diff variables: *rev:in *w:in *rlv:in *scratch:in-out
!                *vol:in *d2wall:in *si:in *sj:in *sk:in
!   plus diff mem management of: rev:in w:in rlv:in scratch:in
!                vol:in d2wall:in si:in sj:in sk:in
  subroutine gammarethetasource_d()
    use blockpointers
    use constants
    use variableconstants
    use paramturb
    implicit none
    integer(kind=inttype) :: i, j, k
    real(kind=realtype) :: re_thetat_eq, u2, u, lambda_theta, delta, &
&   f_theta_t, t, r_t, re_theta_c
    real(kind=realtype) :: re_thetat_eqd, u2d, ud, deltad, f_theta_td, &
&   td, r_td, re_theta
    real(kind=realtype) :: re_s, f_length1, f_length, f_onset1, f_onset&
&   , f_turb, p_gamma, e_gamma, p_thetat
    real(kind=realtype) :: re_sd, f_length1d, f_lengthd, f_onset1d, &
&   f_onsetd, f_turbd, p_gammad, e_gammad, p_thetatd
    real(kind=realtype) :: re_omega, f_wake
    real(kind=realtype) :: re_omegad, f_waked
    real(kind=realtype) :: rhoi, vort
    real(kind=realtype) :: rhoid, vortd
    intrinsic sqrt
    intrinsic max
    intrinsic exp
    intrinsic min
    intrinsic sin
    intrinsic tanh
    real(kind=realtype) :: x1
    real(kind=realtype) :: x1d
    real(kind=realtype) :: x2
    real(kind=realtype) :: x2d
    real(kind=realtype) :: x3
    real(kind=realtype) :: x3d
    real(kind=realtype) :: arg1
    real(kind=realtype) :: arg1d
    real(kind=realtype) :: result1
    real(kind=realtype) :: result1d
    real(kind=realtype) :: result2
    real(kind=realtype) :: result2d
    real(kind=realtype) :: temp
    real(kind=realtype) :: temp0
    real(kind=realtype) :: temp1
    real(kind=realtype) :: temp2
    real(kind=realtype) :: temp3
    real(kind=realtype) :: tempd
    do k=2,kl
      do j=2,jl
        do i=2,il
          temp = one/w(i, j, k, irho)
          rhoid = -(temp*wd(i, j, k, irho)/w(i, j, k, irho))
          rhoi = temp
          temp = scratch(i, j, k, ivorticity)
          temp0 = sqrt(temp)
          if (temp .eq. 0.0_8) then
            x1d = 0.0_8
          else
            x1d = scratchd(i, j, k, ivorticity)/(2.0*temp0)
          end if
          x1 = temp0
          if (x1 .lt. eps) then
            vort = eps
            vortd = 0.0_8
          else
            vortd = x1d
            vort = x1
          end if
! compute re_thetat_eq
          call solve_local_re_thetat_eq_d(re_thetat_eq, re_thetat_eqd, i&
&                                   , j, k)
          temp0 = w(i, j, k, ivx)
          temp = w(i, j, k, ivy)
          temp1 = w(i, j, k, ivz)
          u2d = 2*temp0*wd(i, j, k, ivx) + 2*temp*wd(i, j, k, ivy) + 2*&
&           temp1*wd(i, j, k, ivz)
          u2 = temp0*temp0 + temp*temp + temp1*temp1
          temp1 = sqrt(u2)
          if (u2 .eq. 0.0_8) then
            ud = 0.0_8
          else
            ud = u2d/(2.0*temp1)
          end if
          u = temp1
          temp1 = d2wall(i, j, k)
          temp0 = w(i, j, k, itu2)
          temp = temp0*(temp1*temp1)
          temp2 = w(i, j, k, irho)/rlv(i, j, k)
          re_omegad = temp*(wd(i, j, k, irho)-temp2*rlvd(i, j, k))/rlv(i&
&           , j, k) + temp2*(temp1**2*wd(i, j, k, itu2)+temp0*2*temp1*&
&           d2walld(i, j, k))
          re_omega = temp2*temp
          arg1d = -(2*re_omega*re_omegad/1e5**2)
          arg1 = -((re_omega/1e5)**2)
          f_waked = exp(arg1)*arg1d
          f_wake = exp(arg1)
          temp2 = w(i, j, k, irho)
          temp1 = d2wall(i, j, k)
          temp0 = w(i, j, k, itransition2)
          temp = temp0*vort*temp1/(temp2*u)
          deltad = 375.0*(vort*temp1*wd(i, j, k, itransition2)+temp0*(&
&           temp1*vortd+vort*d2walld(i, j, k))-temp*(u*wd(i, j, k, irho)&
&           +temp2*ud))/(temp2*u)
          delta = 375.0*temp
          temp2 = d2wall(i, j, k)/delta
          arg1d = -(4*temp2**3*(d2walld(i, j, k)-temp2*deltad)/delta)
          arg1 = -(temp2**4)
          temp2 = exp(arg1)
          x3d = temp2*f_waked + f_wake*exp(arg1)*arg1d
          x3 = f_wake*temp2
          if (x3 .lt. 1.0 - ((rlmce2*w(i, j, k, itransition1)-1.0)/(&
&             rlmce2-1))**2) then
            temp2 = (rlmce2*w(i, j, k, itransition1)-1.0)/(rlmce2-1)
            x2d = -(2*temp2*rlmce2*wd(i, j, k, itransition1)/(rlmce2-1))
            x2 = 1.0 - temp2*temp2
          else
            x2d = x3d
            x2 = x3
          end if
          if (x2 .gt. 1.0) then
            f_theta_t = 1.0
            f_theta_td = 0.0_8
          else
            f_theta_td = x2d
            f_theta_t = x2
          end if
          temp2 = w(i, j, k, irho)
          temp1 = rlv(i, j, k)/(temp2*u2)
          td = 500.0*(rlvd(i, j, k)-temp1*(u2*wd(i, j, k, irho)+temp2*&
&           u2d))/(temp2*u2)
          t = 500.0*temp1
! todo: save this in scratch
          temp2 = w(i, j, k, itu2)
          temp1 = rlv(i, j, k)*temp2
          temp0 = w(i, j, k, itu1)
          temp = w(i, j, k, irho)
          temp3 = temp*temp0/temp1
          r_td = (temp0*wd(i, j, k, irho)+temp*wd(i, j, k, itu1)-temp3*(&
&           temp2*rlvd(i, j, k)+rlv(i, j, k)*wd(i, j, k, itu2)))/temp1
          r_t = temp3
! todo: save this in scratch
          arg1d = wd(i, j, k, itransition2)/240.0
          arg1 = w(i, j, k, itransition2)/240.0 + 0.5
          re_theta = 0.67*wd(i, j, k, itransition2) + 24.0*cos(arg1)*&
&           arg1d
          re_theta_c = 0.67*w(i, j, k, itransition2) + 24.0*sin(arg1) + &
&           14.0
! todo: save this in scratch
          temp3 = scratch(i, j, k, istrain)
          temp2 = sqrt(temp3)
          if (temp3 .eq. 0.0_8) then
            result1d = 0.0_8
          else
            result1d = scratchd(i, j, k, istrain)/(2.0*temp2)
          end if
          result1 = temp2
          temp3 = result1/rev(i, j, k)
          temp2 = d2wall(i, j, k)
          temp1 = w(i, j, k, irho)
          temp0 = temp1*(temp2*temp2)
          re_sd = temp3*(temp2**2*wd(i, j, k, irho)+temp1*2*temp2*&
&           d2walld(i, j, k)) + temp0*(result1d-temp3*revd(i, j, k))/rev&
&           (i, j, k)
          re_s = temp0*temp3
          temp3 = -(0.03*(w(i, j, k, itransition2)-460.0))
          f_length1d = -(exp(temp3)*0.03*wd(i, j, k, itransition2))
          f_length1 = exp(temp3)
          temp3 = (f_length1+1)**(1.0/6)
          temp2 = (30000.0*(w(i, j, k, itransition2)-596.0)+43.5)/temp3
          if (f_length1 + 1 .le. 0.0_8 .and. (1.0/6 .eq. 0.0_8 .or. 1.0/&
&             6 .ne. int(1.0/6))) then
            tempd = 0.0_8
          else
            tempd = (f_length1+1)**(1.0/6-1)*f_length1d/6
          end if
          f_lengthd = -((30000.0*wd(i, j, k, itransition2)-temp2*tempd)/&
&           temp3)
          f_length = 44.0 - temp2
! continue here
          temp3 = re_s/(2.6*re_theta_c)
          arg1d = (re_sd-temp3*2.6*re_theta)/(2.6*re_theta_c)
          arg1 = temp3
          temp3 = sqrt(arg1)
          if (arg1 .eq. 0.0_8) then
            f_onset1d = 0.0_8
          else
            f_onset1d = arg1d/(2.0*temp3)
          end if
          f_onset1 = temp3
          f_onsetd = (1.0-tanh(6.0*(f_onset1-1.35))**2)*6.0*f_onset1d/&
&           2.0
          f_onset = (tanh(6.0*(f_onset1-1.35))+1.0)/2.0
          temp3 = exp(-r_t)
          f_turbd = -(temp3*f_onsetd) - (1-f_onset)*exp(-r_t)*r_td
          f_turb = (1-f_onset)*temp3
! since we need to divide by rho, rho does not appear here anymore
          temp3 = scratch(i, j, k, istrain)
          temp2 = sqrt(temp3)
          if (temp3 .eq. 0.0_8) then
            result1d = 0.0_8
          else
            result1d = scratchd(i, j, k, istrain)/(2.0*temp2)
          end if
          result1 = temp2
          temp3 = w(i, j, k, itransition1)
          arg1d = f_onset*wd(i, j, k, itransition1) + temp3*f_onsetd
          arg1 = temp3*f_onset
          temp3 = sqrt(arg1)
          if (arg1 .eq. 0.0_8) then
            result2d = 0.0_8
          else
            result2d = arg1d/(2.0*temp3)
          end if
          result2 = temp3
          temp3 = -(rlmce1*w(i, j, k, itransition1)) + 1.0
          temp2 = f_length*result1*result2
          temp1 = w(i, j, k, irho)
          temp0 = temp1*temp2
          p_gammad = rlmca1*(temp3*(temp2*wd(i, j, k, irho)+temp1*(&
&           result2*(result1*f_lengthd+f_length*result1d)+f_length*&
&           result1*result2d))-temp0*rlmce1*wd(i, j, k, itransition1))
          p_gamma = rlmca1*(temp0*temp3)
          temp3 = rlmce2*w(i, j, k, itransition1) - 1.0
          temp2 = w(i, j, k, itransition1)
          temp1 = w(i, j, k, irho)
          temp0 = temp1*vort*f_turb
          e_gammad = rlmca2*(temp2*temp3*(vort*f_turb*wd(i, j, k, irho)+&
&           temp1*(f_turb*vortd+vort*f_turbd))+temp0*(temp3+temp2*rlmce2&
&           )*wd(i, j, k, itransition1))
          e_gamma = rlmca2*(temp0*(temp2*temp3))
          temp3 = re_thetat_eq - w(i, j, k, itransition2)
          temp2 = (-f_theta_t+1.0)/t
          temp1 = w(i, j, k, irho)
          p_thetatd = rlmcthetat*(temp3*(temp2*wd(i, j, k, irho)+temp1*(&
&           -f_theta_td-temp2*td)/t)+temp1*temp2*(re_thetat_eqd-wd(i, j&
&           , k, itransition2)))
          p_thetat = rlmcthetat*(temp1*temp2*temp3)
          scratchd(i, j, k, istransition1) = rhoi*(p_gammad-e_gammad) + &
&           (p_gamma-e_gamma)*rhoid
          scratch(i, j, k, istransition1) = (p_gamma-e_gamma)*rhoi
          scratchd(i, j, k, istransition2) = rhoi*p_thetatd + p_thetat*&
&           rhoid
          scratch(i, j, k, istransition2) = p_thetat*rhoi
! print *, 'source terms: gamma, thetat', scratch(i, j, k, istransition1), scratch(i, j, k, istransition2)
        end do
      end do
    end do
  end subroutine gammarethetasource_d

  subroutine gammarethetasource()
    use blockpointers
    use constants
    use variableconstants
    use paramturb
    implicit none
    integer(kind=inttype) :: i, j, k
    real(kind=realtype) :: re_thetat_eq, u2, u, lambda_theta, delta, &
&   f_theta_t, t, r_t, re_theta_c
    real(kind=realtype) :: re_s, f_length1, f_length, f_onset1, f_onset&
&   , f_turb, p_gamma, e_gamma, p_thetat
    real(kind=realtype) :: re_omega, f_wake
    real(kind=realtype) :: rhoi, vort
    intrinsic sqrt
    intrinsic max
    intrinsic exp
    intrinsic min
    intrinsic sin
    intrinsic tanh
    real(kind=realtype) :: x1
    real(kind=realtype) :: x2
    real(kind=realtype) :: x3
    real(kind=realtype) :: arg1
    real(kind=realtype) :: result1
    real(kind=realtype) :: result2
    do k=2,kl
      do j=2,jl
        do i=2,il
          rhoi = one/w(i, j, k, irho)
          x1 = sqrt(scratch(i, j, k, ivorticity))
          if (x1 .lt. eps) then
            vort = eps
          else
            vort = x1
          end if
! compute re_thetat_eq
          call solve_local_re_thetat_eq(re_thetat_eq, i, j, k)
          u2 = w(i, j, k, ivx)**2 + w(i, j, k, ivy)**2 + w(i, j, k, ivz)&
&           **2
          u = sqrt(u2)
          re_omega = w(i, j, k, irho)*w(i, j, k, itu2)*d2wall(i, j, k)**&
&           2/rlv(i, j, k)
          arg1 = -((re_omega/1e5)**2)
          f_wake = exp(arg1)
          delta = 375.0*vort*w(i, j, k, itransition2)*d2wall(i, j, k)/(w&
&           (i, j, k, irho)*u)
          arg1 = -((d2wall(i, j, k)/delta)**4)
          x3 = f_wake*exp(arg1)
          if (x3 .lt. 1.0 - ((rlmce2*w(i, j, k, itransition1)-1.0)/(&
&             rlmce2-1))**2) then
            x2 = 1.0 - ((rlmce2*w(i, j, k, itransition1)-1.0)/(rlmce2-1)&
&             )**2
          else
            x2 = x3
          end if
          if (x2 .gt. 1.0) then
            f_theta_t = 1.0
          else
            f_theta_t = x2
          end if
          t = 500.0*rlv(i, j, k)/(w(i, j, k, irho)*u2)
! todo: save this in scratch
          r_t = w(i, j, k, irho)*w(i, j, k, itu1)/(rlv(i, j, k)*w(i, j, &
&           k, itu2))
! todo: save this in scratch
          arg1 = w(i, j, k, itransition2)/240.0 + 0.5
          re_theta_c = 0.67*w(i, j, k, itransition2) + 24.0*sin(arg1) + &
&           14.0
! todo: save this in scratch
          result1 = sqrt(scratch(i, j, k, istrain))
          re_s = w(i, j, k, irho)*result1*d2wall(i, j, k)**2/rev(i, j, k&
&           )
          f_length1 = exp(-(0.03*(w(i, j, k, itransition2)-460.0)))
          f_length = 44.0 - (44.0-(0.5-30000.0*(w(i, j, k, itransition2)&
&           -596.0)))/(1+f_length1)**(1/6)
! continue here
          arg1 = re_s/(2.6*re_theta_c)
          f_onset1 = sqrt(arg1)
          f_onset = (tanh(6.0*(f_onset1-1.35))+1.0)/2.0
          f_turb = (1-f_onset)*exp(-r_t)
! since we need to divide by rho, rho does not appear here anymore
          result1 = sqrt(scratch(i, j, k, istrain))
          arg1 = w(i, j, k, itransition1)*f_onset
          result2 = sqrt(arg1)
          p_gamma = f_length*rlmca1*w(i, j, k, irho)*result1*result2*(&
&           1.0-rlmce1*w(i, j, k, itransition1))
          e_gamma = rlmca2*w(i, j, k, irho)*vort*w(i, j, k, itransition1&
&           )*f_turb*(rlmce2*w(i, j, k, itransition1)-1.0)
          p_thetat = rlmcthetat*w(i, j, k, irho)/t*(re_thetat_eq-w(i, j&
&           , k, itransition2))*(1.0-f_theta_t)
          scratch(i, j, k, istransition1) = (p_gamma-e_gamma)*rhoi
          scratch(i, j, k, istransition2) = p_thetat*rhoi
! print *, 'source terms: gamma, thetat', scratch(i, j, k, istransition1), scratch(i, j, k, istransition2)
        end do
      end do
    end do
  end subroutine gammarethetasource

!  differentiation of gammarethetaviscous in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *scratch
!   with respect to varying inputs: *rev *w *rlv *scratch *vol
!                *si *sj *sk
!   rw status of diff variables: *rev:in *w:in *rlv:in *scratch:in-out
!                *vol:in *si:in *sj:in *sk:in
!   plus diff mem management of: rev:in w:in rlv:in scratch:in
!                vol:in si:in sj:in sk:in
  subroutine gammarethetaviscous_d()
    use blockpointers
    use constants
    use variableconstants
    use paramturb
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rhoi
    real(kind=realtype) :: rhoid
    real(kind=realtype) :: voli, volmi, volpi
    real(kind=realtype) :: volid, volmid, volpid
    real(kind=realtype) :: xm, ym, zm, xp, yp, zp, xa, ya, za
    real(kind=realtype) :: xmd, ymd, zmd, xpd, ypd, zpd, xad, yad, zad
    real(kind=realtype) :: mulm, mulp, muem, muep
    real(kind=realtype) :: mulmd, mulpd, muemd, muepd
    real(kind=realtype) :: ttm, ttp
    real(kind=realtype) :: ttmd, ttpd
    real(kind=realtype) :: c1m, c1p, c10, c2m, c2p, c20
    real(kind=realtype) :: c1md, c1pd, c10d, c2md, c2pd, c20d
    real(kind=realtype) :: rblank
    real(kind=realtype) :: temp
    real(kind=realtype) :: temp0
    real(kind=realtype) :: temp1
!       advection and unsteady terms.
!
!
!       viscous terms in k-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in zeta-direction, i.e. along the
! line k = constant.
          temp = one/vol(i, j, k)
          volid = -(temp*vold(i, j, k)/vol(i, j, k))
          voli = temp
          temp = two/(vol(i, j, k)+vol(i, j, k-1))
          volmid = -(temp*(vold(i, j, k)+vold(i, j, k-1))/(vol(i, j, k)+&
&           vol(i, j, k-1)))
          volmi = temp
          temp = two/(vol(i, j, k)+vol(i, j, k+1))
          volpid = -(temp*(vold(i, j, k)+vold(i, j, k+1))/(vol(i, j, k)+&
&           vol(i, j, k+1)))
          volpi = temp
          temp = sk(i, j, k-1, 1)
          xmd = volmi*skd(i, j, k-1, 1) + temp*volmid
          xm = temp*volmi
          temp = sk(i, j, k-1, 2)
          ymd = volmi*skd(i, j, k-1, 2) + temp*volmid
          ym = temp*volmi
          temp = sk(i, j, k-1, 3)
          zmd = volmi*skd(i, j, k-1, 3) + temp*volmid
          zm = temp*volmi
          temp = sk(i, j, k, 1)
          xpd = volpi*skd(i, j, k, 1) + temp*volpid
          xp = temp*volpi
          temp = sk(i, j, k, 2)
          ypd = volpi*skd(i, j, k, 2) + temp*volpid
          yp = temp*volpi
          temp = sk(i, j, k, 3)
          zpd = volpi*skd(i, j, k, 3) + temp*volpid
          zp = temp*volpi
          temp = sk(i, j, k, 1) + sk(i, j, k-1, 1)
          xad = half*(voli*(skd(i, j, k, 1)+skd(i, j, k-1, 1))+temp*&
&           volid)
          xa = half*(temp*voli)
          temp = sk(i, j, k, 2) + sk(i, j, k-1, 2)
          yad = half*(voli*(skd(i, j, k, 2)+skd(i, j, k-1, 2))+temp*&
&           volid)
          ya = half*(temp*voli)
          temp = sk(i, j, k, 3) + sk(i, j, k-1, 3)
          zad = half*(voli*(skd(i, j, k, 3)+skd(i, j, k-1, 3))+temp*&
&           volid)
          za = half*(temp*voli)
          ttmd = xa*xmd + xm*xad + ya*ymd + ym*yad + za*zmd + zm*zad
          ttm = xm*xa + ym*ya + zm*za
          ttpd = xa*xpd + xp*xad + ya*ypd + yp*yad + za*zpd + zp*zad
          ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in zeta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in zeta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dzeta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the gamma-term.
          temp = one/w(i, j, k, irho)
          rhoid = -(temp*wd(i, j, k, irho)/w(i, j, k, irho))
          rhoi = temp
          mulmd = half*(rlvd(i, j, k-1)+rlvd(i, j, k))
          mulm = half*(rlv(i, j, k-1)+rlv(i, j, k))
          mulpd = half*(rlvd(i, j, k+1)+rlvd(i, j, k))
          mulp = half*(rlv(i, j, k+1)+rlv(i, j, k))
          muemd = half*(revd(i, j, k-1)+revd(i, j, k))
          muem = half*(rev(i, j, k-1)+rev(i, j, k))
          muepd = half*(revd(i, j, k+1)+revd(i, j, k))
          muep = half*(rev(i, j, k+1)+rev(i, j, k))
          temp = mulm + muem/rlmsigmaf
          c1md = ttm*rhoi*(mulmd+muemd/rlmsigmaf) + temp*(rhoi*ttmd+ttm*&
&           rhoid)
          c1m = temp*(ttm*rhoi)
          temp = mulp + muep/rlmsigmaf
          c1pd = ttp*rhoi*(mulpd+muepd/rlmsigmaf) + temp*(rhoi*ttpd+ttp*&
&           rhoid)
          c1p = temp*(ttp*rhoi)
          c10d = c1md + c1pd
          c10 = c1m + c1p
! and the re_theta_t term.
          muemd = half*(revd(i, j, k-1)+revd(i, j, k))
          muem = half*(rev(i, j, k-1)+rev(i, j, k))
          muepd = half*(revd(i, j, k+1)+revd(i, j, k))
          muep = half*(rev(i, j, k+1)+rev(i, j, k))
          c2md = rlmsigmathetat*(ttm*rhoi*(mulmd+muemd)+(mulm+muem)*(&
&           rhoi*ttmd+ttm*rhoid))
          c2m = ttm*rlmsigmathetat*(mulm+muem)*rhoi
          c2pd = rlmsigmathetat*(ttp*rhoi*(mulpd+muepd)+(mulp+muep)*(&
&           rhoi*ttpd+ttp*rhoid))
          c2p = ttp*rlmsigmathetat*(mulp+muep)*rhoi
          c20d = c2md + c2pd
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          temp = w(i, j, k-1, itransition1)
          temp0 = w(i, j, k+1, itransition1)
          temp1 = w(i, j, k, itransition1)
          scratchd(i, j, k, istransition1) = scratchd(i, j, k, &
&           istransition1) + temp*c1md + c1m*wd(i, j, k-1, itransition1)&
&           + temp0*c1pd + c1p*wd(i, j, k+1, itransition1) - temp1*c10d &
&           - c10*wd(i, j, k, itransition1)
          scratch(i, j, k, istransition1) = scratch(i, j, k, &
&           istransition1) + c1m*temp + c1p*temp0 - c10*temp1
          temp1 = w(i, j, k-1, itransition2)
          temp0 = w(i, j, k+1, itransition2)
          temp = w(i, j, k, itransition2)
          scratchd(i, j, k, istransition2) = scratchd(i, j, k, &
&           istransition2) + temp1*c2md + c2m*wd(i, j, k-1, itransition2&
&           ) + temp0*c2pd + c2p*wd(i, j, k+1, itransition2) - temp*c20d&
&           - c20*wd(i, j, k, itransition2)
          scratch(i, j, k, istransition2) = scratch(i, j, k, &
&           istransition2) + c2m*temp1 + c2p*temp0 - c20*temp
! #ifndef 1
!                         b1 = -c1m
!                         c1 = c10
!                         d1 = -c1p
!                         b2 = -c2m
!                         c2 = c20
!                         d2 = -c2p
!                         ! update the central jacobian. for nonboundary cells this
!                         ! is simply c1 and c2. for boundary cells this is slightly
!                         ! more complicated, because the boundary conditions are
!                         ! treated implicitly and the off-diagonal terms b1, b2 and
!                         ! d1, d2 must be taken into account.
!                         ! the boundary conditions are only treated implicitly if
!                         ! the diagonal dominance of the matrix is increased.
!                         if (k == 2) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - b1 * max(bmtk1(i, j, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - b1 * bmtk1(i, j, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - b2 * bmtk1(i, j, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - b2 * max(bmtk1(i, j, itu2, itu2), zero)
!                         else if (k == kl) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - d1 * max(bmtk2(i, j, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - d1 * bmtk2(i, j, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - d2 * bmtk2(i, j, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - d2 * max(bmtk2(i, j, itu2, itu2), zero)
!                         else
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2
!                         end if
! #endif
        end do
      end do
    end do
!
!       viscous terms in j-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in eta-direction, i.e. along the
! line j = constant.
          temp1 = one/vol(i, j, k)
          volid = -(temp1*vold(i, j, k)/vol(i, j, k))
          voli = temp1
          temp1 = two/(vol(i, j, k)+vol(i, j-1, k))
          volmid = -(temp1*(vold(i, j, k)+vold(i, j-1, k))/(vol(i, j, k)&
&           +vol(i, j-1, k)))
          volmi = temp1
          temp1 = two/(vol(i, j, k)+vol(i, j+1, k))
          volpid = -(temp1*(vold(i, j, k)+vold(i, j+1, k))/(vol(i, j, k)&
&           +vol(i, j+1, k)))
          volpi = temp1
          temp1 = sj(i, j-1, k, 1)
          xmd = volmi*sjd(i, j-1, k, 1) + temp1*volmid
          xm = temp1*volmi
          temp1 = sj(i, j-1, k, 2)
          ymd = volmi*sjd(i, j-1, k, 2) + temp1*volmid
          ym = temp1*volmi
          temp1 = sj(i, j-1, k, 3)
          zmd = volmi*sjd(i, j-1, k, 3) + temp1*volmid
          zm = temp1*volmi
          temp1 = sj(i, j, k, 1)
          xpd = volpi*sjd(i, j, k, 1) + temp1*volpid
          xp = temp1*volpi
          temp1 = sj(i, j, k, 2)
          ypd = volpi*sjd(i, j, k, 2) + temp1*volpid
          yp = temp1*volpi
          temp1 = sj(i, j, k, 3)
          zpd = volpi*sjd(i, j, k, 3) + temp1*volpid
          zp = temp1*volpi
          temp1 = sj(i, j, k, 1) + sj(i, j-1, k, 1)
          xad = half*(voli*(sjd(i, j, k, 1)+sjd(i, j-1, k, 1))+temp1*&
&           volid)
          xa = half*(temp1*voli)
          temp1 = sj(i, j, k, 2) + sj(i, j-1, k, 2)
          yad = half*(voli*(sjd(i, j, k, 2)+sjd(i, j-1, k, 2))+temp1*&
&           volid)
          ya = half*(temp1*voli)
          temp1 = sj(i, j, k, 3) + sj(i, j-1, k, 3)
          zad = half*(voli*(sjd(i, j, k, 3)+sjd(i, j-1, k, 3))+temp1*&
&           volid)
          za = half*(temp1*voli)
          ttmd = xa*xmd + xm*xad + ya*ymd + ym*yad + za*zmd + zm*zad
          ttm = xm*xa + ym*ya + zm*za
          ttpd = xa*xpd + xp*xad + ya*ypd + yp*yad + za*zpd + zp*zad
          ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in eta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in eta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/deta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the gamma-term.
          temp1 = one/w(i, j, k, irho)
          rhoid = -(temp1*wd(i, j, k, irho)/w(i, j, k, irho))
          rhoi = temp1
          mulmd = half*(rlvd(i, j-1, k)+rlvd(i, j, k))
          mulm = half*(rlv(i, j-1, k)+rlv(i, j, k))
          mulpd = half*(rlvd(i, j+1, k)+rlvd(i, j, k))
          mulp = half*(rlv(i, j+1, k)+rlv(i, j, k))
          muemd = half*(revd(i, j-1, k)+revd(i, j, k))
          muem = half*(rev(i, j-1, k)+rev(i, j, k))
          muepd = half*(revd(i, j+1, k)+revd(i, j, k))
          muep = half*(rev(i, j+1, k)+rev(i, j, k))
          temp1 = mulm + muem/rlmsigmaf
          c1md = ttm*rhoi*(mulmd+muemd/rlmsigmaf) + temp1*(rhoi*ttmd+ttm&
&           *rhoid)
          c1m = temp1*(ttm*rhoi)
          temp1 = mulp + muep/rlmsigmaf
          c1pd = ttp*rhoi*(mulpd+muepd/rlmsigmaf) + temp1*(rhoi*ttpd+ttp&
&           *rhoid)
          c1p = temp1*(ttp*rhoi)
          c10d = c1md + c1pd
          c10 = c1m + c1p
! and the re_theta_t term.
          muemd = half*(revd(i, j-1, k)+revd(i, j, k))
          muem = half*(rev(i, j-1, k)+rev(i, j, k))
          muepd = half*(revd(i, j+1, k)+revd(i, j, k))
          muep = half*(rev(i, j+1, k)+rev(i, j, k))
          c2md = rlmsigmathetat*(ttm*rhoi*(mulmd+muemd)+(mulm+muem)*(&
&           rhoi*ttmd+ttm*rhoid))
          c2m = ttm*rlmsigmathetat*(mulm+muem)*rhoi
          c2pd = rlmsigmathetat*(ttp*rhoi*(mulpd+muepd)+(mulp+muep)*(&
&           rhoi*ttpd+ttp*rhoid))
          c2p = ttp*rlmsigmathetat*(mulp+muep)*rhoi
          c20d = c2md + c2pd
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          temp1 = w(i, j-1, k, itransition1)
          temp0 = w(i, j+1, k, itransition1)
          temp = w(i, j, k, itransition1)
          scratchd(i, j, k, istransition1) = scratchd(i, j, k, &
&           istransition1) + temp1*c1md + c1m*wd(i, j-1, k, itransition1&
&           ) + temp0*c1pd + c1p*wd(i, j+1, k, itransition1) - temp*c10d&
&           - c10*wd(i, j, k, itransition1)
          scratch(i, j, k, istransition1) = scratch(i, j, k, &
&           istransition1) + c1m*temp1 + c1p*temp0 - c10*temp
          temp1 = w(i, j-1, k, itransition2)
          temp0 = w(i, j+1, k, itransition2)
          temp = w(i, j, k, itransition2)
          scratchd(i, j, k, istransition2) = scratchd(i, j, k, &
&           istransition2) + temp1*c2md + c2m*wd(i, j-1, k, itransition2&
&           ) + temp0*c2pd + c2p*wd(i, j+1, k, itransition2) - temp*c20d&
&           - c20*wd(i, j, k, itransition2)
          scratch(i, j, k, istransition2) = scratch(i, j, k, &
&           istransition2) + c2m*temp1 + c2p*temp0 - c20*temp
! #ifndef 1
!                         b1 = -c1m
!                         c1 = c10
!                         d1 = -c1p
!                         b2 = -c2m
!                         c2 = c20
!                         d2 = -c2p
!                         ! update the central jacobian. for nonboundary cells this
!                         ! is simply c1 and c2. for boundary cells this is slightly
!                         ! more complicated, because the boundary conditions are
!                         ! treated implicitly and the off-diagonal terms b1, b2 and
!                         ! d1, d2 must be taken into account.
!                         ! the boundary conditions are only treated implicitly if
!                         ! the diagonal dominance of the matrix is increased.
!                         if (j == 2) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - b1 * max(bmtj1(i, k, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - b1 * bmtj1(i, k, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - b2 * bmtj1(i, k, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - b2 * max(bmtj1(i, k, itu2, itu2), zero)
!                         else if (j == jl) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - d1 * max(bmtj2(i, k, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - d1 * bmtj2(i, k, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - d2 * bmtj2(i, k, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - d2 * max(bmtj2(i, k, itu2, itu2), zero)
!                         else
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2
!                         end if
! #endif
        end do
      end do
    end do
!
!       viscous terms in i-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in xi-direction, i.e. along the
! line i = constant.
          temp1 = one/vol(i, j, k)
          volid = -(temp1*vold(i, j, k)/vol(i, j, k))
          voli = temp1
          temp1 = two/(vol(i, j, k)+vol(i-1, j, k))
          volmid = -(temp1*(vold(i, j, k)+vold(i-1, j, k))/(vol(i, j, k)&
&           +vol(i-1, j, k)))
          volmi = temp1
          temp1 = two/(vol(i, j, k)+vol(i+1, j, k))
          volpid = -(temp1*(vold(i, j, k)+vold(i+1, j, k))/(vol(i, j, k)&
&           +vol(i+1, j, k)))
          volpi = temp1
          temp1 = si(i-1, j, k, 1)
          xmd = volmi*sid(i-1, j, k, 1) + temp1*volmid
          xm = temp1*volmi
          temp1 = si(i-1, j, k, 2)
          ymd = volmi*sid(i-1, j, k, 2) + temp1*volmid
          ym = temp1*volmi
          temp1 = si(i-1, j, k, 3)
          zmd = volmi*sid(i-1, j, k, 3) + temp1*volmid
          zm = temp1*volmi
          temp1 = si(i, j, k, 1)
          xpd = volpi*sid(i, j, k, 1) + temp1*volpid
          xp = temp1*volpi
          temp1 = si(i, j, k, 2)
          ypd = volpi*sid(i, j, k, 2) + temp1*volpid
          yp = temp1*volpi
          temp1 = si(i, j, k, 3)
          zpd = volpi*sid(i, j, k, 3) + temp1*volpid
          zp = temp1*volpi
          temp1 = si(i, j, k, 1) + si(i-1, j, k, 1)
          xad = half*(voli*(sid(i, j, k, 1)+sid(i-1, j, k, 1))+temp1*&
&           volid)
          xa = half*(temp1*voli)
          temp1 = si(i, j, k, 2) + si(i-1, j, k, 2)
          yad = half*(voli*(sid(i, j, k, 2)+sid(i-1, j, k, 2))+temp1*&
&           volid)
          ya = half*(temp1*voli)
          temp1 = si(i, j, k, 3) + si(i-1, j, k, 3)
          zad = half*(voli*(sid(i, j, k, 3)+sid(i-1, j, k, 3))+temp1*&
&           volid)
          za = half*(temp1*voli)
          ttmd = xa*xmd + xm*xad + ya*ymd + ym*yad + za*zmd + zm*zad
          ttm = xm*xa + ym*ya + zm*za
          ttpd = xa*xpd + xp*xad + ya*ypd + yp*yad + za*zpd + zp*zad
          ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in xi-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in xi-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dxi derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the gamma-term.
          temp1 = one/w(i, j, k, irho)
          rhoid = -(temp1*wd(i, j, k, irho)/w(i, j, k, irho))
          rhoi = temp1
          mulmd = half*(rlvd(i-1, j, k)+rlvd(i, j, k))
          mulm = half*(rlv(i-1, j, k)+rlv(i, j, k))
          mulpd = half*(rlvd(i+1, j, k)+rlvd(i, j, k))
          mulp = half*(rlv(i+1, j, k)+rlv(i, j, k))
          muemd = half*(revd(i-1, j, k)+revd(i, j, k))
          muem = half*(rev(i-1, j, k)+rev(i, j, k))
          muepd = half*(revd(i+1, j, k)+revd(i, j, k))
          muep = half*(rev(i+1, j, k)+rev(i, j, k))
          temp1 = mulm + muem/rlmsigmaf
          c1md = ttm*rhoi*(mulmd+muemd/rlmsigmaf) + temp1*(rhoi*ttmd+ttm&
&           *rhoid)
          c1m = temp1*(ttm*rhoi)
          temp1 = mulp + muep/rlmsigmaf
          c1pd = ttp*rhoi*(mulpd+muepd/rlmsigmaf) + temp1*(rhoi*ttpd+ttp&
&           *rhoid)
          c1p = temp1*(ttp*rhoi)
          c10d = c1md + c1pd
          c10 = c1m + c1p
! and the re_theta_t term.
          muemd = half*(revd(i-1, j, k)+revd(i, j, k))
          muem = half*(rev(i-1, j, k)+rev(i, j, k))
          muepd = half*(revd(i+1, j, k)+revd(i, j, k))
          muep = half*(rev(i+1, j, k)+rev(i, j, k))
          c2md = rlmsigmathetat*(ttm*rhoi*(mulmd+muemd)+(mulm+muem)*(&
&           rhoi*ttmd+ttm*rhoid))
          c2m = ttm*rlmsigmathetat*(mulm+muem)*rhoi
          c2pd = rlmsigmathetat*(ttp*rhoi*(mulpd+muepd)+(mulp+muep)*(&
&           rhoi*ttpd+ttp*rhoid))
          c2p = ttp*rlmsigmathetat*(mulp+muep)*rhoi
          c20d = c2md + c2pd
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          temp1 = w(i-1, j, k, itransition1)
          temp0 = w(i+1, j, k, itransition1)
          temp = w(i, j, k, itransition1)
          scratchd(i, j, k, istransition1) = scratchd(i, j, k, &
&           istransition1) + temp1*c1md + c1m*wd(i-1, j, k, itransition1&
&           ) + temp0*c1pd + c1p*wd(i+1, j, k, itransition1) - temp*c10d&
&           - c10*wd(i, j, k, itransition1)
          scratch(i, j, k, istransition1) = scratch(i, j, k, &
&           istransition1) + c1m*temp1 + c1p*temp0 - c10*temp
          temp1 = w(i-1, j, k, itransition2)
          temp0 = w(i+1, j, k, itransition2)
          temp = w(i, j, k, itransition2)
          scratchd(i, j, k, istransition2) = scratchd(i, j, k, &
&           istransition2) + temp1*c2md + c2m*wd(i-1, j, k, itransition2&
&           ) + temp0*c2pd + c2p*wd(i+1, j, k, itransition2) - temp*c20d&
&           - c20*wd(i, j, k, itransition2)
          scratch(i, j, k, istransition2) = scratch(i, j, k, &
&           istransition2) + c2m*temp1 + c2p*temp0 - c20*temp
! #ifndef 1
!                         b1 = -c1m
!                         c1 = c10
!                         d1 = -c1p
!                         b2 = -c2m
!                         c2 = c20
!                         d2 = -c2p
!                         ! update the central jacobian. for nonboundary cells this
!                         ! is simply c1 and c2. for boundary cells this is slightly
!                         ! more complicated, because the boundary conditions are
!                         ! treated implicitly and the off-diagonal terms b1, b2 and
!                         ! d1, d2 must be taken into account.
!                         ! the boundary conditions are only treated implicitly if
!                         ! the diagonal dominance of the matrix is increased.
!                         if (i == 2) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - b1 * max(bmti1(j, k, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - b1 * bmti1(j, k, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - b2 * bmti1(j, k, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - b2 * max(bmti1(j, k, itu2, itu2), zero)
!                         else if (i == il) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - d1 * max(bmti2(j, k, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - d1 * bmti2(j, k, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - d2 * bmti2(j, k, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - d2 * max(bmti2(j, k, itu2, itu2), zero)
!                         else
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2
!                         end if
! #endif
        end do
      end do
    end do
  end subroutine gammarethetaviscous_d

  subroutine gammarethetaviscous()
    use blockpointers
    use constants
    use variableconstants
    use paramturb
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rhoi
    real(kind=realtype) :: voli, volmi, volpi
    real(kind=realtype) :: xm, ym, zm, xp, yp, zp, xa, ya, za
    real(kind=realtype) :: mulm, mulp, muem, muep
    real(kind=realtype) :: ttm, ttp
    real(kind=realtype) :: c1m, c1p, c10, c2m, c2p, c20
    real(kind=realtype) :: rblank
!       advection and unsteady terms.
!
!
!       viscous terms in k-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in zeta-direction, i.e. along the
! line k = constant.
          voli = one/vol(i, j, k)
          volmi = two/(vol(i, j, k)+vol(i, j, k-1))
          volpi = two/(vol(i, j, k)+vol(i, j, k+1))
          xm = sk(i, j, k-1, 1)*volmi
          ym = sk(i, j, k-1, 2)*volmi
          zm = sk(i, j, k-1, 3)*volmi
          xp = sk(i, j, k, 1)*volpi
          yp = sk(i, j, k, 2)*volpi
          zp = sk(i, j, k, 3)*volpi
          xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
          ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
          za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
          ttm = xm*xa + ym*ya + zm*za
          ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in zeta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in zeta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dzeta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the gamma-term.
          rhoi = one/w(i, j, k, irho)
          mulm = half*(rlv(i, j, k-1)+rlv(i, j, k))
          mulp = half*(rlv(i, j, k+1)+rlv(i, j, k))
          muem = half*(rev(i, j, k-1)+rev(i, j, k))
          muep = half*(rev(i, j, k+1)+rev(i, j, k))
          c1m = ttm*(mulm+muem/rlmsigmaf)*rhoi
          c1p = ttp*(mulp+muep/rlmsigmaf)*rhoi
          c10 = c1m + c1p
! and the re_theta_t term.
          muem = half*(rev(i, j, k-1)+rev(i, j, k))
          muep = half*(rev(i, j, k+1)+rev(i, j, k))
          c2m = ttm*rlmsigmathetat*(mulm+muem)*rhoi
          c2p = ttp*rlmsigmathetat*(mulp+muep)*rhoi
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          scratch(i, j, k, istransition1) = scratch(i, j, k, &
&           istransition1) + c1m*w(i, j, k-1, itransition1) - c10*w(i, j&
&           , k, itransition1) + c1p*w(i, j, k+1, itransition1)
          scratch(i, j, k, istransition2) = scratch(i, j, k, &
&           istransition2) + c2m*w(i, j, k-1, itransition2) - c20*w(i, j&
&           , k, itransition2) + c2p*w(i, j, k+1, itransition2)
! #ifndef 1
!                         b1 = -c1m
!                         c1 = c10
!                         d1 = -c1p
!                         b2 = -c2m
!                         c2 = c20
!                         d2 = -c2p
!                         ! update the central jacobian. for nonboundary cells this
!                         ! is simply c1 and c2. for boundary cells this is slightly
!                         ! more complicated, because the boundary conditions are
!                         ! treated implicitly and the off-diagonal terms b1, b2 and
!                         ! d1, d2 must be taken into account.
!                         ! the boundary conditions are only treated implicitly if
!                         ! the diagonal dominance of the matrix is increased.
!                         if (k == 2) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - b1 * max(bmtk1(i, j, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - b1 * bmtk1(i, j, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - b2 * bmtk1(i, j, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - b2 * max(bmtk1(i, j, itu2, itu2), zero)
!                         else if (k == kl) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - d1 * max(bmtk2(i, j, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - d1 * bmtk2(i, j, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - d2 * bmtk2(i, j, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - d2 * max(bmtk2(i, j, itu2, itu2), zero)
!                         else
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2
!                         end if
! #endif
        end do
      end do
    end do
!
!       viscous terms in j-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in eta-direction, i.e. along the
! line j = constant.
          voli = one/vol(i, j, k)
          volmi = two/(vol(i, j, k)+vol(i, j-1, k))
          volpi = two/(vol(i, j, k)+vol(i, j+1, k))
          xm = sj(i, j-1, k, 1)*volmi
          ym = sj(i, j-1, k, 2)*volmi
          zm = sj(i, j-1, k, 3)*volmi
          xp = sj(i, j, k, 1)*volpi
          yp = sj(i, j, k, 2)*volpi
          zp = sj(i, j, k, 3)*volpi
          xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
          ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
          za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
          ttm = xm*xa + ym*ya + zm*za
          ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in eta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in eta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/deta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the gamma-term.
          rhoi = one/w(i, j, k, irho)
          mulm = half*(rlv(i, j-1, k)+rlv(i, j, k))
          mulp = half*(rlv(i, j+1, k)+rlv(i, j, k))
          muem = half*(rev(i, j-1, k)+rev(i, j, k))
          muep = half*(rev(i, j+1, k)+rev(i, j, k))
          c1m = ttm*(mulm+muem/rlmsigmaf)*rhoi
          c1p = ttp*(mulp+muep/rlmsigmaf)*rhoi
          c10 = c1m + c1p
! and the re_theta_t term.
          muem = half*(rev(i, j-1, k)+rev(i, j, k))
          muep = half*(rev(i, j+1, k)+rev(i, j, k))
          c2m = ttm*rlmsigmathetat*(mulm+muem)*rhoi
          c2p = ttp*rlmsigmathetat*(mulp+muep)*rhoi
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          scratch(i, j, k, istransition1) = scratch(i, j, k, &
&           istransition1) + c1m*w(i, j-1, k, itransition1) - c10*w(i, j&
&           , k, itransition1) + c1p*w(i, j+1, k, itransition1)
          scratch(i, j, k, istransition2) = scratch(i, j, k, &
&           istransition2) + c2m*w(i, j-1, k, itransition2) - c20*w(i, j&
&           , k, itransition2) + c2p*w(i, j+1, k, itransition2)
! #ifndef 1
!                         b1 = -c1m
!                         c1 = c10
!                         d1 = -c1p
!                         b2 = -c2m
!                         c2 = c20
!                         d2 = -c2p
!                         ! update the central jacobian. for nonboundary cells this
!                         ! is simply c1 and c2. for boundary cells this is slightly
!                         ! more complicated, because the boundary conditions are
!                         ! treated implicitly and the off-diagonal terms b1, b2 and
!                         ! d1, d2 must be taken into account.
!                         ! the boundary conditions are only treated implicitly if
!                         ! the diagonal dominance of the matrix is increased.
!                         if (j == 2) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - b1 * max(bmtj1(i, k, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - b1 * bmtj1(i, k, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - b2 * bmtj1(i, k, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - b2 * max(bmtj1(i, k, itu2, itu2), zero)
!                         else if (j == jl) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - d1 * max(bmtj2(i, k, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - d1 * bmtj2(i, k, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - d2 * bmtj2(i, k, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - d2 * max(bmtj2(i, k, itu2, itu2), zero)
!                         else
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2
!                         end if
! #endif
        end do
      end do
    end do
!
!       viscous terms in i-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in xi-direction, i.e. along the
! line i = constant.
          voli = one/vol(i, j, k)
          volmi = two/(vol(i, j, k)+vol(i-1, j, k))
          volpi = two/(vol(i, j, k)+vol(i+1, j, k))
          xm = si(i-1, j, k, 1)*volmi
          ym = si(i-1, j, k, 2)*volmi
          zm = si(i-1, j, k, 3)*volmi
          xp = si(i, j, k, 1)*volpi
          yp = si(i, j, k, 2)*volpi
          zp = si(i, j, k, 3)*volpi
          xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
          ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
          za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
          ttm = xm*xa + ym*ya + zm*za
          ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in xi-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in xi-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dxi derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the gamma-term.
          rhoi = one/w(i, j, k, irho)
          mulm = half*(rlv(i-1, j, k)+rlv(i, j, k))
          mulp = half*(rlv(i+1, j, k)+rlv(i, j, k))
          muem = half*(rev(i-1, j, k)+rev(i, j, k))
          muep = half*(rev(i+1, j, k)+rev(i, j, k))
          c1m = ttm*(mulm+muem/rlmsigmaf)*rhoi
          c1p = ttp*(mulp+muep/rlmsigmaf)*rhoi
          c10 = c1m + c1p
! and the re_theta_t term.
          muem = half*(rev(i-1, j, k)+rev(i, j, k))
          muep = half*(rev(i+1, j, k)+rev(i, j, k))
          c2m = ttm*rlmsigmathetat*(mulm+muem)*rhoi
          c2p = ttp*rlmsigmathetat*(mulp+muep)*rhoi
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          scratch(i, j, k, istransition1) = scratch(i, j, k, &
&           istransition1) + c1m*w(i-1, j, k, itransition1) - c10*w(i, j&
&           , k, itransition1) + c1p*w(i+1, j, k, itransition1)
          scratch(i, j, k, istransition2) = scratch(i, j, k, &
&           istransition2) + c2m*w(i-1, j, k, itransition2) - c20*w(i, j&
&           , k, itransition2) + c2p*w(i+1, j, k, itransition2)
! #ifndef 1
!                         b1 = -c1m
!                         c1 = c10
!                         d1 = -c1p
!                         b2 = -c2m
!                         c2 = c20
!                         d2 = -c2p
!                         ! update the central jacobian. for nonboundary cells this
!                         ! is simply c1 and c2. for boundary cells this is slightly
!                         ! more complicated, because the boundary conditions are
!                         ! treated implicitly and the off-diagonal terms b1, b2 and
!                         ! d1, d2 must be taken into account.
!                         ! the boundary conditions are only treated implicitly if
!                         ! the diagonal dominance of the matrix is increased.
!                         if (i == 2) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - b1 * max(bmti1(j, k, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - b1 * bmti1(j, k, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - b2 * bmti1(j, k, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - b2 * max(bmti1(j, k, itu2, itu2), zero)
!                         else if (i == il) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - d1 * max(bmti2(j, k, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - d1 * bmti2(j, k, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - d2 * bmti2(j, k, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - d2 * max(bmti2(j, k, itu2, itu2), zero)
!                         else
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2
!                         end if
! #endif
        end do
      end do
    end do
  end subroutine gammarethetaviscous

!  differentiation of gammarethetaresscale in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *dw
!   with respect to varying inputs: *dw *scratch
!   rw status of diff variables: *dw:in-out *scratch:in
!   plus diff mem management of: dw:in scratch:in
  subroutine gammarethetaresscale_d()
    use blockpointers
    use constants
    use variableconstants
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rblank
    intrinsic real
    real(kind=realtype) :: temp
! multiply the residual by the volume and store this in dw; this
! is done for monitoring reasons only. the multiplication with the
! volume is present to be consistent with the flow residuals; also
! the negative value is taken, again to be consistent with the
! flow equations. also multiply by iblank so that no updates occur
! in holes or the overset boundary.
    do k=2,kl
      do j=2,jl
        do i=2,il
          rblank = real(iblank(i, j, k), realtype)
          temp = volref(i, j, k)*rblank
          dwd(i, j, k, itransition1) = -(temp*scratchd(i, j, k, &
&           istransition1))
          dw(i, j, k, itransition1) = -(temp*scratch(i, j, k, &
&           istransition1))
          temp = volref(i, j, k)*rblank
          dwd(i, j, k, itransition2) = -(temp*scratchd(i, j, k, &
&           istransition2))
          dw(i, j, k, itransition2) = -(temp*scratch(i, j, k, &
&           istransition2))
! print *, 'dw transition 1 & 2', dw(i, j, k, itransition1), dw(i, j, k, itransition2)
        end do
      end do
    end do
  end subroutine gammarethetaresscale_d

  subroutine gammarethetaresscale()
    use blockpointers
    use constants
    use variableconstants
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rblank
    intrinsic real
! multiply the residual by the volume and store this in dw; this
! is done for monitoring reasons only. the multiplication with the
! volume is present to be consistent with the flow residuals; also
! the negative value is taken, again to be consistent with the
! flow equations. also multiply by iblank so that no updates occur
! in holes or the overset boundary.
    do k=2,kl
      do j=2,jl
        do i=2,il
          rblank = real(iblank(i, j, k), realtype)
          dw(i, j, k, itransition1) = -(volref(i, j, k)*scratch(i, j, k&
&           , istransition1)*rblank)
          dw(i, j, k, itransition2) = -(volref(i, j, k)*scratch(i, j, k&
&           , istransition2)*rblank)
! print *, 'dw transition 1 & 2', dw(i, j, k, itransition1), dw(i, j, k, itransition2)
        end do
      end do
    end do
  end subroutine gammarethetaresscale

end module gammarethetamodel_d

