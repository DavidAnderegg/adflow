!        generated by tapenade     (inria, ecuador team)
!  tapenade 3.16 (develop) - 10 nov 2023 18:24
!
module gammarethetamodel_d
  use constants
  implicit none

contains
  subroutine solve_local_re_thetat_eq(re_thetat_eq, i, j, k)
    use blockpointers
    use constants
    use paramturb
    implicit none
! input/output variables
    integer(kind=inttype), intent(in) :: i, j, k
    real(kind=realtype), intent(out) :: re_thetat_eq
! local variables
    real(kind=realtype) :: u, u_inv, fact, du_dx, du_dy, du_dz, du_ds, &
&   tu, f1, f2, f3, f
    real(kind=realtype) :: dudx, dudy, dudz, dvdx, dvdy, dvdz, dwdx, &
&   dwdy, dwdz
    real(kind=realtype) :: lambda, thetat, residum, thetat_old, &
&   residum_old, thetat_new
    real(kind=realtype) :: re_thetat_eq_1, re_thetat_eq_2
    integer(kind=inttype) :: n
    intrinsic sqrt
    intrinsic exp
    intrinsic max
    intrinsic min
    intrinsic abs
    real(kind=realtype) :: abs0
    real(kind=realtype) :: arg1
    real(kind=realtype) :: result1
    arg1 = w(i, j, k, ivx)**2 + w(i, j, k, ivy)**2 + w(i, j, k, ivz)**2
    u = sqrt(arg1)
    u_inv = 1.0/u
! compute the gradient of u in the cell center. use is made
! of the fact that the surrounding normals sum up to zero,
! such that the cell i,j,k does not give a contribution.
! since the gradient is scaled by a factor of 2*vol, we need to account for that
    fact = 1.0/(vol(i, j, k)*2.0)
    dudx = (w(i+1, j, k, ivx)*si(i, j, k, 1)-w(i-1, j, k, ivx)*si(i-1, j&
&     , k, 1)+w(i, j+1, k, ivx)*sj(i, j, k, 1)-w(i, j-1, k, ivx)*sj(i, j&
&     -1, k, 1)+w(i, j, k+1, ivx)*sk(i, j, k, 1)-w(i, j, k-1, ivx)*sk(i&
&     , j, k-1, 1))*fact
    dudy = (w(i+1, j, k, ivx)*si(i, j, k, 2)-w(i-1, j, k, ivx)*si(i-1, j&
&     , k, 2)+w(i, j+1, k, ivx)*sj(i, j, k, 2)-w(i, j-1, k, ivx)*sj(i, j&
&     -1, k, 2)+w(i, j, k+1, ivx)*sk(i, j, k, 2)-w(i, j, k-1, ivx)*sk(i&
&     , j, k-1, 2))*fact
    dudz = (w(i+1, j, k, ivx)*si(i, j, k, 3)-w(i-1, j, k, ivx)*si(i-1, j&
&     , k, 3)+w(i, j+1, k, ivx)*sj(i, j, k, 3)-w(i, j-1, k, ivx)*sj(i, j&
&     -1, k, 3)+w(i, j, k+1, ivx)*sk(i, j, k, 3)-w(i, j, k-1, ivx)*sk(i&
&     , j, k-1, 3))*fact
! idem for the gradient of v.
    dvdx = (w(i+1, j, k, ivy)*si(i, j, k, 1)-w(i-1, j, k, ivy)*si(i-1, j&
&     , k, 1)+w(i, j+1, k, ivy)*sj(i, j, k, 1)-w(i, j-1, k, ivy)*sj(i, j&
&     -1, k, 1)+w(i, j, k+1, ivy)*sk(i, j, k, 1)-w(i, j, k-1, ivy)*sk(i&
&     , j, k-1, 1))*fact
    dvdy = (w(i+1, j, k, ivy)*si(i, j, k, 2)-w(i-1, j, k, ivy)*si(i-1, j&
&     , k, 2)+w(i, j+1, k, ivy)*sj(i, j, k, 2)-w(i, j-1, k, ivy)*sj(i, j&
&     -1, k, 2)+w(i, j, k+1, ivy)*sk(i, j, k, 2)-w(i, j, k-1, ivy)*sk(i&
&     , j, k-1, 2))*fact
    dvdz = (w(i+1, j, k, ivy)*si(i, j, k, 3)-w(i-1, j, k, ivy)*si(i-1, j&
&     , k, 3)+w(i, j+1, k, ivy)*sj(i, j, k, 3)-w(i, j-1, k, ivy)*sj(i, j&
&     -1, k, 3)+w(i, j, k+1, ivy)*sk(i, j, k, 3)-w(i, j, k-1, ivy)*sk(i&
&     , j, k-1, 3))*fact
! and for the gradient of w.
    dwdx = (w(i+1, j, k, ivz)*si(i, j, k, 1)-w(i-1, j, k, ivz)*si(i-1, j&
&     , k, 1)+w(i, j+1, k, ivz)*sj(i, j, k, 1)-w(i, j-1, k, ivz)*sj(i, j&
&     -1, k, 1)+w(i, j, k+1, ivz)*sk(i, j, k, 1)-w(i, j, k-1, ivz)*sk(i&
&     , j, k-1, 1))*fact
    dwdy = (w(i+1, j, k, ivz)*si(i, j, k, 2)-w(i-1, j, k, ivz)*si(i-1, j&
&     , k, 2)+w(i, j+1, k, ivz)*sj(i, j, k, 2)-w(i, j-1, k, ivz)*sj(i, j&
&     -1, k, 2)+w(i, j, k+1, ivz)*sk(i, j, k, 2)-w(i, j, k-1, ivz)*sk(i&
&     , j, k-1, 2))*fact
    dwdz = (w(i+1, j, k, ivz)*si(i, j, k, 3)-w(i-1, j, k, ivz)*si(i-1, j&
&     , k, 3)+w(i, j+1, k, ivz)*sj(i, j, k, 3)-w(i, j-1, k, ivz)*sj(i, j&
&     -1, k, 3)+w(i, j, k+1, ivz)*sk(i, j, k, 3)-w(i, j, k-1, ivz)*sk(i&
&     , j, k-1, 3))*fact
    du_dx = u_inv*(w(i, j, k, ivx)*dudx+w(i, j, k, ivy)*dudy+w(i, j, k, &
&     ivz)*dudz)
    du_dy = u_inv*(w(i, j, k, ivx)*dvdx+w(i, j, k, ivy)*dvdy+w(i, j, k, &
&     ivz)*dvdz)
    du_dz = u_inv*(w(i, j, k, ivx)*dwdx+w(i, j, k, ivy)*dwdy+w(i, j, k, &
&     ivz)*dwdz)
    du_ds = w(i, j, k, ivx)/u*du_dx + w(i, j, k, ivy)/u*du_dy + w(i, j, &
&     k, ivz)/u*du_dz
    arg1 = 2*w(i, j, k, itu1)/3
    result1 = sqrt(arg1)
    tu = 100.0*result1/u
! tu = max(tu, 0.027) ! clip for numerical robustness
! now we need to solve for theta through newton's method. the number of iterations is hard-coded so tapenade is 
! able to differentiate it
    thetat = 0.01
    do n=1,10
      lambda = w(i, j, k, irho)*thetat**2/rlv(i, j, k)*du_ds
! lambda = max(min(lambda, 0.1), -0.1) ! clip for numerical robustness
! compute f function
      f1 = 1.0 + 0.275*(1.0-exp(-(35.0*lambda)))*exp(-(tu/0.5))
      if (f1 .lt. 1.0) then
        f2 = 1.0
      else
        f2 = f1
      end if
      arg1 = -((tu/1.5)**1.5)
      f3 = 1.0 - (-(12.986*lambda)-123.66*lambda**2-405.689*lambda**3)*&
&       exp(arg1)
      if (f2 .gt. f3) then
        f = f3
      else
        f = f2
      end if
      if (tu .gt. 1.3) then
        re_thetat_eq_1 = 331.50*(tu-0.5658)**(-0.671)*f
      else
        re_thetat_eq_1 = (1173.51-589.428*tu+0.2196*tu**(-2))*f
      end if
      re_thetat_eq_2 = w(i, j, k, irho)*u*thetat/rlv(i, j, k)
! residum which should go to 0
      residum = re_thetat_eq_1 - re_thetat_eq_2
! print *, 'iteration, thetat, residum, re_thetat_eq_1', n, thetat, residum, re_thetat_eq_1
! if we are in the first iteration, we need to kickstart the secant method first
      if (n .eq. 1) then
        residum_old = residum
        thetat_old = thetat
        thetat = 0.5*thetat
      else
        if (residum .ge. 0.) then
          abs0 = residum
        else
          abs0 = -residum
        end if
! if the residum is basically 0, we cycle until we reach the end. (we cant drop out because tapenade would be unable to
! differentiate it)
        if (abs0 .gt. 1e-9) then
! cycle
          thetat_new = (thetat_old*residum-thetat*residum_old)/(residum-&
&           residum_old)
        else
          thetat_new = thetat
        end if
! compute next step (secant method)
! thetat_new = (thetat_old*residum - thetat*residum_old) / (residum - residum_old)
! save values for next iteration
        residum_old = residum
        thetat_old = thetat
        thetat = thetat_new
! todo: make sure this still works after getting rid of 'cycle'
      end if
    end do
! save result in output-variable
! re_thetat_eq = max(re_thetat_eq_1, 20.0) ! clip for numerical robustness
! print *, 'thetat, lambda, re_thetat_eq', thetat, lambda, re_thetat_eq

  end subroutine solve_local_re_thetat_eq

!  differentiation of gammarethetasource in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *scratch
!   with respect to varying inputs: *rev *w *rlv *scratch *d2wall
!   rw status of diff variables: *rev:in *w:in *rlv:in *scratch:in-out
!                *d2wall:in
!   plus diff mem management of: rev:in w:in rlv:in scratch:in
!                d2wall:in
  subroutine gammarethetasource_d()
    use blockpointers
    use constants
    use variableconstants
    use paramturb
    implicit none
    integer(kind=inttype) :: i, j, k
    real(kind=realtype) :: re_thetat_eq, u2, u, lambda_theta, delta, &
&   f_theta_t, t, r_t, re_theta_c
    real(kind=realtype) :: u2d, ud, deltad, f_theta_td, td, r_td, &
&   re_theta
    real(kind=realtype) :: re_s, f_length1, f_length, f_onset1, f_onset&
&   , f_turb, p_gamma, e_gamma, p_thetat
    real(kind=realtype) :: re_sd, f_length1d, f_lengthd, f_onset1d, &
&   f_onsetd, f_turbd, p_gammad, e_gammad, p_thetatd
    real(kind=realtype) :: re_omega, f_wake
    real(kind=realtype) :: re_omegad, f_waked
    real(kind=realtype) :: rhoi, vort
    real(kind=realtype) :: rhoid, vortd
    intrinsic sqrt
    intrinsic max
    intrinsic exp
    intrinsic min
    intrinsic sin
    intrinsic tanh
    real(kind=realtype) :: x1
    real(kind=realtype) :: x1d
    real(kind=realtype) :: x2
    real(kind=realtype) :: x2d
    real(kind=realtype) :: x3
    real(kind=realtype) :: x3d
    real(kind=realtype) :: arg1
    real(kind=realtype) :: arg1d
    real(kind=realtype) :: result1
    real(kind=realtype) :: result1d
    real(kind=realtype) :: result2
    real(kind=realtype) :: result2d
    real(kind=realtype) :: temp
    real(kind=realtype) :: temp0
    real(kind=realtype) :: temp1
    real(kind=realtype) :: temp2
    real(kind=realtype) :: temp3
    real(kind=realtype) :: tempd
    do k=2,kl
      do j=2,jl
        do i=2,il
          temp = one/w(i, j, k, irho)
          rhoid = -(temp*wd(i, j, k, irho)/w(i, j, k, irho))
          rhoi = temp
          temp = scratch(i, j, k, ivorticity)
          temp0 = sqrt(temp)
          if (temp .eq. 0.0_8) then
            x1d = 0.0_8
          else
            x1d = scratchd(i, j, k, ivorticity)/(2.0*temp0)
          end if
          x1 = temp0
          if (x1 .lt. eps) then
            vort = eps
            vortd = 0.0_8
          else
            vortd = x1d
            vort = x1
          end if
! compute re_thetat_eq
          call solve_local_re_thetat_eq(re_thetat_eq, i, j, k)
          temp0 = w(i, j, k, ivx)
          temp = w(i, j, k, ivy)
          temp1 = w(i, j, k, ivz)
          u2d = 2*temp0*wd(i, j, k, ivx) + 2*temp*wd(i, j, k, ivy) + 2*&
&           temp1*wd(i, j, k, ivz)
          u2 = temp0*temp0 + temp*temp + temp1*temp1
          temp1 = sqrt(u2)
          if (u2 .eq. 0.0_8) then
            ud = 0.0_8
          else
            ud = u2d/(2.0*temp1)
          end if
          u = temp1
          temp1 = d2wall(i, j, k)
          temp0 = w(i, j, k, itu2)
          temp = temp0*(temp1*temp1)
          temp2 = w(i, j, k, irho)/rlv(i, j, k)
          re_omegad = temp*(wd(i, j, k, irho)-temp2*rlvd(i, j, k))/rlv(i&
&           , j, k) + temp2*(temp1**2*wd(i, j, k, itu2)+temp0*2*temp1*&
&           d2walld(i, j, k))
          re_omega = temp2*temp
          arg1d = -(2*re_omega*re_omegad/1e5**2)
          arg1 = -((re_omega/1e5)**2)
          f_waked = exp(arg1)*arg1d
          f_wake = exp(arg1)
          temp2 = w(i, j, k, irho)
          temp1 = d2wall(i, j, k)
          temp0 = w(i, j, k, itransition2)
          temp = temp0*vort*temp1/(temp2*u)
          deltad = 375.0*(vort*temp1*wd(i, j, k, itransition2)+temp0*(&
&           temp1*vortd+vort*d2walld(i, j, k))-temp*(u*wd(i, j, k, irho)&
&           +temp2*ud))/(temp2*u)
          delta = 375.0*temp
          temp2 = d2wall(i, j, k)/delta
          arg1d = -(4*temp2**3*(d2walld(i, j, k)-temp2*deltad)/delta)
          arg1 = -(temp2**4)
          temp2 = exp(arg1)
          x3d = temp2*f_waked + f_wake*exp(arg1)*arg1d
          x3 = f_wake*temp2
          if (x3 .lt. 1.0 - ((rlmce2*w(i, j, k, itransition1)-1.0)/(&
&             rlmce2-1))**2) then
            temp2 = (rlmce2*w(i, j, k, itransition1)-1.0)/(rlmce2-1)
            x2d = -(2*temp2*rlmce2*wd(i, j, k, itransition1)/(rlmce2-1))
            x2 = 1.0 - temp2*temp2
          else
            x2d = x3d
            x2 = x3
          end if
          if (x2 .gt. 1.0) then
            f_theta_t = 1.0
            f_theta_td = 0.0_8
          else
            f_theta_td = x2d
            f_theta_t = x2
          end if
          temp2 = w(i, j, k, irho)
          temp1 = rlv(i, j, k)/(temp2*u2)
          td = 500.0*(rlvd(i, j, k)-temp1*(u2*wd(i, j, k, irho)+temp2*&
&           u2d))/(temp2*u2)
          t = 500.0*temp1
! todo: save this in scratch
          temp2 = w(i, j, k, itu2)
          temp1 = rlv(i, j, k)*temp2
          temp0 = w(i, j, k, itu1)
          temp = w(i, j, k, irho)
          temp3 = temp*temp0/temp1
          r_td = (temp0*wd(i, j, k, irho)+temp*wd(i, j, k, itu1)-temp3*(&
&           temp2*rlvd(i, j, k)+rlv(i, j, k)*wd(i, j, k, itu2)))/temp1
          r_t = temp3
! todo: save this in scratch
          arg1d = wd(i, j, k, itransition2)/240.0
          arg1 = w(i, j, k, itransition2)/240.0 + 0.5
          re_theta = 0.67*wd(i, j, k, itransition2) + 24.0*cos(arg1)*&
&           arg1d
          re_theta_c = 0.67*w(i, j, k, itransition2) + 24.0*sin(arg1) + &
&           14.0
! todo: save this in scratch
          temp3 = scratch(i, j, k, istrain)
          temp2 = sqrt(temp3)
          if (temp3 .eq. 0.0_8) then
            result1d = 0.0_8
          else
            result1d = scratchd(i, j, k, istrain)/(2.0*temp2)
          end if
          result1 = temp2
          temp3 = result1/rev(i, j, k)
          temp2 = d2wall(i, j, k)
          temp1 = w(i, j, k, irho)
          temp0 = temp1*(temp2*temp2)
          re_sd = temp3*(temp2**2*wd(i, j, k, irho)+temp1*2*temp2*&
&           d2walld(i, j, k)) + temp0*(result1d-temp3*revd(i, j, k))/rev&
&           (i, j, k)
          re_s = temp0*temp3
          temp3 = -(0.03*(w(i, j, k, itransition2)-460.0))
          f_length1d = -(exp(temp3)*0.03*wd(i, j, k, itransition2))
          f_length1 = exp(temp3)
          temp3 = (f_length1+1)**(1.0/6)
          temp2 = (30000.0*(w(i, j, k, itransition2)-596.0)+43.5)/temp3
          if (f_length1 + 1 .le. 0.0_8 .and. (1.0/6 .eq. 0.0_8 .or. 1.0/&
&             6 .ne. int(1.0/6))) then
            tempd = 0.0_8
          else
            tempd = (f_length1+1)**(1.0/6-1)*f_length1d/6
          end if
          f_lengthd = -((30000.0*wd(i, j, k, itransition2)-temp2*tempd)/&
&           temp3)
          f_length = 44.0 - temp2
! continue here
          temp3 = re_s/(2.6*re_theta_c)
          arg1d = (re_sd-temp3*2.6*re_theta)/(2.6*re_theta_c)
          arg1 = temp3
          temp3 = sqrt(arg1)
          if (arg1 .eq. 0.0_8) then
            f_onset1d = 0.0_8
          else
            f_onset1d = arg1d/(2.0*temp3)
          end if
          f_onset1 = temp3
          f_onsetd = (1.0-tanh(6.0*(f_onset1-1.35))**2)*6.0*f_onset1d/&
&           2.0
          f_onset = (tanh(6.0*(f_onset1-1.35))+1.0)/2.0
          temp3 = exp(-r_t)
          f_turbd = -(temp3*f_onsetd) - (1-f_onset)*exp(-r_t)*r_td
          f_turb = (1-f_onset)*temp3
! since we need to divide by rho, rho does not appear here anymore
          temp3 = scratch(i, j, k, istrain)
          temp2 = sqrt(temp3)
          if (temp3 .eq. 0.0_8) then
            result1d = 0.0_8
          else
            result1d = scratchd(i, j, k, istrain)/(2.0*temp2)
          end if
          result1 = temp2
          temp3 = w(i, j, k, itransition1)
          arg1d = f_onset*wd(i, j, k, itransition1) + temp3*f_onsetd
          arg1 = temp3*f_onset
          temp3 = sqrt(arg1)
          if (arg1 .eq. 0.0_8) then
            result2d = 0.0_8
          else
            result2d = arg1d/(2.0*temp3)
          end if
          result2 = temp3
          temp3 = -(rlmce1*w(i, j, k, itransition1)) + 1.0
          temp2 = f_length*result1*result2
          temp1 = w(i, j, k, irho)
          temp0 = temp1*temp2
          p_gammad = rlmca1*(temp3*(temp2*wd(i, j, k, irho)+temp1*(&
&           result2*(result1*f_lengthd+f_length*result1d)+f_length*&
&           result1*result2d))-temp0*rlmce1*wd(i, j, k, itransition1))
          p_gamma = rlmca1*(temp0*temp3)
          temp3 = rlmce2*w(i, j, k, itransition1) - 1.0
          temp2 = w(i, j, k, itransition1)
          temp1 = w(i, j, k, irho)
          temp0 = temp1*vort*f_turb
          e_gammad = rlmca2*(temp2*temp3*(vort*f_turb*wd(i, j, k, irho)+&
&           temp1*(f_turb*vortd+vort*f_turbd))+temp0*(temp3+temp2*rlmce2&
&           )*wd(i, j, k, itransition1))
          e_gamma = rlmca2*(temp0*(temp2*temp3))
! somewhere here is the problem regarding partials not matching
          temp3 = re_thetat_eq - w(i, j, k, itransition2)
          temp2 = (-f_theta_t+1.0)/t
          temp1 = w(i, j, k, irho)
          p_thetatd = rlmcthetat*(temp3*(temp2*wd(i, j, k, irho)+temp1*(&
&           -f_theta_td-temp2*td)/t)-temp1*temp2*wd(i, j, k, &
&           itransition2))
          p_thetat = rlmcthetat*(temp1*temp2*temp3)
          scratchd(i, j, k, istransition1) = rhoi*(p_gammad-e_gammad) + &
&           (p_gamma-e_gamma)*rhoid
          scratch(i, j, k, istransition1) = (p_gamma-e_gamma)*rhoi
          scratchd(i, j, k, istransition2) = rhoi*p_thetatd + p_thetat*&
&           rhoid
          scratch(i, j, k, istransition2) = p_thetat*rhoi
! print *, 'source terms: gamma, thetat', scratch(i, j, k, istransition1), scratch(i, j, k, istransition2)
        end do
      end do
    end do
  end subroutine gammarethetasource_d

  subroutine gammarethetasource()
    use blockpointers
    use constants
    use variableconstants
    use paramturb
    implicit none
    integer(kind=inttype) :: i, j, k
    real(kind=realtype) :: re_thetat_eq, u2, u, lambda_theta, delta, &
&   f_theta_t, t, r_t, re_theta_c
    real(kind=realtype) :: re_s, f_length1, f_length, f_onset1, f_onset&
&   , f_turb, p_gamma, e_gamma, p_thetat
    real(kind=realtype) :: re_omega, f_wake
    real(kind=realtype) :: rhoi, vort
    intrinsic sqrt
    intrinsic max
    intrinsic exp
    intrinsic min
    intrinsic sin
    intrinsic tanh
    real(kind=realtype) :: x1
    real(kind=realtype) :: x2
    real(kind=realtype) :: x3
    real(kind=realtype) :: arg1
    real(kind=realtype) :: result1
    real(kind=realtype) :: result2
    do k=2,kl
      do j=2,jl
        do i=2,il
          rhoi = one/w(i, j, k, irho)
          x1 = sqrt(scratch(i, j, k, ivorticity))
          if (x1 .lt. eps) then
            vort = eps
          else
            vort = x1
          end if
! compute re_thetat_eq
          call solve_local_re_thetat_eq(re_thetat_eq, i, j, k)
          u2 = w(i, j, k, ivx)**2 + w(i, j, k, ivy)**2 + w(i, j, k, ivz)&
&           **2
          u = sqrt(u2)
          re_omega = w(i, j, k, irho)*w(i, j, k, itu2)*d2wall(i, j, k)**&
&           2/rlv(i, j, k)
          arg1 = -((re_omega/1e5)**2)
          f_wake = exp(arg1)
          delta = 375.0*vort*w(i, j, k, itransition2)*d2wall(i, j, k)/(w&
&           (i, j, k, irho)*u)
          arg1 = -((d2wall(i, j, k)/delta)**4)
          x3 = f_wake*exp(arg1)
          if (x3 .lt. 1.0 - ((rlmce2*w(i, j, k, itransition1)-1.0)/(&
&             rlmce2-1))**2) then
            x2 = 1.0 - ((rlmce2*w(i, j, k, itransition1)-1.0)/(rlmce2-1)&
&             )**2
          else
            x2 = x3
          end if
          if (x2 .gt. 1.0) then
            f_theta_t = 1.0
          else
            f_theta_t = x2
          end if
          t = 500.0*rlv(i, j, k)/(w(i, j, k, irho)*u2)
! todo: save this in scratch
          r_t = w(i, j, k, irho)*w(i, j, k, itu1)/(rlv(i, j, k)*w(i, j, &
&           k, itu2))
! todo: save this in scratch
          arg1 = w(i, j, k, itransition2)/240.0 + 0.5
          re_theta_c = 0.67*w(i, j, k, itransition2) + 24.0*sin(arg1) + &
&           14.0
! todo: save this in scratch
          result1 = sqrt(scratch(i, j, k, istrain))
          re_s = w(i, j, k, irho)*result1*d2wall(i, j, k)**2/rev(i, j, k&
&           )
          f_length1 = exp(-(0.03*(w(i, j, k, itransition2)-460.0)))
          f_length = 44.0 - (44.0-(0.5-30000.0*(w(i, j, k, itransition2)&
&           -596.0)))/(1+f_length1)**(1/6)
! continue here
          arg1 = re_s/(2.6*re_theta_c)
          f_onset1 = sqrt(arg1)
          f_onset = (tanh(6.0*(f_onset1-1.35))+1.0)/2.0
          f_turb = (1-f_onset)*exp(-r_t)
! since we need to divide by rho, rho does not appear here anymore
          result1 = sqrt(scratch(i, j, k, istrain))
          arg1 = w(i, j, k, itransition1)*f_onset
          result2 = sqrt(arg1)
          p_gamma = f_length*rlmca1*w(i, j, k, irho)*result1*result2*(&
&           1.0-rlmce1*w(i, j, k, itransition1))
          e_gamma = rlmca2*w(i, j, k, irho)*vort*w(i, j, k, itransition1&
&           )*f_turb*(rlmce2*w(i, j, k, itransition1)-1.0)
! somewhere here is the problem regarding partials not matching
          p_thetat = rlmcthetat*w(i, j, k, irho)/t*(re_thetat_eq-w(i, j&
&           , k, itransition2))*(1.0-f_theta_t)
          scratch(i, j, k, istransition1) = (p_gamma-e_gamma)*rhoi
          scratch(i, j, k, istransition2) = p_thetat*rhoi
! print *, 'source terms: gamma, thetat', scratch(i, j, k, istransition1), scratch(i, j, k, istransition2)
        end do
      end do
    end do
  end subroutine gammarethetasource

!  differentiation of gammarethetaviscous in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *scratch
!   with respect to varying inputs: *rev *w *rlv *scratch *vol
!                *si *sj *sk
!   rw status of diff variables: *rev:in *w:in *rlv:in *scratch:in-out
!                *vol:in *si:in *sj:in *sk:in
!   plus diff mem management of: rev:in w:in rlv:in scratch:in
!                vol:in si:in sj:in sk:in
  subroutine gammarethetaviscous_d()
    use blockpointers
    use constants
    use variableconstants
    use paramturb
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rhoi
    real(kind=realtype) :: rhoid
    real(kind=realtype) :: voli, volmi, volpi
    real(kind=realtype) :: volid, volmid, volpid
    real(kind=realtype) :: xm, ym, zm, xp, yp, zp, xa, ya, za
    real(kind=realtype) :: xmd, ymd, zmd, xpd, ypd, zpd, xad, yad, zad
    real(kind=realtype) :: mulm, mulp, muem, muep
    real(kind=realtype) :: mulmd, mulpd, muemd, muepd
    real(kind=realtype) :: ttm, ttp
    real(kind=realtype) :: ttmd, ttpd
    real(kind=realtype) :: c1m, c1p, c10, c2m, c2p, c20
    real(kind=realtype) :: c1md, c1pd, c10d, c2md, c2pd, c20d
    real(kind=realtype) :: rblank
    real(kind=realtype) :: temp
    real(kind=realtype) :: temp0
    real(kind=realtype) :: temp1
!       advection and unsteady terms.
!
!
!       viscous terms in k-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in zeta-direction, i.e. along the
! line k = constant.
          temp = one/vol(i, j, k)
          volid = -(temp*vold(i, j, k)/vol(i, j, k))
          voli = temp
          temp = two/(vol(i, j, k)+vol(i, j, k-1))
          volmid = -(temp*(vold(i, j, k)+vold(i, j, k-1))/(vol(i, j, k)+&
&           vol(i, j, k-1)))
          volmi = temp
          temp = two/(vol(i, j, k)+vol(i, j, k+1))
          volpid = -(temp*(vold(i, j, k)+vold(i, j, k+1))/(vol(i, j, k)+&
&           vol(i, j, k+1)))
          volpi = temp
          temp = sk(i, j, k-1, 1)
          xmd = volmi*skd(i, j, k-1, 1) + temp*volmid
          xm = temp*volmi
          temp = sk(i, j, k-1, 2)
          ymd = volmi*skd(i, j, k-1, 2) + temp*volmid
          ym = temp*volmi
          temp = sk(i, j, k-1, 3)
          zmd = volmi*skd(i, j, k-1, 3) + temp*volmid
          zm = temp*volmi
          temp = sk(i, j, k, 1)
          xpd = volpi*skd(i, j, k, 1) + temp*volpid
          xp = temp*volpi
          temp = sk(i, j, k, 2)
          ypd = volpi*skd(i, j, k, 2) + temp*volpid
          yp = temp*volpi
          temp = sk(i, j, k, 3)
          zpd = volpi*skd(i, j, k, 3) + temp*volpid
          zp = temp*volpi
          temp = sk(i, j, k, 1) + sk(i, j, k-1, 1)
          xad = half*(voli*(skd(i, j, k, 1)+skd(i, j, k-1, 1))+temp*&
&           volid)
          xa = half*(temp*voli)
          temp = sk(i, j, k, 2) + sk(i, j, k-1, 2)
          yad = half*(voli*(skd(i, j, k, 2)+skd(i, j, k-1, 2))+temp*&
&           volid)
          ya = half*(temp*voli)
          temp = sk(i, j, k, 3) + sk(i, j, k-1, 3)
          zad = half*(voli*(skd(i, j, k, 3)+skd(i, j, k-1, 3))+temp*&
&           volid)
          za = half*(temp*voli)
          ttmd = xa*xmd + xm*xad + ya*ymd + ym*yad + za*zmd + zm*zad
          ttm = xm*xa + ym*ya + zm*za
          ttpd = xa*xpd + xp*xad + ya*ypd + yp*yad + za*zpd + zp*zad
          ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in zeta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in zeta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dzeta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the gamma-term.
          temp = one/w(i, j, k, irho)
          rhoid = -(temp*wd(i, j, k, irho)/w(i, j, k, irho))
          rhoi = temp
          mulmd = half*(rlvd(i, j, k-1)+rlvd(i, j, k))
          mulm = half*(rlv(i, j, k-1)+rlv(i, j, k))
          mulpd = half*(rlvd(i, j, k+1)+rlvd(i, j, k))
          mulp = half*(rlv(i, j, k+1)+rlv(i, j, k))
          muemd = half*(revd(i, j, k-1)+revd(i, j, k))
          muem = half*(rev(i, j, k-1)+rev(i, j, k))
          muepd = half*(revd(i, j, k+1)+revd(i, j, k))
          muep = half*(rev(i, j, k+1)+rev(i, j, k))
          temp = mulm + muem/rlmsigmaf
          c1md = ttm*rhoi*(mulmd+muemd/rlmsigmaf) + temp*(rhoi*ttmd+ttm*&
&           rhoid)
          c1m = temp*(ttm*rhoi)
          temp = mulp + muep/rlmsigmaf
          c1pd = ttp*rhoi*(mulpd+muepd/rlmsigmaf) + temp*(rhoi*ttpd+ttp*&
&           rhoid)
          c1p = temp*(ttp*rhoi)
          c10d = c1md + c1pd
          c10 = c1m + c1p
! and the re_theta_t term.
          muemd = half*(revd(i, j, k-1)+revd(i, j, k))
          muem = half*(rev(i, j, k-1)+rev(i, j, k))
          muepd = half*(revd(i, j, k+1)+revd(i, j, k))
          muep = half*(rev(i, j, k+1)+rev(i, j, k))
          c2md = rlmsigmathetat*(ttm*rhoi*(mulmd+muemd)+(mulm+muem)*(&
&           rhoi*ttmd+ttm*rhoid))
          c2m = ttm*rlmsigmathetat*(mulm+muem)*rhoi
          c2pd = rlmsigmathetat*(ttp*rhoi*(mulpd+muepd)+(mulp+muep)*(&
&           rhoi*ttpd+ttp*rhoid))
          c2p = ttp*rlmsigmathetat*(mulp+muep)*rhoi
          c20d = c2md + c2pd
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          temp = w(i, j, k-1, itransition1)
          temp0 = w(i, j, k+1, itransition1)
          temp1 = w(i, j, k, itransition1)
          scratchd(i, j, k, istransition1) = scratchd(i, j, k, &
&           istransition1) + temp*c1md + c1m*wd(i, j, k-1, itransition1)&
&           + temp0*c1pd + c1p*wd(i, j, k+1, itransition1) - temp1*c10d &
&           - c10*wd(i, j, k, itransition1)
          scratch(i, j, k, istransition1) = scratch(i, j, k, &
&           istransition1) + c1m*temp + c1p*temp0 - c10*temp1
          temp1 = w(i, j, k-1, itransition2)
          temp0 = w(i, j, k+1, itransition2)
          temp = w(i, j, k, itransition2)
          scratchd(i, j, k, istransition2) = scratchd(i, j, k, &
&           istransition2) + temp1*c2md + c2m*wd(i, j, k-1, itransition2&
&           ) + temp0*c2pd + c2p*wd(i, j, k+1, itransition2) - temp*c20d&
&           - c20*wd(i, j, k, itransition2)
          scratch(i, j, k, istransition2) = scratch(i, j, k, &
&           istransition2) + c2m*temp1 + c2p*temp0 - c20*temp
! #ifndef 1
!                         b1 = -c1m
!                         c1 = c10
!                         d1 = -c1p
!                         b2 = -c2m
!                         c2 = c20
!                         d2 = -c2p
!                         ! update the central jacobian. for nonboundary cells this
!                         ! is simply c1 and c2. for boundary cells this is slightly
!                         ! more complicated, because the boundary conditions are
!                         ! treated implicitly and the off-diagonal terms b1, b2 and
!                         ! d1, d2 must be taken into account.
!                         ! the boundary conditions are only treated implicitly if
!                         ! the diagonal dominance of the matrix is increased.
!                         if (k == 2) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - b1 * max(bmtk1(i, j, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - b1 * bmtk1(i, j, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - b2 * bmtk1(i, j, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - b2 * max(bmtk1(i, j, itu2, itu2), zero)
!                         else if (k == kl) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - d1 * max(bmtk2(i, j, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - d1 * bmtk2(i, j, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - d2 * bmtk2(i, j, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - d2 * max(bmtk2(i, j, itu2, itu2), zero)
!                         else
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2
!                         end if
! #endif
        end do
      end do
    end do
!
!       viscous terms in j-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in eta-direction, i.e. along the
! line j = constant.
          temp1 = one/vol(i, j, k)
          volid = -(temp1*vold(i, j, k)/vol(i, j, k))
          voli = temp1
          temp1 = two/(vol(i, j, k)+vol(i, j-1, k))
          volmid = -(temp1*(vold(i, j, k)+vold(i, j-1, k))/(vol(i, j, k)&
&           +vol(i, j-1, k)))
          volmi = temp1
          temp1 = two/(vol(i, j, k)+vol(i, j+1, k))
          volpid = -(temp1*(vold(i, j, k)+vold(i, j+1, k))/(vol(i, j, k)&
&           +vol(i, j+1, k)))
          volpi = temp1
          temp1 = sj(i, j-1, k, 1)
          xmd = volmi*sjd(i, j-1, k, 1) + temp1*volmid
          xm = temp1*volmi
          temp1 = sj(i, j-1, k, 2)
          ymd = volmi*sjd(i, j-1, k, 2) + temp1*volmid
          ym = temp1*volmi
          temp1 = sj(i, j-1, k, 3)
          zmd = volmi*sjd(i, j-1, k, 3) + temp1*volmid
          zm = temp1*volmi
          temp1 = sj(i, j, k, 1)
          xpd = volpi*sjd(i, j, k, 1) + temp1*volpid
          xp = temp1*volpi
          temp1 = sj(i, j, k, 2)
          ypd = volpi*sjd(i, j, k, 2) + temp1*volpid
          yp = temp1*volpi
          temp1 = sj(i, j, k, 3)
          zpd = volpi*sjd(i, j, k, 3) + temp1*volpid
          zp = temp1*volpi
          temp1 = sj(i, j, k, 1) + sj(i, j-1, k, 1)
          xad = half*(voli*(sjd(i, j, k, 1)+sjd(i, j-1, k, 1))+temp1*&
&           volid)
          xa = half*(temp1*voli)
          temp1 = sj(i, j, k, 2) + sj(i, j-1, k, 2)
          yad = half*(voli*(sjd(i, j, k, 2)+sjd(i, j-1, k, 2))+temp1*&
&           volid)
          ya = half*(temp1*voli)
          temp1 = sj(i, j, k, 3) + sj(i, j-1, k, 3)
          zad = half*(voli*(sjd(i, j, k, 3)+sjd(i, j-1, k, 3))+temp1*&
&           volid)
          za = half*(temp1*voli)
          ttmd = xa*xmd + xm*xad + ya*ymd + ym*yad + za*zmd + zm*zad
          ttm = xm*xa + ym*ya + zm*za
          ttpd = xa*xpd + xp*xad + ya*ypd + yp*yad + za*zpd + zp*zad
          ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in eta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in eta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/deta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the gamma-term.
          temp1 = one/w(i, j, k, irho)
          rhoid = -(temp1*wd(i, j, k, irho)/w(i, j, k, irho))
          rhoi = temp1
          mulmd = half*(rlvd(i, j-1, k)+rlvd(i, j, k))
          mulm = half*(rlv(i, j-1, k)+rlv(i, j, k))
          mulpd = half*(rlvd(i, j+1, k)+rlvd(i, j, k))
          mulp = half*(rlv(i, j+1, k)+rlv(i, j, k))
          muemd = half*(revd(i, j-1, k)+revd(i, j, k))
          muem = half*(rev(i, j-1, k)+rev(i, j, k))
          muepd = half*(revd(i, j+1, k)+revd(i, j, k))
          muep = half*(rev(i, j+1, k)+rev(i, j, k))
          temp1 = mulm + muem/rlmsigmaf
          c1md = ttm*rhoi*(mulmd+muemd/rlmsigmaf) + temp1*(rhoi*ttmd+ttm&
&           *rhoid)
          c1m = temp1*(ttm*rhoi)
          temp1 = mulp + muep/rlmsigmaf
          c1pd = ttp*rhoi*(mulpd+muepd/rlmsigmaf) + temp1*(rhoi*ttpd+ttp&
&           *rhoid)
          c1p = temp1*(ttp*rhoi)
          c10d = c1md + c1pd
          c10 = c1m + c1p
! and the re_theta_t term.
          muemd = half*(revd(i, j-1, k)+revd(i, j, k))
          muem = half*(rev(i, j-1, k)+rev(i, j, k))
          muepd = half*(revd(i, j+1, k)+revd(i, j, k))
          muep = half*(rev(i, j+1, k)+rev(i, j, k))
          c2md = rlmsigmathetat*(ttm*rhoi*(mulmd+muemd)+(mulm+muem)*(&
&           rhoi*ttmd+ttm*rhoid))
          c2m = ttm*rlmsigmathetat*(mulm+muem)*rhoi
          c2pd = rlmsigmathetat*(ttp*rhoi*(mulpd+muepd)+(mulp+muep)*(&
&           rhoi*ttpd+ttp*rhoid))
          c2p = ttp*rlmsigmathetat*(mulp+muep)*rhoi
          c20d = c2md + c2pd
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          temp1 = w(i, j-1, k, itransition1)
          temp0 = w(i, j+1, k, itransition1)
          temp = w(i, j, k, itransition1)
          scratchd(i, j, k, istransition1) = scratchd(i, j, k, &
&           istransition1) + temp1*c1md + c1m*wd(i, j-1, k, itransition1&
&           ) + temp0*c1pd + c1p*wd(i, j+1, k, itransition1) - temp*c10d&
&           - c10*wd(i, j, k, itransition1)
          scratch(i, j, k, istransition1) = scratch(i, j, k, &
&           istransition1) + c1m*temp1 + c1p*temp0 - c10*temp
          temp1 = w(i, j-1, k, itransition2)
          temp0 = w(i, j+1, k, itransition2)
          temp = w(i, j, k, itransition2)
          scratchd(i, j, k, istransition2) = scratchd(i, j, k, &
&           istransition2) + temp1*c2md + c2m*wd(i, j-1, k, itransition2&
&           ) + temp0*c2pd + c2p*wd(i, j+1, k, itransition2) - temp*c20d&
&           - c20*wd(i, j, k, itransition2)
          scratch(i, j, k, istransition2) = scratch(i, j, k, &
&           istransition2) + c2m*temp1 + c2p*temp0 - c20*temp
! #ifndef 1
!                         b1 = -c1m
!                         c1 = c10
!                         d1 = -c1p
!                         b2 = -c2m
!                         c2 = c20
!                         d2 = -c2p
!                         ! update the central jacobian. for nonboundary cells this
!                         ! is simply c1 and c2. for boundary cells this is slightly
!                         ! more complicated, because the boundary conditions are
!                         ! treated implicitly and the off-diagonal terms b1, b2 and
!                         ! d1, d2 must be taken into account.
!                         ! the boundary conditions are only treated implicitly if
!                         ! the diagonal dominance of the matrix is increased.
!                         if (j == 2) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - b1 * max(bmtj1(i, k, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - b1 * bmtj1(i, k, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - b2 * bmtj1(i, k, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - b2 * max(bmtj1(i, k, itu2, itu2), zero)
!                         else if (j == jl) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - d1 * max(bmtj2(i, k, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - d1 * bmtj2(i, k, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - d2 * bmtj2(i, k, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - d2 * max(bmtj2(i, k, itu2, itu2), zero)
!                         else
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2
!                         end if
! #endif
        end do
      end do
    end do
!
!       viscous terms in i-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in xi-direction, i.e. along the
! line i = constant.
          temp1 = one/vol(i, j, k)
          volid = -(temp1*vold(i, j, k)/vol(i, j, k))
          voli = temp1
          temp1 = two/(vol(i, j, k)+vol(i-1, j, k))
          volmid = -(temp1*(vold(i, j, k)+vold(i-1, j, k))/(vol(i, j, k)&
&           +vol(i-1, j, k)))
          volmi = temp1
          temp1 = two/(vol(i, j, k)+vol(i+1, j, k))
          volpid = -(temp1*(vold(i, j, k)+vold(i+1, j, k))/(vol(i, j, k)&
&           +vol(i+1, j, k)))
          volpi = temp1
          temp1 = si(i-1, j, k, 1)
          xmd = volmi*sid(i-1, j, k, 1) + temp1*volmid
          xm = temp1*volmi
          temp1 = si(i-1, j, k, 2)
          ymd = volmi*sid(i-1, j, k, 2) + temp1*volmid
          ym = temp1*volmi
          temp1 = si(i-1, j, k, 3)
          zmd = volmi*sid(i-1, j, k, 3) + temp1*volmid
          zm = temp1*volmi
          temp1 = si(i, j, k, 1)
          xpd = volpi*sid(i, j, k, 1) + temp1*volpid
          xp = temp1*volpi
          temp1 = si(i, j, k, 2)
          ypd = volpi*sid(i, j, k, 2) + temp1*volpid
          yp = temp1*volpi
          temp1 = si(i, j, k, 3)
          zpd = volpi*sid(i, j, k, 3) + temp1*volpid
          zp = temp1*volpi
          temp1 = si(i, j, k, 1) + si(i-1, j, k, 1)
          xad = half*(voli*(sid(i, j, k, 1)+sid(i-1, j, k, 1))+temp1*&
&           volid)
          xa = half*(temp1*voli)
          temp1 = si(i, j, k, 2) + si(i-1, j, k, 2)
          yad = half*(voli*(sid(i, j, k, 2)+sid(i-1, j, k, 2))+temp1*&
&           volid)
          ya = half*(temp1*voli)
          temp1 = si(i, j, k, 3) + si(i-1, j, k, 3)
          zad = half*(voli*(sid(i, j, k, 3)+sid(i-1, j, k, 3))+temp1*&
&           volid)
          za = half*(temp1*voli)
          ttmd = xa*xmd + xm*xad + ya*ymd + ym*yad + za*zmd + zm*zad
          ttm = xm*xa + ym*ya + zm*za
          ttpd = xa*xpd + xp*xad + ya*ypd + yp*yad + za*zpd + zp*zad
          ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in xi-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in xi-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dxi derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the gamma-term.
          temp1 = one/w(i, j, k, irho)
          rhoid = -(temp1*wd(i, j, k, irho)/w(i, j, k, irho))
          rhoi = temp1
          mulmd = half*(rlvd(i-1, j, k)+rlvd(i, j, k))
          mulm = half*(rlv(i-1, j, k)+rlv(i, j, k))
          mulpd = half*(rlvd(i+1, j, k)+rlvd(i, j, k))
          mulp = half*(rlv(i+1, j, k)+rlv(i, j, k))
          muemd = half*(revd(i-1, j, k)+revd(i, j, k))
          muem = half*(rev(i-1, j, k)+rev(i, j, k))
          muepd = half*(revd(i+1, j, k)+revd(i, j, k))
          muep = half*(rev(i+1, j, k)+rev(i, j, k))
          temp1 = mulm + muem/rlmsigmaf
          c1md = ttm*rhoi*(mulmd+muemd/rlmsigmaf) + temp1*(rhoi*ttmd+ttm&
&           *rhoid)
          c1m = temp1*(ttm*rhoi)
          temp1 = mulp + muep/rlmsigmaf
          c1pd = ttp*rhoi*(mulpd+muepd/rlmsigmaf) + temp1*(rhoi*ttpd+ttp&
&           *rhoid)
          c1p = temp1*(ttp*rhoi)
          c10d = c1md + c1pd
          c10 = c1m + c1p
! and the re_theta_t term.
          muemd = half*(revd(i-1, j, k)+revd(i, j, k))
          muem = half*(rev(i-1, j, k)+rev(i, j, k))
          muepd = half*(revd(i+1, j, k)+revd(i, j, k))
          muep = half*(rev(i+1, j, k)+rev(i, j, k))
          c2md = rlmsigmathetat*(ttm*rhoi*(mulmd+muemd)+(mulm+muem)*(&
&           rhoi*ttmd+ttm*rhoid))
          c2m = ttm*rlmsigmathetat*(mulm+muem)*rhoi
          c2pd = rlmsigmathetat*(ttp*rhoi*(mulpd+muepd)+(mulp+muep)*(&
&           rhoi*ttpd+ttp*rhoid))
          c2p = ttp*rlmsigmathetat*(mulp+muep)*rhoi
          c20d = c2md + c2pd
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          temp1 = w(i-1, j, k, itransition1)
          temp0 = w(i+1, j, k, itransition1)
          temp = w(i, j, k, itransition1)
          scratchd(i, j, k, istransition1) = scratchd(i, j, k, &
&           istransition1) + temp1*c1md + c1m*wd(i-1, j, k, itransition1&
&           ) + temp0*c1pd + c1p*wd(i+1, j, k, itransition1) - temp*c10d&
&           - c10*wd(i, j, k, itransition1)
          scratch(i, j, k, istransition1) = scratch(i, j, k, &
&           istransition1) + c1m*temp1 + c1p*temp0 - c10*temp
          temp1 = w(i-1, j, k, itransition2)
          temp0 = w(i+1, j, k, itransition2)
          temp = w(i, j, k, itransition2)
          scratchd(i, j, k, istransition2) = scratchd(i, j, k, &
&           istransition2) + temp1*c2md + c2m*wd(i-1, j, k, itransition2&
&           ) + temp0*c2pd + c2p*wd(i+1, j, k, itransition2) - temp*c20d&
&           - c20*wd(i, j, k, itransition2)
          scratch(i, j, k, istransition2) = scratch(i, j, k, &
&           istransition2) + c2m*temp1 + c2p*temp0 - c20*temp
! #ifndef 1
!                         b1 = -c1m
!                         c1 = c10
!                         d1 = -c1p
!                         b2 = -c2m
!                         c2 = c20
!                         d2 = -c2p
!                         ! update the central jacobian. for nonboundary cells this
!                         ! is simply c1 and c2. for boundary cells this is slightly
!                         ! more complicated, because the boundary conditions are
!                         ! treated implicitly and the off-diagonal terms b1, b2 and
!                         ! d1, d2 must be taken into account.
!                         ! the boundary conditions are only treated implicitly if
!                         ! the diagonal dominance of the matrix is increased.
!                         if (i == 2) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - b1 * max(bmti1(j, k, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - b1 * bmti1(j, k, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - b2 * bmti1(j, k, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - b2 * max(bmti1(j, k, itu2, itu2), zero)
!                         else if (i == il) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - d1 * max(bmti2(j, k, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - d1 * bmti2(j, k, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - d2 * bmti2(j, k, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - d2 * max(bmti2(j, k, itu2, itu2), zero)
!                         else
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2
!                         end if
! #endif
        end do
      end do
    end do
  end subroutine gammarethetaviscous_d

  subroutine gammarethetaviscous()
    use blockpointers
    use constants
    use variableconstants
    use paramturb
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rhoi
    real(kind=realtype) :: voli, volmi, volpi
    real(kind=realtype) :: xm, ym, zm, xp, yp, zp, xa, ya, za
    real(kind=realtype) :: mulm, mulp, muem, muep
    real(kind=realtype) :: ttm, ttp
    real(kind=realtype) :: c1m, c1p, c10, c2m, c2p, c20
    real(kind=realtype) :: rblank
!       advection and unsteady terms.
!
!
!       viscous terms in k-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in zeta-direction, i.e. along the
! line k = constant.
          voli = one/vol(i, j, k)
          volmi = two/(vol(i, j, k)+vol(i, j, k-1))
          volpi = two/(vol(i, j, k)+vol(i, j, k+1))
          xm = sk(i, j, k-1, 1)*volmi
          ym = sk(i, j, k-1, 2)*volmi
          zm = sk(i, j, k-1, 3)*volmi
          xp = sk(i, j, k, 1)*volpi
          yp = sk(i, j, k, 2)*volpi
          zp = sk(i, j, k, 3)*volpi
          xa = half*(sk(i, j, k, 1)+sk(i, j, k-1, 1))*voli
          ya = half*(sk(i, j, k, 2)+sk(i, j, k-1, 2))*voli
          za = half*(sk(i, j, k, 3)+sk(i, j, k-1, 3))*voli
          ttm = xm*xa + ym*ya + zm*za
          ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in zeta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in zeta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dzeta^2 = d/dzeta (d/dzeta k+1/2 - d/dzeta k-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dzeta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the gamma-term.
          rhoi = one/w(i, j, k, irho)
          mulm = half*(rlv(i, j, k-1)+rlv(i, j, k))
          mulp = half*(rlv(i, j, k+1)+rlv(i, j, k))
          muem = half*(rev(i, j, k-1)+rev(i, j, k))
          muep = half*(rev(i, j, k+1)+rev(i, j, k))
          c1m = ttm*(mulm+muem/rlmsigmaf)*rhoi
          c1p = ttp*(mulp+muep/rlmsigmaf)*rhoi
          c10 = c1m + c1p
! and the re_theta_t term.
          muem = half*(rev(i, j, k-1)+rev(i, j, k))
          muep = half*(rev(i, j, k+1)+rev(i, j, k))
          c2m = ttm*rlmsigmathetat*(mulm+muem)*rhoi
          c2p = ttp*rlmsigmathetat*(mulp+muep)*rhoi
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          scratch(i, j, k, istransition1) = scratch(i, j, k, &
&           istransition1) + c1m*w(i, j, k-1, itransition1) - c10*w(i, j&
&           , k, itransition1) + c1p*w(i, j, k+1, itransition1)
          scratch(i, j, k, istransition2) = scratch(i, j, k, &
&           istransition2) + c2m*w(i, j, k-1, itransition2) - c20*w(i, j&
&           , k, itransition2) + c2p*w(i, j, k+1, itransition2)
! #ifndef 1
!                         b1 = -c1m
!                         c1 = c10
!                         d1 = -c1p
!                         b2 = -c2m
!                         c2 = c20
!                         d2 = -c2p
!                         ! update the central jacobian. for nonboundary cells this
!                         ! is simply c1 and c2. for boundary cells this is slightly
!                         ! more complicated, because the boundary conditions are
!                         ! treated implicitly and the off-diagonal terms b1, b2 and
!                         ! d1, d2 must be taken into account.
!                         ! the boundary conditions are only treated implicitly if
!                         ! the diagonal dominance of the matrix is increased.
!                         if (k == 2) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - b1 * max(bmtk1(i, j, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - b1 * bmtk1(i, j, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - b2 * bmtk1(i, j, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - b2 * max(bmtk1(i, j, itu2, itu2), zero)
!                         else if (k == kl) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - d1 * max(bmtk2(i, j, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - d1 * bmtk2(i, j, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - d2 * bmtk2(i, j, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - d2 * max(bmtk2(i, j, itu2, itu2), zero)
!                         else
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2
!                         end if
! #endif
        end do
      end do
    end do
!
!       viscous terms in j-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in eta-direction, i.e. along the
! line j = constant.
          voli = one/vol(i, j, k)
          volmi = two/(vol(i, j, k)+vol(i, j-1, k))
          volpi = two/(vol(i, j, k)+vol(i, j+1, k))
          xm = sj(i, j-1, k, 1)*volmi
          ym = sj(i, j-1, k, 2)*volmi
          zm = sj(i, j-1, k, 3)*volmi
          xp = sj(i, j, k, 1)*volpi
          yp = sj(i, j, k, 2)*volpi
          zp = sj(i, j, k, 3)*volpi
          xa = half*(sj(i, j, k, 1)+sj(i, j-1, k, 1))*voli
          ya = half*(sj(i, j, k, 2)+sj(i, j-1, k, 2))*voli
          za = half*(sj(i, j, k, 3)+sj(i, j-1, k, 3))*voli
          ttm = xm*xa + ym*ya + zm*za
          ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in eta-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in eta-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/deta^2 = d/deta (d/deta j+1/2 - d/deta j-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/deta derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the gamma-term.
          rhoi = one/w(i, j, k, irho)
          mulm = half*(rlv(i, j-1, k)+rlv(i, j, k))
          mulp = half*(rlv(i, j+1, k)+rlv(i, j, k))
          muem = half*(rev(i, j-1, k)+rev(i, j, k))
          muep = half*(rev(i, j+1, k)+rev(i, j, k))
          c1m = ttm*(mulm+muem/rlmsigmaf)*rhoi
          c1p = ttp*(mulp+muep/rlmsigmaf)*rhoi
          c10 = c1m + c1p
! and the re_theta_t term.
          muem = half*(rev(i, j-1, k)+rev(i, j, k))
          muep = half*(rev(i, j+1, k)+rev(i, j, k))
          c2m = ttm*rlmsigmathetat*(mulm+muem)*rhoi
          c2p = ttp*rlmsigmathetat*(mulp+muep)*rhoi
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          scratch(i, j, k, istransition1) = scratch(i, j, k, &
&           istransition1) + c1m*w(i, j-1, k, itransition1) - c10*w(i, j&
&           , k, itransition1) + c1p*w(i, j+1, k, itransition1)
          scratch(i, j, k, istransition2) = scratch(i, j, k, &
&           istransition2) + c2m*w(i, j-1, k, itransition2) - c20*w(i, j&
&           , k, itransition2) + c2p*w(i, j+1, k, itransition2)
! #ifndef 1
!                         b1 = -c1m
!                         c1 = c10
!                         d1 = -c1p
!                         b2 = -c2m
!                         c2 = c20
!                         d2 = -c2p
!                         ! update the central jacobian. for nonboundary cells this
!                         ! is simply c1 and c2. for boundary cells this is slightly
!                         ! more complicated, because the boundary conditions are
!                         ! treated implicitly and the off-diagonal terms b1, b2 and
!                         ! d1, d2 must be taken into account.
!                         ! the boundary conditions are only treated implicitly if
!                         ! the diagonal dominance of the matrix is increased.
!                         if (j == 2) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - b1 * max(bmtj1(i, k, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - b1 * bmtj1(i, k, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - b2 * bmtj1(i, k, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - b2 * max(bmtj1(i, k, itu2, itu2), zero)
!                         else if (j == jl) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - d1 * max(bmtj2(i, k, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - d1 * bmtj2(i, k, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - d2 * bmtj2(i, k, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - d2 * max(bmtj2(i, k, itu2, itu2), zero)
!                         else
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2
!                         end if
! #endif
        end do
      end do
    end do
!
!       viscous terms in i-direction.
!
    do k=2,kl
      do j=2,jl
        do i=2,il
! compute the metrics in xi-direction, i.e. along the
! line i = constant.
          voli = one/vol(i, j, k)
          volmi = two/(vol(i, j, k)+vol(i-1, j, k))
          volpi = two/(vol(i, j, k)+vol(i+1, j, k))
          xm = si(i-1, j, k, 1)*volmi
          ym = si(i-1, j, k, 2)*volmi
          zm = si(i-1, j, k, 3)*volmi
          xp = si(i, j, k, 1)*volpi
          yp = si(i, j, k, 2)*volpi
          zp = si(i, j, k, 3)*volpi
          xa = half*(si(i, j, k, 1)+si(i-1, j, k, 1))*voli
          ya = half*(si(i, j, k, 2)+si(i-1, j, k, 2))*voli
          za = half*(si(i, j, k, 3)+si(i-1, j, k, 3))*voli
          ttm = xm*xa + ym*ya + zm*za
          ttp = xp*xa + yp*ya + zp*za
! computation of the viscous terms in xi-direction; note
! that cross-derivatives are neglected, i.e. the mesh is
! assumed to be orthogonal.
! the second derivative in xi-direction is constructed as
! the central difference of the first order derivatives, i.e.
! d^2/dxi^2 = d/dxi (d/dxi i+1/2 - d/dxi i-1/2).
! in this way the metric as well as the varying viscosity
! can be taken into account; the latter appears inside the
! d/dxi derivative. the whole term is divided by rho to
! obtain the diffusion term for k and omega.
! first the gamma-term.
          rhoi = one/w(i, j, k, irho)
          mulm = half*(rlv(i-1, j, k)+rlv(i, j, k))
          mulp = half*(rlv(i+1, j, k)+rlv(i, j, k))
          muem = half*(rev(i-1, j, k)+rev(i, j, k))
          muep = half*(rev(i+1, j, k)+rev(i, j, k))
          c1m = ttm*(mulm+muem/rlmsigmaf)*rhoi
          c1p = ttp*(mulp+muep/rlmsigmaf)*rhoi
          c10 = c1m + c1p
! and the re_theta_t term.
          muem = half*(rev(i-1, j, k)+rev(i, j, k))
          muep = half*(rev(i+1, j, k)+rev(i, j, k))
          c2m = ttm*rlmsigmathetat*(mulm+muem)*rhoi
          c2p = ttp*rlmsigmathetat*(mulp+muep)*rhoi
          c20 = c2m + c2p
! update the residual for this cell and store the possible
! coefficients for the matrix in b1, b2, c1, c2, d1 and d2.
          scratch(i, j, k, istransition1) = scratch(i, j, k, &
&           istransition1) + c1m*w(i-1, j, k, itransition1) - c10*w(i, j&
&           , k, itransition1) + c1p*w(i+1, j, k, itransition1)
          scratch(i, j, k, istransition2) = scratch(i, j, k, &
&           istransition2) + c2m*w(i-1, j, k, itransition2) - c20*w(i, j&
&           , k, itransition2) + c2p*w(i+1, j, k, itransition2)
! #ifndef 1
!                         b1 = -c1m
!                         c1 = c10
!                         d1 = -c1p
!                         b2 = -c2m
!                         c2 = c20
!                         d2 = -c2p
!                         ! update the central jacobian. for nonboundary cells this
!                         ! is simply c1 and c2. for boundary cells this is slightly
!                         ! more complicated, because the boundary conditions are
!                         ! treated implicitly and the off-diagonal terms b1, b2 and
!                         ! d1, d2 must be taken into account.
!                         ! the boundary conditions are only treated implicitly if
!                         ! the diagonal dominance of the matrix is increased.
!                         if (i == 2) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - b1 * max(bmti1(j, k, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - b1 * bmti1(j, k, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - b2 * bmti1(j, k, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - b2 * max(bmti1(j, k, itu2, itu2), zero)
!                         else if (i == il) then
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1 &
!                                                 - d1 * max(bmti2(j, k, itu1, itu1), zero)
!                             qq(i, j, k, 1, 2) = qq(i, j, k, 1, 2) - d1 * bmti2(j, k, itu1, itu2)
!                             qq(i, j, k, 2, 1) = qq(i, j, k, 2, 1) - d2 * bmti2(j, k, itu2, itu1)
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2 &
!                                                 - d2 * max(bmti2(j, k, itu2, itu2), zero)
!                         else
!                             qq(i, j, k, 1, 1) = qq(i, j, k, 1, 1) + c1
!                             qq(i, j, k, 2, 2) = qq(i, j, k, 2, 2) + c2
!                         end if
! #endif
        end do
      end do
    end do
  end subroutine gammarethetaviscous

!  differentiation of gammarethetaresscale in forward (tangent) mode (with options i4 dr8 r8):
!   variations   of useful results: *dw
!   with respect to varying inputs: *dw *scratch
!   rw status of diff variables: *dw:in-out *scratch:in
!   plus diff mem management of: dw:in scratch:in
  subroutine gammarethetaresscale_d()
    use blockpointers
    use constants
    use variableconstants
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rblank
    intrinsic real
    real(kind=realtype) :: temp
! multiply the residual by the volume and store this in dw; this
! is done for monitoring reasons only. the multiplication with the
! volume is present to be consistent with the flow residuals; also
! the negative value is taken, again to be consistent with the
! flow equations. also multiply by iblank so that no updates occur
! in holes or the overset boundary.
    do k=2,kl
      do j=2,jl
        do i=2,il
          rblank = real(iblank(i, j, k), realtype)
          temp = volref(i, j, k)*rblank
          dwd(i, j, k, itransition1) = -(temp*scratchd(i, j, k, &
&           istransition1))
          dw(i, j, k, itransition1) = -(temp*scratch(i, j, k, &
&           istransition1))
          temp = volref(i, j, k)*rblank
          dwd(i, j, k, itransition2) = -(temp*scratchd(i, j, k, &
&           istransition2))
          dw(i, j, k, itransition2) = -(temp*scratch(i, j, k, &
&           istransition2))
! print *, 'dw transition 1 & 2', dw(i, j, k, itransition1), dw(i, j, k, itransition2)
        end do
      end do
    end do
  end subroutine gammarethetaresscale_d

  subroutine gammarethetaresscale()
    use blockpointers
    use constants
    use variableconstants
    implicit none
!
!      local variables.
!
    integer(kind=inttype) :: i, j, k, ii
    real(kind=realtype) :: rblank
    intrinsic real
! multiply the residual by the volume and store this in dw; this
! is done for monitoring reasons only. the multiplication with the
! volume is present to be consistent with the flow residuals; also
! the negative value is taken, again to be consistent with the
! flow equations. also multiply by iblank so that no updates occur
! in holes or the overset boundary.
    do k=2,kl
      do j=2,jl
        do i=2,il
          rblank = real(iblank(i, j, k), realtype)
          dw(i, j, k, itransition1) = -(volref(i, j, k)*scratch(i, j, k&
&           , istransition1)*rblank)
          dw(i, j, k, itransition2) = -(volref(i, j, k)*scratch(i, j, k&
&           , istransition2)*rblank)
! print *, 'dw transition 1 & 2', dw(i, j, k, itransition1), dw(i, j, k, itransition2)
        end do
      end do
    end do
  end subroutine gammarethetaresscale

end module gammarethetamodel_d

